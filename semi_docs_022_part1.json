{
  "doc_id": "semi_docs_022",
  "chunk_id": 1,
  "content": "SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts (Part 7)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts\n\nContent: — The transport module is responsible for transfer of material from one clusterattached module to another. It consists of a robotic handler capable of exchanging material with each of the attached modules at the interface flanges. It can be a variety of physical topologies (radial or linear, for example). In SEMI standard cluster tools, the transport module has an interface isolation valve at each point of attachment to the attached modules. The transport module is responsible for managing constraints on the simultaneous opening of isolation valves as it relates to contamination of the transport module's environment by that of an attached module, as well as cross contamination between attached modules. The attributes of modules and related objects in Figure 5 are not standardized as these objects are equipment and process-dependent. 7.1.2 Material Model — Material is received from the factory, in a carrier or singly, at an intertool port resource. They are transported within the cluster and processed by\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts (Part 8)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts\n\nContent: processing resources. Once processed, they are returned to the factory at the same, or another, intertool port resource. The processing which is to be performed on material is determined from the process specification for that material. The material model in Figure 6 establishes the relationships between the material and material locations. Two material types are of interest in cluster tool module communications, single material and carriers. Single material may be grouped in carriers. This is modeled by defining the material slot object, which is a type of material location. A carrier is made up of an ordered set of material slots. A single material occupies a material slot when in the carrier. In addition, a single material may be assigned a particular material slot which it does not yet occupy, indicating that it is to be received into that material slot when it arrives. Carriers may be cassettes used to transport single material in the factory and to input single material to the cluster tool, or they may be\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts (Part 9)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts\n\nContent: material boats in batch process modules. The attributes of the material slot object are standardized to enable mapping of single material in carriers. Other objects in the diagram are not standardized. However, the identifier of the material, MaterialID, is an attribute of the material slot object. Other materials (consumable gases and fluids, etc.) are present in the cluster tool, but outside the scope of these standards. 7.1.3 Material Processing Model — The material processing model in Figure 7 shows the use of the process job to direct the processing resource to apply the appropriate process, as specified by the recipe, to one or more materials in a process module. A processing resource in a process module has processing capabilities which are specified by corresponding recipes. A process job can control multiple material only if identical processing is applied to all. Processing should begin and end simultaneously, synchronized with the arrival of the whole group of material. The process job lifecycle\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts (Part 10)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts\n\nContent: extends beyond the active processing of the material. It exists from just before material arrival at the intratool port resource, through setup and processing, and until just after the material departure at the same, or another, intratool port resource. This allows for material-related pre-conditioning and post-conditioning of the processing resource before the material is received and after it is sent. As material input and output is controlled by the intratool port resource, it is the responsibility of the process module to ensure coordination of the intratool port and processing resources. This is the model used to establish the Processing Management definition. There is no standardization beyond creation and control (starting, canceling, stopping, aborting, and pausing) of the high-level process job since the low-level control of process modules is application-dependent. There is a component of scheduling embodied in this model. The material, recipes, and processing resources are scheduled by the cluster\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts (Part 11)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts\n\nContent: controller according to the process specification to a particular process module through the use of the process job. In order to perform the required processing, material is transferred to the processing resource, as directed by the cluster controller. 7.1.4 Material Movement Models — Material movement in a cluster tool includes all services required within the cluster tool to move material from the factory to a sequence of process modules in order to be processed and then back to the factory. Material is moved individually within a cluster tool and may be received from the factory in cassettes or individually. The material movement model is divided into three parts as follows: intratool material movement defines the transfer of material between attached modules, with the transfer agent being a transport module. intertool material movement defines the exchange of carriers and single material with the factory at the cluster tool cassette module. carrier mapping defines presence and identifiers of single material\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts (Part 12)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts\n\nContent: contained in carriers. These three models are used to establish the Material Movement Management definition within a cluster tool. 7.1.4.1 Intratool Material Transfer — The intratool material movement model is shown in Figure 8. An intratool material transfer is the movement of material from one attached module to another attached module through the linking transport module. The cluster controller schedules an intratool material transfer job when intratool material transfer is required. This is achieved by TM and AM transfer jobs assigned to the appropriate module resource in each of the participating modules: • to the transfer resource in the transport module to get the material from the source attached module and put it into the destination attached module. to the intratool port resource in the source attached module to send the material to the transport module. to the intratool port resource in the destination attached module to receive the material from the transport module. Transfer jobs are made up of\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts (Part 13)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts\n\nContent: atomic transfers. An atomic transfer in one transfer partner synchronizes with the corresponding atomic transfer in the other partner to achieve the material transfer through handoff micro moves. In a cluster tool, the attached module is the primary partner, requesting the handoff micro moves, and the transport module is the secondary partner achieving those micro moves by controlling the end effector on which the material is transported. The transport module is responsible for managing constraints on the simultaneous opening of isolation valves as it relates to contamination of the transport module's environment by that of an attached module, as well as cross contamination between modules. The attached module ensures that its environment will not contaminate the transport module before synchronizing for handoff. The rules for re-establishing isolation at verification are determined by the transport module. 7.1.4.2 Intertool Material Transfer — The cassette module performs material exchange with the factory.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts (Part 14)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts\n\nContent: The material generally consists of cassettes with single material or empty cassettes, but may be individual single material. The intertool material movement model, shown in Figure 9, is similar to the intratool material movement model. An intertool material transfer is a transfer in the factory which includes the cluster tool as one of the transfer partners. In the cluster tool, the cluster controller schedules an intertool material transfer job when material exchange with the factory is required. This job may be an element of a factory material transfer job in which the cluster tool is a partner. The intertool material transfer job is achieved by a CM input/output transfer job assigned to the intertool port resource in the participating cassette module. It defines the material exchange with the factory for the cassette module. The CM input/output transfer job comprises an atomic transfer, which defines the roles in the material handoff. In the cassette module, material transfer with the transport module is\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts (Part 15)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts\n\nContent: controlled by the intratool port resource. It is the responsibility of the cassette module to coordinate its intertool and intratool port resources. The factory transfer resource may be an operator, SMIF, AGV, or other mechanism. Its definition, associated transfer jobs, and the handoff, are beyond the scope of this standard. Factory material movement may be achieved automatically using applicable SEMI standards. 7.1.4.3 Carrier Mapping — The final element of material movement in a cluster tool is the mapping of single material in a carrier. Once a cassette is received by the cluster tool, it is necessary to communicate the presence and identifiers of the material it contains. Batch process modules also require these carrier mapping services in order to define loading of the process carrier. In carrier mapping, the carrier may be a cassette used to hold single material loaded at the cassette module from the factory, or a process carrier used to hold multiple material for batch processing. For the purposes of\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts (Part 16)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts\n\nContent: carrier mapping, these are equivalent, and the relationships are shown in the material model, Figure 6. A carrier has an ordered set of material slots, a specialization of material location, each of which can hold a single material. The material slot of a carrier is only of interest when the carrier is in the cluster tool, so it is viewed as a location of the module which contains the carrier. In addition to occupancy, a single material may be assigned to a material slot, indicating, for example, the particular slot to which a single material is to be moved when available. Information on material presence and assignment of the material identifier may be detected in the module or determined by the cluster controller or a supervisory controller. 7.1.5 Exception Model — In an auto mated control system where the operator interface is remote from the module controller, it is necessary to have interactive exception handling for error recovery. In addition to exception reporting, a module requires input from a\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts (Part 17)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts\n\nContent: decision authority to resolve recoverable abnormal situations. These include exception conditions which extend beyond the module domain and those for which the module has insufficient information, such as in hardware failure. The decision authority in a cluster tool is the cluster controller. It may interact with an operator to determine the appropriate recovery action to perform. Figure 10 shows the exception model. Module resources detect appropriate exception conditions, which may be set or cleared. An abnormal situation is indicated by the corresponding exception condition being in the set state. A significant change in exception condition information generates an exception report to notify the decision authority. Both detection of the abnormal situation and its resolution generate exception reports. Reporting of each exception condition may be enabled and disabled independently in order to mask nuisance exceptions. Error exception conditions may have associated recovery actions which can be performed by\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts (Part 18)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts\n\nContent: the module resource to attempt to recover from the abnormal situation. Alarm exception conditions cannot, by definition, be resolved using recovery actions. A list of possible recovery actions is included in a posted error report. The decision authority can request one of the offered recovery actions to resolve the error condition. The selected recovery action is performed by the appropriate module resource and may result in clearing the error condition. This model is used to establish the Exception Management definition. 7.1.6 Recipe Management Model — Recipe management in a module varies with the requirements of the application. Simple modules do not provide local recipe editing and don’t require management of multiple logical domains (namespaces) and local recipe version control. Figure 11 Recipe Management Information Model Process recipes specify the actual parameters of the processing to be achieved. The module processing resource identifies, through the process job, the required recipe(s) to be loaded by\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts (Part 19)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Concepts\n\nContent: the recipe executor in order to process a particular material. The recipe executor accesses and selects recipes for execution. It uploads and downloads recipes from the cluster controller and is capable of verifying that a recipe is syntactically correct. The recipe executor also provides for a service-user to select a recipe to be loaded into the recipe execution area. The recipe is made up of a recipe body and may have headers if the module supports recipe namespace management. The module accesses recipe namespaces where requested by service-users. A module which does not provide local editing and linking of recipes does not need recipe namespace management. Recipe namespace management requires management of recipe generic and agent (module) specific headers. For example, a process module could manage a recipe namespace containing its process and service recipes. This model is used to establish the Recipe Management services requirements for cluster tool modules.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model\n\nContent: Event reporting provides a dynamic and flexible means by which a service-user can receive notification of events and data relating to module resources. The services-user can define and enable two types of reporting, event reporting and trace reporting. Both may convey data, the values of identified variables at the data collection time. The variable identifiers required to be reported are specified in the data report definition. In event reporting, data reports are linked to event report definitions associated with each collection event type. On occurrence of the collection event, an event report message is generated according to the event report definition and the linked data report definitions. Reporting may be enabled and disabled for each collection event type. Data reports and links may be predefined or specified dynamically by the service user. Trace reporting is time-based data reporting. Trace reporting is specified by the service-user dynamically as required. Collection events may\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model\n\nContent: initiate and terminate the tracing in order to link reporting to significant conditions, such as processing. The trace data is collected at a frequency specified by the serviceuser. Trace reports are generated according to the trace report definition and the associated data report definition. Through associating the event report and trace report definition with the service-user, the model provides for the association of multiple service-users to a single service-provider. This allows for event reporting between modules where needed as well as the ability for direct connection of a data acquisition entity independent of the cluster controller. 7.2 Cluster Tool Module Message Flow — The appropriate objects in the information models in the previous section are grouped in the cluster tool module types. The communications with the essential objects are shown in the message flow diagrams in this section. The diagrams show message flow between entities within an agent (in this case a module) and those\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model (Part 3)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model\n\nContent: outside the agent. Entities are rectangular boxes, and the agent is a rounded box. As emphasis is on the module and its services, only one agent is shown on each diagram. Outside entities in the cluster tool module communications domain appear within an agent on another diagram. The messaging is shown by arrows in each direction, with a brief label indicating the services requested or provided. The communications are shown for the primary control of the process module (Figure 13), cassette module (Figure 14), and transport module (Figure 15). Note that the transport module transfer resource communicates with multiple process and cassette module intratool port resources. The communications for support functionality are shown for any module, as the services are common to all module types. The support functionality modeled includes exception handling (Figure 16), recipe management (Figure 17), and event reporting (Figure 18). A typical decision authority or service-user is the cluster controller.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model (Part 4)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model\n\nContent: 7.3 Cluster Tool Behavioral Mode l — The process material is the fundamentally important object in a cluster tool and its lifecycle is the key component to establishing cohesiveness in the communication and controls standards. The finite state model in Figure 19 presents the highlevel behavior of a single material within the domain of the cluster tool. Bold transitions trace the normal lifecycle of the material and are described in the transition table, Table 1. Other transitions occur in exception situations and are not detailed here. The transition table actions indicate the primary control operations which are requested of the modules by the cluster controller. When ready to be processed in the cluster tool, the material is presented and loaded at the input cassette module (intertool material transfer). It is usually contained with other single material in a cassette. The material process substate in the scope of this visit to the cluster tool is initially unprocessed. The material is then\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model (Part 5)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model\n\nContent: transferred to the first process module (intratool material transfer), ready for process. At this point, the material may be returned to the input cassette module and back to the factory, as the material has not been physically altered. The material then begins processing in the process module according to the recipe for that process step (process job), and the process sub-state changes to in-process. On successful completion of the process step, the material is then ready to be transferred to the next module (intratool material transfer). This may be another process module for the next process step or to the output cassette module if processing in the cluster tool is complete, in which case the process sub-state changes to processed. It is also possible that the next process step be performed in the same process module. Table 1 Cluster Material State Transition Table The material is finally unloaded from the output cassette module to the factory (intertool material transfer). If all process\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model (Part 6)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model\n\nContent: steps in the cluster tool were completed and were successful, the processing in the cluster tool is complete; otherwise, processing in the cluster tool was only partially accomplished. Detailed behavioral models are documented in the individual Cluster-Specific Services and in the standards which they reference. The Typical Operating Scenario in the application notes illustrates the behavioral characteristics of cluster tool control by showing the detailed messaging among modules and supervisory controller through the lifecycle of material as it enters the cluster, is processed, and then leaves the cluster. 7.4 Cluster Tool Control Topology — The natural decomposition of a cluster tool is into its modules. The module controller is the entity which performs internal control of a module and provides standard services. Module controllers provide certain application-specific functions (providers of services and user of services) and consist of hardware and software components that interact with the\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model (Part 7)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model\n\nContent: communications and control environment of the cluster tool. Traditional definitions of controllers have implied certain PHYSICAL, hardware control topologies (such as distributed or centralized processors). These cluster tool standards specify the communications in terms of services-providers, enabling the module controllers to be based on LOGICAL control topologies. The list of possible physical controllers which could be used to implement the logical services of the standards are listed below. It is emphasized, however, that the standard is not based on any constraint that each of these physical controllers be present in a cluster control system, but instead requires that the logical services (i.e., software functional components) be present somewhere in the cluster control system. Possible Controllers: Cassette Module Controller Process Module Controller Transport Module Controller Cluster Controller The logical control topology allows any combination of module controllers on a single\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model (Part 8)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7.1.7  Event Reporting Model\n\nContent: control unit. Standard communication is not required among them. A common example is the grouping of transport module and cassette module control into a single material handler control unit as shown in Figure 1. For interface compliance, all communication between a logical module controller and remote controller or service-user must be compliant with the standard services.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: The Cluster Tool control system elements, as represented in the object information, object communications, and behavioral models, require standard services in order to interface with one another. The objects which are fully standardized (attributes, behavior, and operations) are only those essential to this communication, and the services are the interactions with these standard objects. The services are grouped into the following functional areas: Object Services Processing Management Material Movement Management Exception Management Recipe Management Event Reporting Clock The services of each of these groups are described in detail in this section. The services are defined in terms of services provided by independent SEMI standards, specifying their application and limitations with respect to the fundamental requirements of cluster tool module communications. 8.1 Object Services — All standar dized service object attribute access across a cluster tool module communications interface is\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: achieved using object services. Access may be to read attribute values of objects, to get a list of objects corresponding to certain criteria, and to set the values of writable attributes of objects. The message services provided to accomplish this are Get and Set. The specific object types, relations, attributes, and access rules are defined in each specific services group. The object services are defined in SEMI E39 (Object Services Standard: Concepts, Behavior, and Services). Cluster tool module communications require only the fundamental requirements of that standard except where stated in a specific services group below. 8.2 Processing Management Services — Processing management across a cluster tool module communications interface is achieved using the processing management services. These services provide the communications and behavior required of the processing resource by the material processing models through defining the process job object and its operations. The processing\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 3)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: management services follow SEMI E40 (Standard for Processing Management). Cluster tool module communications require full compliance with the information, behavior, and messaging services of the fundamental requirements of that document. The process job creation is requested by the cluster controller using the PRJobCreate service. If the processing resource accepts the job, it performs the required processing to completion once the material arrives. The processing resource shall support the PRJobCommand Abort service, which ceases any processing and terminates the job. The processing resource reports process job milestones achieved to the cluster controller using the PRJobAlert service. Process job object attributes required to be accessible through object services follow: Processing management messaging services required: Processing resource capabilities required, but not already specified above: Detect and report success or failure of a process job. Reject incomplete, invalid, and\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 4)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: unsupported requests. Processing resource capabilities permitted, but not to be required, by a service-user: Pre-conditioning and post-conditioning. Stop, Pause, and Resume of a process job. Manual process start. Process job queuing and queued job Cancel. Process tuning. Processing of material groups. Multiple concurrent process jobs. Multiple consecutive process jobs. Process job with no material. Notification of waiting for material and of pro job state changes. 8.3 Material Movement Services — Each material movement in a cluster tool involves interaction among the cluster controller and all of the modules participating in the transfer. The communications interfaces and behavior resulting from the material movement models are defined for each association by the material movement services. The material movement services are partitioned into intratool material movement services, intertool material movement services, and carrier mapping, as in the models. The material movement services\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 5)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: follow the Material Movement Management Standard [SEMI E32] and Object Services Standard: Concepts, Behavior, and Services [SEMI E39]. Cluster tool module communications require full compliance with the information, behavior, and messaging services of the fundamental requirements of those standards. 8.3.1 Intratool Material Movement S ervices — From the intratool material movement models, an intratool material transfer — the transfer of material from one attached module to another through a transport module — requires the following interactions: 1. The cluster controller decides that material is to be moved as the result of either arrival of material or the completion of some processing step on the material. It determines which material is to be moved and the source and destination of that movement (cluster-application-specific). It requests all the modules involved to perform the appropriate TM or AM transfer job. 2. The source- and destination-attached modules inform the transport module\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 6)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: that they are prepared to do their specific activities during the material transfer. The transport module informs the sourceand destination-attached modules, each at the appropriate point in time, that it is synchronized for material handoff. 3. The detailed transactions required to handoff the material during the transfer are accomplished, first at the source and then at the destination. These interactions may require a number of communications interfaces for intratool material transfer from the following: Cluster controller to transport module transfer resource: TM transfer job source AM to destination AM Cluster controller to source-attached module intratool port resource: AM transfer job send Cluster controller to destination-attached module intratool port resource: AM transfer job receive Transport module to source-attached module intratool port to transfer resource: handoff get Transport module to destination-attached module intratool port to transfer resource: handoff put The\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 7)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: material movement services define the communications and behavior required of the attached module intratool port resource and the transport module transfer resource. They define the TM transfer job, TM atomic transfer, AM transfer job, and AM atomic transfer objects and their operations, as well as the handoff operations between the transfer resource and the intratool port resource. Each interface is described below. Cluster Controller to Transport Module Interface — The TM transfer job creation is requested by the cluster controller using the TRJobCreate service. If the transfer resource accepts the job, it performs the transfer of the material to completion, coordinating with the attached modules. The TM transfer job comprises two atomic transfers for the material, one to get (receive) it from the source-attached module and another to put (send) it to the destination-attached module. The transfer resource shall support the TRJobCommand Abort service, which ceases any transfer activity and\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 8)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: terminates the job. The transfer resource reports transfer job milestones achieved to the cluster controller using the TRJobAlert service. The transfer resource coordinates material handoff with each attached module through the transport module/attached module interface, described below. TM transfer job object attributes required to be accessible through object services: TM atomic transfer object attributes required to be accessible through object services: Material movement messaging services required: Transfer resource capabilities required, but not already specified above: Detect and report success or failure of a transfer job. Reject incomplete, invalid, and unsupported requests. Transfer resource capabilities permitted, but not to be required, by a service-user: Stop, Pause, and Resume of a transfer job. Manual atomic transfer start. Transfer job queuing and queued job Cancel. Transferring of material groups. Multiple concurrent transfer jobs. Notification of transfer events. Cluster\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 9)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: Controller to Attached Module Interface — The AM transfer job creation is requested by the cluster controller using the TRJobCreate service. If the intratool port resource accepts the job, it coordinates with and directs the transport module to achieve the material handoff. The AM transfer job comprises an atomic transfer for material which is to receive it from, or send it to, the transport module. The intratool port resource shall support the TRJobCommand Abort service, which ceases any transfer activity and terminates the job. The intratool port resource reports transfer job milestones achieved to the cluster controller using the TRJobAlert service. The intratool port resource coordinates material handoff with the transport module through the transport module to attached module interface, described below. AM transfer job object attributes required to be accessible through object services: AM atomic transfer object attributes required to be accessible through object services: Note that\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 10)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: TRLocation is not required to be supported as it is the responsibility of the attached module to determine the appropriate location to be used based on the material identifier. Material movement messaging services required: Transfer resource capabilities required, but not already specified above: Detect and report success or failure of a transfer job. Reject incomplete, invalid, and unsupported requests. Transfer resource capabilities permitted, but not to be required, by a service-user: Stop, Pause, and Resume of a transfer job. Manual atomic transfer start. Transfer job queuing and queued job Cancel. Transferring of material groups. Multiple concurrent transfer jobs. Notification of transfer events. Transport Module to Attached Module Interface — The control interface for the handoff of material between the end effector of a transport module and any attached module supports a sequence of three phases: 1. a synchronization phase that establishes that both the attached module intratool port\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 11)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: resource and the transport module transfer resource are ready to handoff the material. 2. a physical handoff phase controlled by the intratool port resource. 3. a verification phase to determine that actual handoff took place. This action completes the handoff. The transport module is responsible for managing constraints on the simultaneous opening of isolation valves as it relates to contamination of the transport module's environment by that of an attached module, as well as cross-contamination between modules. The attached module ensures that its environment will not contaminate the transport module before synchronizing. The rules for re-establishing isolation at verification are determined by the transport module. The synchronization between the transfer resource and the intratool port resource is achieved by each, indicating readiness to transfer the material, using the HOReady service. Once both partners have received the HOReady, the intratool port resource directs the physical\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 12)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: handoff. The intratool port resource commands the transfer resource using the defined HOCommand services. Once the physical handoff is complete, the intratool port resource requests verification using the HOVerify service. The transfer resource and intratool port resource shall support the HOCancelReady service which cancels a previously sent HOReady while still in the synchronization phase. The transfer resource shall support the HOHalt service, which ceases any transfer activity and terminates the handoff. Material movement messaging services required: HOCommands to be supported by the transfer resource: Where the robotic hardware does not provide for vertical motion, Pick and Place are not required to be supported. Transfer partner capabilities required, but not already specified above: Detect and report success or failure of handoff commands. Detect and report success or failure of the handoff, through the verification. Reject incomplete, invalid, and unsupported requests. Transfer\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 13)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: resource capabilities permitted, but not to be required, by either partner: Multiple concurrent handoffs. Additional handoff commands. 8.3.2 Intertool Material Movement S ervices Factory-to-cluster tool carrier or single material input/output management across a cluster tool module communications interface is achieved using the intertool material movement services. These services provide the communications and behavior required of the intertool port resource by the intertool material movement models through defining the CM input/output transfer job object and its operations. This standard specifies only the required communication between the cluster controller and the cassette module and does not assume automated material movement in the factory. The CM input/output transfer job is compliant with SEMI E32 (Material Movement Management) and may be extended to support automated material movement in the factory. The CM input/output transfer job creation is requested by the cluster controller\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 14)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: using the TRJobCreate service. If the intertool port resource accepts the job, it coordinates with the operator or some entity to achieve the material handoff. The CM input/output transfer job comprises an atomic transfer for a cassette or single material which is to receive it from, or send it to, the factory. The intertool port resource shall support the TRJobCommand Abort service, which ceases any transfer activity and terminates the job. The intertool port resource reports transfer job milestones achieved to the cluster controller using the TRJobAlert service. CM input/output transfer job object attributes required to be accessible through object services: Atomic transfer object attributes required to be accessible through object services: The requirements above indicate the settings if the transfer is to be manual, with the operator. The attributes TRLink, TRRole, TRPartner, and TRType are not significant in this situation. These become significant in automated material transfer.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 15)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: Material movement messaging services required: Detect and report success or failure of a transfer job. Reject incomplete, invalid, and unsupported requests. Intertool port resource capabilities permitted, but not to be required, by a service-user: Automated transfer of material within factory. Stop, Pause, and Resume of a transfer job. Manual atomic transfer start. Transfer job queuing and queued job Cancel. Transferring of material groups. Multiple concurrent transfer jobs. Notification of transfer events. 8.3.3 Carrier Mapping Services — Mapping of material in carriers across a cluster tool module communications interface is achieved using the carrier mapping services. These services provide the communications required of the appropriate module resources by the material models through defining the material slot object. The carrier-mapping services are fully specified in terms of the material slot attributes accessed through the get and set services of SEMI E39 (Object Services Standard:\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 16)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: Concepts, Behavior, and Services). Cluster tool module communications require full compliance with the information, behavior, and messaging services of the fundamental requirements of that standard. The mapping information is only of interest to the cluster tool for a carrier contained in the module resource. The material slot objects are, therefore, associated with, and managed by, the module resource which uniquely identifies all of its material slots. The carrier-mapping services provide for communication of material slot information in both directions between the cluster controller and the module resource. The information communicated is material presence and material identification. Whether the material presence is detected by the module resource or determined by the cluster controller is application-specific. This is also the case for material identification. A material slot may be assigned the identifier of material which is not yet occupying the material slot. This provides for\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 17)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: determination by the cluster controller of which material slot the material is to be moved into when it arrives at the module. Intertool port resource capabilities required, but not already specified above: Material slot object attributes required to be accessible through object services are detailed in Table 2. Table 2 Material Slot Attributes The material slot occupancy attribute indicates the presence of material as follows: SlotUnknown — the carrier is present and slot occupancy is not known, such as from when a carrier is loaded until the material is detected or the state is set by the cluster controller. • SlotEmpty — no material in the slot. • SlotOccupied — material is present in the slot. SlotActive — material is being removed from, or is arriving at, the slot. • SlotDisabled — material slot unusable, such as when the carrier is not present. Module resource capabilities required, but not already specified above: • Reject incomplete, invalid, and unsupported requests. Module\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices (Part 18)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8  Cluster Tool Module Serv ices\n\nContent: resource capabilities permitted, but not to be required, by the cluster controller: Detection of the presence of material in a material slot. Detection of the identifier of material in a material slot.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes\n\nContent: 8.4 Exception Management Servic es — Exception management across a cluster tool module communications interface is achieved using the exception management services. These services provide the communications and behavior required of the module resource by the exception models described in Section 7.1.5 through defining the exception condition object and its operations. The exception management services follow SEMI Draft Document 2013C (SECS II Support for SEMI E41 (Exception Management Standard)). Cluster tool module communications require full compliance with the information, behavior, and messaging services of the fundamental requirements of that standard. Exception conditions (alarms and error conditions) are created and managed by the module resource detecting the related abnormal situation. The module resource uses the EXPost service to report the occurrence of the abnormal situation or some significant change in exception condition information while the situation exists. EXCleared reports that\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes\n\nContent: the abnormal situation is no longer apparent or relevant. Reporting on an exception condition is enabled and disabled by setting its EXEnabled attribute. The cluster controller may direct recovery of error conditions using the EXRecover service. The module resource performs the recovery action and reports its completion using the EXRecoveryComplete service. The module resource is only required to permit a single recovery action at a time on all set exception conditions, but may support multiple recovery actions. The module resource shall support the EXRecoveryAbort service, which ceases any activity and terminates the recovery action. Exception condition object attributes required to be accessible through object services: Exception management messaging services required: Reporting of all exception conditions is set to be enabled on establishment of an association, and those in the set state are posted. 8.5 Recipe Management Services Recipe management across a cluster tool module communications\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes (Part 3)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes\n\nContent: interface is achieved using the recipe management services. These services provide the communications and behavior required of the module by the recipe models described in Section 7.1.6 of this document. The recipe management services follow SEMI E42 (Recipe Management Standard). Cluster tool module communications require full compliance with the information, behavior, and messaging services of the fundamental requirements of a recipe executor, and optionally the recipe namespace management, as defined in that standard. The module requiring recipe services contains a recipe executor that is capable of performing recipe download, verification, selection, deselection, and deletion as requested by the cluster controller. The module may also support recipe namespace services. In certain configurations, the module may require recipe management services to be provided by the cluster controller, in order that it may request a selected recipe that is not stored locally. The module is the service-user in\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes (Part 4)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes\n\nContent: this case, and the cluster controller should support the necessary recipe namespace services. The module coordinates the activities of the processing resource and the recipe executor to ensure the appropriate recipes are loaded into the execution area for material processing. Recipe executor object attributes required to be accessible through object services: Module resource capabilities required, but not already specified above: Reject incomplete, invalid, and unsupported requests. Module resource capabilities permitted, but not to be required, by a service-user: Multiple concurrent recovery actions. Dynamic update of exception condition message and valid recovery actions. Recipe management messaging services required: Modules that require more than one recipe class for an execution cycle shall support multi-part recipes. That is, the ability to select multiple recipes in a single process job request is not supported in processing management. Recipe executor capabilities required and not already\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes (Part 5)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes\n\nContent: specified above: Reject incomplete, invalid, and unsupported requests Recipe executor and module capabilities permitted by not to be required by a service-user: Support for variable parameters (attributes and select service), Support for multi-part recipes, Upload a recipe, Support recipe namespace services for local recipe management, Local editing. 8.6 Event Reporting Services — E vent reporting services are to be supported in accordance with the models described in Section 7.1.7. Both event-based reporting and tracing are required. Support for userdefined reports is not required. Event reporting for CTMC-compliant modules shall be based on services as described in SEMI E53. 8.6.1 The attributes defined in the fo llowing table shall be supported by CTMC compliant modules. 8.6.2 Support for the following mes sages from SEMI E53 shall be provided. 8.6.3 Support for dynamic and user defined reports is optional. However, implementations which support these advanced capabilities, shall comply with the\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes (Part 6)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes\n\nContent: specifications of SEMI E53 and SEMI E39. SEMI E39 service messages shall use the optional object specifier arguments, such as EvtSrcSpec. Object services can then be used to interrogate objects for their reportable attributes. 8.7 Clock Services — The clock services provide for synchronization of the clocks on the modules with that of the cluster controller. These services provide the communications required of the appropriate module resources through defining the clock object. The clock services are fully specified in terms of the clock attributes accessed through the get and set services of SEMI E39 (Object Services Standard: Concepts, Behavior, and Services). Cluster tool module communications require full compliance with the information, behavior, and messaging services of the fundamental requirements of that standard. The clock object is uniquely identified for the module. Table 3 describes the attributes of the clock object. The identifier of the clock used for communications services is\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes (Part 7)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes\n\nContent: defined. The clock attribute Time is kept current and used to determine the value of the timestamp used in service messages. The module returns the current Time when it receives a get. The clock time is synchronized by using the object set service on the Time attribute. On receipt of a set request, the module performs the operations necessary to set the clock to the value supplied, within its resolution, from which it shall continue immediately. The DateTime attribute of the Clock object as used in Clock Services has a resolution in the range of seconds to centiseconds. If it is possible to specify the DateTime accurate to centiseconds, then centiseconds should be specified. If it is not possible to resolve time to less than a second, then centiseconds shall be reported as $^ { 6 6 } 0 0$ .” This requirement is for the reporting of the DateTime attribute of the Clock object in Clock Services only; other services may require greater resolution, in which case the Clock Services DateTime attribute\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes (Part 8)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Table 3  lock Attributes\n\nContent: resolution shall also be greater. 8.8 Required Services — Within a standards-compliant Cluster Tool, a number of services must be supported, at least to the fundamental requirements level. Due to the specialization of the modules in a Cluster Tool as detailed in the concepts section above, each module type only needs to support a subset of the service groups as shown in the message flow diagrams. The services requirements for each module controller are described in this section. An example of use of services by a cluster controller is also given.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8.8.1  Transport Module Controller\n\nMaterial transfer functions for the end-to-end establishment of material movement within the cluster (supported through the Material Movement services). Material transfer is set up through a Transfer Job requested of the transport module by the service-user (e.g., cluster controller).\nMaterial Handoff between the process and cassette modules and the transport module (supported through the Material Movement services).\nException capabilities to post and manage exception conditions within the transport module (supported through the Exception Management services).\nReporting of module variable data linked to  events to the service-user (supported through the Event Reporting services).\nAccess to standard objects of the specific services above as required by the service-user (supported through the Object services).\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8.8.2  Cassette Module Controller\n\nMaterial I/O functions for the management of moving cassettes in and out of the cluster as well as for moving material between the cassette module and the transport module (supported through the Material Movement services). Material I/O is set up through a Transfer Job requested of the cassette module by the service-user (e.g., cluster controller).  \nMaterial Handoff between the cassette module and the transport module (supported through the Material Movement services).\nException capabilities to post and manage exception conditions within the transport module (supported through the Exception Management services).\nReporting of module variable data linked to events to the service-user (supported through the Event Reporting services).\nAccess to standard objects of the specific services above as required by the service-user (supported through the Object services).\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8.8.3  Process Module Controller (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8.8.3  Process Module Controller\n\nContent: Material processing functions (supported through the Processing Management services). Processing is specified through a Process job requested of the process module by the service-user (e.g., cluster controller). Recipe Management to verify and transfer recipes between the process module and the service-user (supported through the Processing Management services). Material I/O functions for the management of moving material in and out of the process module (supported through the Material Movement services). Material I/O is set up through a Transfer job requested of the process module by the serviceuser (e.g., cluster controller). Material Handoff between the process module and the transport module (supported through the Material Movement services). ? Exception capabilities to post and manage exception conditions within the transport module (supported through the Exception Management services). Reporting of module variable data linked to events to the service-user (supported through the Event\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8.8.3  Process Module Controller (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8.8.3  Process Module Controller\n\nContent: Reporting services). Access to standard objects of the specific services above as required by the service-user (supported through the Object services).\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8.8.4  Example Cluster Controller\n\nScheduling and primary module control. Schedules Transfer and Process jobs in order to achieve the mission of the cluster tool, the processing of material.  \nRecipe management for storage, archival, and editing of process module recipes (supported through the Recipe Management services). • Human interfaces for the attached process, transport, and cassette modules (supported through the Event Reporting and Object Service definitions). Exception resolution services for making recovery decisions on exception conditions within the cluster (supported through the Exception Management services).\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # APPENDIX 1 APPLICATION NOTES\n\nNOTE: This appendix was approved as a part of SEMI E38 by full letter ballot procedure.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-1  Factory Integration (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-1  Factory Integration\n\nContent: The Cluster Tool Module Communications (CTMC) Standard and its associated services define the interactions of the cluster modules and the cluster controller. The standard does not address the communications between the cluster and an external factory “host.” The SEMI standard which addresses the equipment to host communications interface is SEMI E30 (GEM). The purpose of this application note is to discuss the requirements and possible pitfalls of the factory hostcluster tool interface. The bulk of the text will address the use of the current (at this writing) version of GEM (SEMI E30). However, some consideration will be given to the possibility of direct access to the components of the cluster through the cluster communications environment. A1-1.1 Direct Access to Cluster Modules — The CTMC was designed to allow for interoperability among the entities in a cluster. It is possible to add a new entity to the cluster and share in this interoperability. This means that a software application that is\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-1  Factory Integration (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-1  Factory Integration\n\nContent: “plugged” into the cluster communication environment will have access to all of the cluster modules via the standard message set. In this way, a factory host computer can gain direct access to cluster modules, by-passing the cluster controller. While direct access to the cluster modules has some advantages, intrusions into the cluster tool communications environment can have a profound effect on the system. Below are listed a few of the positive benefits direct access can bring, followed by some of the negatives of such an approach.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Positives:\n\nIf the cluster controller does not have to act as the intermediary in transactions between module and host, it may be simplified.\nDirect access of the modules can be a more efficient means of obtaining information.\nThe factory host would have the flexibility to perform scenarios which the cluster controller suppliers had not imagined.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives: (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives:\n\nContent: A new, unplanned load on the cluster network may have a negative impact on system performance. If the delivered system’s network is highly loaded and has been tuned for that load, added pressure on the system may have unexpected results. Direct access of the cluster modules may have a negative impact on system performance. The cluster modules are performing the physical work for the cluster. If they become busy answering inquiries, it may detract from their speed of processing. For example, a simple query, such as temperature of chamber, may actually result in messaging to the sensor itself along the same realtime communication path used to open and close valves, ect. System integrity of the cluster tool may be at risk if an external entity (e.g., Factory Host) takes even minor control actions. A changed equipment constant may put the cluster controller out of synch with its module. An external command to perform an action may directly conflict with the cluster’s current actions. The CTMC defines no access\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives: (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives:\n\nContent: security to prevent undesirable actions on the part of external entities. If there is to be this sort of direct communication with cluster modules, the implementer should exercise extreme caution in the design of the add-on application. It is recommended that no active control be attempted and that no changes to the system configuration be attempted (e.g., do not set attributes). If data is to be accessed, it is best done by asynchronous event based reporting, rather than by polling. Above all, it is recommended that any plans to access the cluster through the cluster communication environment be discussed thoroughly with the system supplier. A1-1.2 GEM Control of a Cluster Tool — This section discusses the interactions between a cluster tool and factory host. The basis for that communication is assumed to be SEMI E30, the Generic Equipment Model. GEM was designed relative to the prevalent class of equipment at that time: proprietary, single supplier, and limited to a single process run at a time. The advent of\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives: (Part 3)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives:\n\nContent: multi-chamber processing equipment and later of multisupplier cluster tools has changed the general requirements set for the factory-equipment interface. In the future, GEM may evolve to meet these new requirements. Regardless, the point of this application note is to explore how best to apply the existing factory host communication standards to cluster-based equipment. Below, each GEM capability will be addressed separately, followed by a look at capabilities which GEM does not cover. The capabilities are taken in roughly the order given by SEMI E30 (GEM) table of contents. Communications State Model/Establish Communications — The Communications State Model is related to the ability to communicate. It is independent of the functionality offered by the equipment. There is no conflict with the cluster tool supporting this GEM capability. Control State Model — The control state model assumes a single operator interface at the equipment. A cluster tool is expected to supply such an interface connected to the\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives: (Part 4)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives:\n\nContent: cluster controller. However, there is a potential disconnect with attached modules which supply user interfaces. Since CTMC does not provide anything similar to the control state model at this time, the cluster controller has no control over access to these separate user interfaces, nor even any knowledge of what might be happening. In this situation, the cluster controller cannot guarantee compliance to the control state model. To assure GEM compliance, it is recommended that a module request and receive closure of all controlrelated service connections before allowing use of its local operator interface in a control mode. This assumes the use of the communication environment as defined in SEMI E38.1. Equipment Processing States — GEM specifies that there be a processing state model. The model given in the document is only an example, which shows the approximate depth needed and suggests a form. The example applies to the classic single chamber, singleprocess machine. Thus, it may not be directly applicable to\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives: (Part 5)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives:\n\nContent: a cluster tool. The cluster tool is required to provide a processing state model, but the form should match the cluster tool's function. The Plasma Etch Specific Equipment Model (document available from SEMI) suggested one way to model a multi-chamber, multi-process job machine. Data Collection — Data collection is a combination of several different capabilities. Each will be discussed in turn. There is also a high-level issue with data collection. GEM assumes a flat address space. That is, it assumes that the smallest granularity of object is “equipment.” The equipment has attributes. Some attributes are readonly (Status Variables). Some have read/write access (Equipment Constants). There are a few read-only attributes which are valid only at certain times (DVVALs). Cluster tools do not fit this model well. The CTMC was based on a model which includes a hierarchy of objects which contain (or control) other objects. The CTMC requirements are a subset of that model and include a cluster controller (which does not\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives: (Part 6)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives:\n\nContent: have to be a single entity), attached modules, transport module, and specific objects associated with the services. Thus, to request information about the processing of a wafer in a process module, the attributes of the process job must be accessed. The chain then includes Cluster Controller->Process Module- $. >$ Process Job->Job Attribute. It is quite a challenge to present this attribute as SVID #532678. And yet, this is what must be done. The cluster controller should provide a flat name space from which to access critical module data. Object services with scopeing capabilities may also be supported through the host interface, but if used, this would be an extension to the host's GEM interface. The data collection categories below give more detail on the challenge and possible solutions. Event Notification — Many of the events of interest to the host actually occur at the attached modules (e.g., “Etch step complete for wafer x”). The cluster controller is responsible for assigning each of these events a\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives: (Part 7)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives:\n\nContent: unique CEID. There are two challenges: (1) to assure uniqueness of events from duplicate modules, and (2) to provide a scheme whereby the host can determine the source of the event. Embedding a module number within the CEID is one solution which has been used to address both challenges. For instance, the highest order byte of a four-byte integer might contain the module ID. Dynamic Event Report Configuration — The host must be able to attach the information of interest to the event notifications. The cluster controller is responsible for providing access to the attributes of the cluster modules. It is also responsible for assuring that the data contained in the event reports is representative of the state of the cluster at the time the event occurred. There are three sources of data for the event reports. 1. Cluster Controller: Data which is local to the cluster controller may be accessed directly. 2. Module (not source of collection event): This data must be polled unless a data trace for the attributes of\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives: (Part 8)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives:\n\nContent: interest is in progress. 3. Module (source of collection event): This data tends to be most closely related to the event and thus the most time-critical. While polling and data trace may be used in this case, it is better to use the CTMC Event Reporting Services to attach the data of interest directly to the module collection event. Variable Data Collection/Status Data Collection — Again, the cluster must take measures to present a flat address space. See various discussions above. Limits Monitoring — Clearly, most variables which would be of interest for limits monitoring reside in the cluster modules. The CTMC does not provide specific services for configurable limits monitoring. A module may provide for some limits checking via “limits” attributes of objects which may be set via object services. Notification of excursions beyond limits would be via exceptions and/or collection events. If this method is not available, the cluster controller would have to institute a data trace on the attribute of interest and\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives: (Part 9)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives:\n\nContent: then itself perform the limits checking activity. The time period of the trace would be crucial to assuring that short-term excursions are not missed. Trace Data Collection — Trace data collection maps well from GEM to CTMC. In fact, the CTMC services in this area are a superset of the GEM functionality. On-Line Identification — At first glance, this seems to be an easy requirement to meet. However, the model number and software revision included in the message are ambiguous on a cluster with separate model numbers for each module (and the cluster controller itself) and separate software releases running on each. The purpose of these data items is to allow the host to determine when the equipment has been changed in such a way that it may no longer be compatible with the host software. At a minimum, the data items should indicate a change to the cluster controller software (e.g., a new revision of the software, or a significant reconfiguration such as the addition of a new module). Alarm Management — GEM alarm\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives: (Part 10)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives:\n\nContent: management is a subset of the functionality of the CTMC exception services. Any exception message from a module can, where desired, be translated into a GEM-compliant alarm message. The set of CTMC exceptions is a superset of GEM alarms. GEM alarms are of a serious nature and expect human intervention to be required. The CTMC extends this set to include problems which the controller may be able to solve, and provides for modules to suggest appropriate recovery actions. Those CTMC exceptions which fall into the GEM alarm category should be passed on via the GEM Alarm capability. Exceptions which are not GEM alarms should be reported only as events. Remote Control — Cluster tools need to be able to handle multiple tasks simultaneously. Most need to handle multiple lot or batch jobs at once. GEM's support for (process) job control is minimal. The implicit assumption in GEM is that only one job at a time will occur on a machine. It provides for a “START” command, collection events when the job is actually started\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives: (Part 11)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives:\n\nContent: and when it finishes, and also job control commands (e.g., PAUSE, RESUME, ABORT, STOP). What GEM lacks is differentiation of one job from another (e.g., a job ID). However, the GEM remote command message does provide for parameters. A cluster tool may be able to implement a scheme which is similar to that defined by the Process Management Services. For instance, a “job ID” parameter may be included in all job-related messages. Thus, the equipment would set a job ID in the “Start” or the “PP-Select” message (whichever first refers to the job), and would then refer to that ID in any subsequent job control commands. The job ID could also be available as a data value in collection event reports. While it might be preferable to have the equipment assign the job ID, this scheme may be workable. Equipment Constants — Again, the flat address space issue applies. (See the Data Collection section above.) Process Program Management — The CTMC uses Recipe Management Services (RMS) to manage recipes internal to the cluster.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives: (Part 12)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives:\n\nContent: GEM's processing services is a different mechanism. The two can be made to interact, but the combination is not ideal. It is possible for the cluster to translate a “recipe” to a “process program” for communication with the host. However, if a recipe is created or modified at the host and then downloaded, the editor at the host must be compatible with RMS concepts, and care must be taken to maintain the integrity of the RMS system. Material Movement — GEM requires only collection events when material is received or sent. A cluster can easily satisfy this requirement. Equipment Terminal Services, Error Messages, and Spooling — Equipment Terminal Services, Error Messages, and Spooling are in the domain of the cluster controller. Cluster modules do not provide these functions, nor do they contribute to the cluster controller's delivery of the services. Clock — A key purpose of clock is to allow the host to determine ordering of events from an equipment. The cluster controller should ensure that this need is met.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives: (Part 13)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Negatives:\n\nContent: The cluster should attempt to report consistent time relative to its modules. Also, when the factory host sets the time on the cluster, the cluster controller should resynchronize the time on its modules. There should be no compatibility problems in this area.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-2  Typical Operating Scenario (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-2  Typical Operating Scenario\n\nContent: The purpose of this section is to give an example of a typical operating scenario that will illustrate the various services being used to perform cluster tool control functionality. This operating scenario is NOT intended to be the only scenario to be implemented in a standards-compliant cluster. The intent is to provide guidance in navigating the various services standards. An exhaustive use of Object Services and Exception Management Services will not be done since these two areas tend to be very application-specific. This scenario concentrates on the material processing, material movement aspects of the cluster-specific services. The operating scenario shown in Figure 20 will be given in the form of a communication timing diagram with messages being sent between the various cluster tool components and will be indicated in the following manner: ServiceGroup_ServiceName.Request or Response (Service Parameters) Example: TRJobCreate.Req(...) TR is the service group that contains the service,\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-2  Typical Operating Scenario (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-2  Typical Operating Scenario\n\nContent: the material movement services. JobCreate is the service being used to cause communication to take place between two cluster tool components. Specifically, this service is the material movement service that initiates the transfer of material between modules. Req indicates that the service is a Request. (...) indicates any other parameters that might be present with the service definition and will be service-dependent.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # Definitions:\n\n$\\mathrm { C C } =$ Cluster Controller $\\mathbf { C M } =$ Cassette Module  \n$\\mathbf { T M } =$ Transport Module $\\mathbf { \\Delta } \\mathrm { P M 1 } =$ Processing Module #1 $\\mathbf { P M } 2 =$ Processing Module #2  \nThe general routing for the scenario is illustrated in the message sequence below:\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 1. FACTORY TO CM CASSETTE HANDOFF (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 1. FACTORY TO CM CASSETTE HANDOFF\n\nContent: The cassette containing a single wafer in wafer slot 1 to be processed by the cluster tool is passed from the factory environment to the cluster tool. At this point the user (human or host) will be prompted to place the cassette on the cassette module loading system. The cassette module is then informed to receive a cassette from the external environment. 19. The wafer is handed off between the transport module and the cassette module. 20. The cassette module is instructed to send the cassette to the factory. CC CM >> >> TRJobCreate.Req(MID $\\ c =$ \"Carrier1\",Port $\\ c =$ Port2 Dir $\\ c =$ Receive) CC CM << << TRJobCreate.Rsp(JobID $\\ c =$ IOJob1,Status $\\scriptstyle = \\supset \\mathbb { K }$ ) The cassette module prepares to receive the cassette by such actions as loadlock venting, door opening, and then requesting handoff from the Factory. CC CM << << TRJobStarted.Req(JobID $\\ c =$ IOJob1, TimeStamp) 1. A cassette of wafers arrives from the factory and is given to the cassette module. 2.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 1. FACTORY TO CM CASSETTE HANDOFF (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 1. FACTORY TO CM CASSETTE HANDOFF\n\nContent: A mapping of the wafers in the various slots of the cassette is determined for use inside the cluster. 3. A transfer job is initiated to move a wafer from the cassette to a process module (in this case PM1). 4. The cassette module is commanded to send the wafer to the transport module. 5. The PM1 is instructed to create the process job and to retrieve any pertinent recipe information in order to process the wafer. 6. The wafer is handed off between the cassette module and the transport module (Wafer GET operation). 7. The wafer is handed off between the transport module and PM1 (this is a Wafer PUT operation). 8. The wafer is processed in PM1. 9. A transfer job is initiated to the transport module to move a wafer from PM1 to PM2. 10. The PM1 is commanded to send the wafer to the transport module. 11. The PM2 is instructed to create the process job and to retrieve any pertinent recipe information in order to process the wafer. 12. The wafer is handed off between the PM1 and the transport\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 1. FACTORY TO CM CASSETTE HANDOFF (Part 3)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 1. FACTORY TO CM CASSETTE HANDOFF\n\nContent: module with a GET. 13. The wafer is handed off between the transport and PM2 with a PUT. 14. The wafer is processed in PM2 when manually started. 15. A transfer job is initiated to the transport module to move a wafer from PM2 back to the cassette module. 16. The PM2 is commanded to send the wafer to the transport module. 17. The cassette module is instructed to receive the wafer. 18. The wafer is handed off between PM2 and the transport module. The actual cassette transfer takes place, the cassette module takes such actions as door closing and loadlock pumping down to internal transfer pressures, and then reports completion of the material transfer. CC CM <<- << TRJobComplete.Req(JobID $\\ c =$ IOJob1,TimeStamp, Status $\\scriptstyle \\mathtt { \\Gamma } = \\mathtt { O K }$ ))\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 2. WAFER MAPPING\n\nThe wafers in each of the cassette wafer slots are assigned a unique wafer ID. In this case, the wafer is identified as “Wafer1.” If there were more than one wafer, this process would be repeated until all the wafers had been given their appropriate identification that is used later when specific wafers are requested for transfer and processing.  \nCC CM >> >> Set.Req(\"WAFERSLOT\",SlotID ${ \\bf \\varepsilon } = 1$ , $\\mathtt { M I D } =$ \"Wafer1\") CC CM << << Set.Rsp(\"WAFERSLOT\",SlotID ${ \\bf \\varepsilon } = 1$ ,Status $_ { \\mathsf { \\Omega } } = \\mathsf { O } \\mathsf { K }$ )\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 3. CC TO TM TRANSFER JOB SETUP\n\nThe CC informs the TM that a wafer transfer is required from the CM to PM1.  \nCC TM >> 专 TRJobCreate.Req(MID $\\ c =$ \"Wafer1\",TRSourceAmID $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ \"CM\",TRDestinationAmID $\\ c =$ \"PM1\")  \nThe transport module assigns an identifier for this particular transfer job. This is important in an actual cluster implementation since multiple transfer jobs may be queued and active at any given time. The transfer job is then started by the transport module.  \nCC TM < << TRJobCreate.Rsp(JobID $\\ c =$ TMJob1,Status $_ { \\cdot = \\mathsf { O K } }$ ) CC TM <<- << TRJobStarted.Req(JobID $\\ c =$ TMJob1,TimeStamp)\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 4. CC TO CM SEND WAFER\n\nThe CC informs the CM that a wafer is to be transferred to the TM.  \nCC CM >> >> TRJobCreate.Req(MID $\\ c =$ \"Wafer1\",PortID $\\ c =$ \"Port1\",Dir $\\ c =$ Send) CC CM << << TRJobCreate.Rsp(JobID $\\ c =$ IOJob2,Status $_ { \\mathsf { \\Omega } } = \\mathsf { O } \\mathsf { K }$ )  \nWhen the cassette module is ready, it directly communicates with the cluster controller and the transport module to indicate its readiness for wafer handoff.  \nCC CM <<- << TRJobStarted.Req(JobID $\\ c =$ IOJob2, TimeStamp) TM CM << << HOReady.Req(PortID $\\ c =$ \"Port1\",AmID $\\ c =$ \"CM\", HODir $\\ c =$ GET,MID $\\ c =$ \"Wafer1\")\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 5. CC TO PM1 PROCESSING JOB SETUP (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 5. CC TO PM1 PROCESSING JOB SETUP\n\nContent: The CC informs PM1 that a wafer will be delivered (which requires a TRJob to be created) and is to be processed (this requires that a process job be established). This involves creating the jobs and transferring the appropriate recipes to the process module as required. At some point in this process, the PM will inform the transport module that it is ready to receive the wafer with the issuing of the HOReady Request. The CC informs PM1 that a wafer is to be transfered from the TM. CC PM1 >> >> TRJobCreate.Req(MID $\\ c =$ \"Wafer1\",Port $\\ c =$ \"Port1\" Dir $\\ c =$ Receive) CC PM1 << << TRJobCreate.Rsp(JobID $\\ c =$ IOJob3,Status $- \\mathsf { O K }$ ) When the process module is ready, it directly communicates with the cluster controller to indicate its readiness for wafer handoff. CC PM1 << << TRJobStarted.Req(JobID $\\ c =$ IOJob3, TimeStamp) The process job is created on the process module. CC PM1 >> >> PRJobCreate.Req(RecID $\\ c =$ \"PP1\",MID $\\ c =$ \"Wafer1\") CC PM1 <<- <<\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 5. CC TO PM1 PROCESSING JOB SETUP (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 5. CC TO PM1 PROCESSING JOB SETUP\n\nContent: PRJobCreate.Rsp(JobID $\\ c =$ PM1Job1,Status $_ { \\cdot = \\mathsf { O K } }$ ) CC PM1 << << PRJobSetup.Req(JobID $\\ c =$ PM1Job1) The process module requests that all sections (headers and the body) of the recipe be downloaded. CC PM1 << << RCRequest.Req(RecID $\\ c =$ \"PP1\",RCTransfer $= \\mathtt { a l l }$ ) CC PM1 >>- >> RCRequest.Rsp(RecID $\\ c =$ \"PP1\",Status $_ { \\cdot = \\mathrm { O K } }$ ) CC PM1 >> >> RCSend.Req(RecID $\\ c =$ \"PP1\",<Headers & Body>) CC PM1 <<- << RCSend.Rsp(RecID $\\ c =$ \"PP1\",Status $\\scriptstyle = \\supset \\mathbb { K }$ ) The process module informs the transport module that it is ready to receive the material. TM PM1 <<- << HOReady.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM1\",HODi $\\scriptstyle \\mathtt { r } = \\mathtt { P }$ UT,MID $\\ c =$ \"Wafer1\")\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6. CM TO TM WAFER HANDOFF (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6. CM TO TM WAFER HANDOFF\n\nContent: The CM transfers the wafer to the TM through the handoff sequence, and the CM and TM will keep the cluster controller informed of its transfer progress. The transport module informs the cassette module that it is proceeding with the \"getting\" of the wafer. CM TM << << HOReady.Req(Port $\\ c =$ Port1,AmID $\\mid =$ \"CM\",HODi $\\scriptstyle { \\mathsf { r } } = { \\mathsf { G E } }$ T, MID $\\ c =$ \"Wafer1\") The cassette module informs the transport module to use the PICK sequence to get the wafer. CM TM >> >> HOPick.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"CM\") CM TM << << HOPick.Rsp(Port $\\ c =$ Port1,AmID $\\ c =$ \"CM\", Status $\\scriptstyle = \\supset \\mathbb { K }$ ) When the getting of the wafer has been successful, the cassette module informs the transport module with a verify sequence. CM TM >> >> HOVerify.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"CM\") CM TM << << HOVerify.Rsp(Port $\\ c =$ Port1,AmID $\\ c =$ \"CM\", Status $\\scriptstyle = \\supset \\mathbb { K }$ ) The cassette module then informs the cluster\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6. CM TO TM WAFER HANDOFF (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6. CM TO TM WAFER HANDOFF\n\nContent: controller of its current status. CC CM <<- << TRJobComplete.Req(JobID $\\ c =$ IOJob2,TimeStamp, Status $\\mathtt { \\Gamma } = \\mathtt { O K }$ )\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7. TM TO PM1 WAFER HANDOFF (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7. TM TO PM1 WAFER HANDOFF\n\nContent: The TM now has possession of the wafer and is ready to proceed with the putting of the wafer into the process module. The TM and PM1 will inform the cluster controller of the progress of the transfer of material. The TM informs the PM that it is proceeding with the putting of the wafer. PM1 TM << << HOReady.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM1\",HODir $\\scriptstyle \\cdot = \\mathrm { { P } }$ UT,MID $\\ c =$ \"Wafer1\") The process module informs the TM to use the PLACE scenario as the put operation. PM1 TM >> >> HOPlace.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM1\") PM1 TM << << HOPlace.Rsp(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM1\", Status $= \\mathsf { O K }$ ) When the putting of the wafer has been successful, the PM informs the transport module with a verify sequence. PM1 TM >> >> HOVerify.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM1\") PM1 TM << << HOVerify.Rsp(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM1\", Status $\\scriptstyle = \\supset \\mathbb { K }$ ) CC PM1 <<- << TRJobComplete.Req(JobID $\\ c =$ IOJob3,\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7. TM TO PM1 WAFER HANDOFF (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7. TM TO PM1 WAFER HANDOFF\n\nContent: TimeStamp) The TM then informs the cluster controller that the putting phase of the transfer is complete and then that the requested transfer job is complete. CC TM <<- << TRJobComplete.Req(JobID $\\ c =$ TMJob1, TimeStamp,Status $\\scriptstyle = \\supset \\mathbb { K }$ )\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8. PM1 JOB PROCESSING (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8. PM1 JOB PROCESSING\n\nContent: The process module informs the cluster controller, now that is has received the material and having previously entered the setup state, that it is ready to initiate processing on the wafer. When actual processing is initiated, the PM informs the cluster controller of its current status. CC PM1 <<- << PRJobProcessing.Req(JobID $\\ c =$ PM1Job1,TimeSta mp) A data collection is enabled to allow parameters to be sent from the PM to the cluster controller while the wafer processing is taking place. A previously defined event is enabled and the report structure is established. CC PM1>> >>Set.Req(EREvent,EventID $\\ c =$ Event1,Enabled $\\ c =$ TRUE)CC PM1<<Set.Rsp(EREvent,EventID $\\ c =$ Event1,Status $= \\mathsf { O K }$ ) Two variables for time and temperature will be reported based on Event1 occurring. CC PM1 << ERReport.Req(EventID $\\ c =$ Event1,ReportID $\\ c =$ Rpt1 ValueList $\\ c =$ {time,temp}) When wafer processing is complete on the PM, the cluster controller is informed of the current status. CC PM1\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8. PM1 JOB PROCESSING (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 8. PM1 JOB PROCESSING\n\nContent: <<- << PRJobProcessingComplete.Req(JobID $\\mid =$ PM1Job1 TimeStamp,Status $\\mathtt { \\Gamma } = \\mathtt { O K }$ ) Data collection is then disabled. CC PM1 >> Set.Req(EREvent,EventID $\\ c =$ Event1, Enabled $\\ c =$ FALSE) CC PM1 <<- << Set.Rsp(EREvent,EventID $\\ c =$ Event1,Status $_ { \\cdot = \\mathrm { O K } }$ )\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 9. PM1 to PM2 TRANSFER JOB SETUP\n\nThe CC informs the TM that a wafer transfer is required from the PM1 to PM2.  \nCC TM\n>>\nTRJobCreate.Req(MID $\\ c =$ \"Wafer1\"\nTRSourceAmID $\\ c =$ \"PM1\",\nTRDestinationAmID $\\ c =$ \"PM2\")  \nThe transport module assigns an identifier for this particular transfer job. The transfer job is then started by the transport module.  \nCC TM <<- << TRJobCreate.Rsp(JobID $\\ c =$ TMJob2,Status $\\ c =$ OK) CC TM <<- << TRJobStarted.Req(JobID $\\ c =$ TMJob2, TimeStamp)\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 11. CC TO PM2 PROCESSING JOB SETUP (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 11. CC TO PM2 PROCESSING JOB SETUP\n\nContent: The CC informs PM1 that a wafer is to be transferred to the TM. CC PM1 >> >> TRJobCreate.Req(MID $\\ c =$ \"Wafer1\",Port $\\ c =$ \"Port1\", Dir $\\mathbf { \\bar { \\rho } } = \\mathbf { \\rho }$ Send) CC PM1 <<- << TRJobCreate.Rsp(JobID $\\ c =$ IOJob4,Status $_ { \\mathsf { \\Omega } } = \\mathsf { O } \\mathsf { K }$ ) CC PM1 << << TRJobStarted.Rsp(JobID $\\ c =$ IOJob4, TimeStamp) When the process module is ready, it directly communicates with the transport module to indicate its readiness for wafer handoff. TM PM1 << << HOReady.Req(PortID $\\ c =$ \"Port1\",AmID $\\ c =$ \"CM\", HODir $\\ c =$ GET,MID $\\ c =$ \"Wafer1\") The CC informs PM2 that a wafer will be delivered (requires a TRJob) and is to be processed (requires that a process job be established). This involves creating the jobs and transferring the appropriate recipes to the process module as required. At some point in this process, the PM will inform the transport module that it is ready to receive the wafer with the isssuing of the HOReady\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 11. CC TO PM2 PROCESSING JOB SETUP (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 11. CC TO PM2 PROCESSING JOB SETUP\n\nContent: Request. CC PM2 >> >> TRJobCreate.Req(MID $\\ c =$ \"Wafer1\",Port $\\ c =$ \"Port1\" Dir $\\mathbf { \\bar { \\rho } } = \\mathbf { \\rho }$ Receive) CC PM2 <<- << TRJobCreate.Rsp(JobID $\\ c =$ IOJob5,Status $- \\mathsf { O K }$ ) CC PM2 <<- << TRJobStarted.Req(JobID $\\ c =$ IOJob5, TimeStamp) CC PM2 >> >> PRJobCreate.Req(RecID $\\ c =$ \"PP2\",MID $\\ c =$ \"Wafer1\", ManualStart) CC PM2 <<- << PRJobCreate.Rsp(JobID $\\ c =$ PM2Job1,Status $_ { \\cdot = \\mathsf { O K } }$ ) CC PM2 <<- << PRJobSetup.Req(JobID $\\ c =$ PM2Job1) The process module requests that all sections (headers and the body) of the recipe be downloaded. CC PM2 << << RCRequest.Req(RecID $\\ c =$ \"PP2\",RCTransfe $\\mathtt { \\Lambda } = \\mathtt { a l l }$ ) CC PM2 >> >> RCRequest.Rsp(RecID $\\ c =$ \"PP2\",LinkedID $= 0$ ,{Bod y: \"TEMP 250 TIME 40\"}) CC PM2 >> >> RCSend.Req(RecID $\\ c =$ \"PP1\",<Headers & Body>) CC PM2 <<- << RCSend.Rsp(RecID $\\ c =$ \"PP1\",Status $= \\mathsf { O K }$ ) The process module then informs the transport module to proceed\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 11. CC TO PM2 PROCESSING JOB SETUP (Part 3)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 11. CC TO PM2 PROCESSING JOB SETUP\n\nContent: with the putting of the wafer. TM PM2 <<- << HOReady.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM2\",HODi $\\scriptstyle \\mathtt { r } = \\mathtt { P }$ UT,MID $\\ c =$ \"Wafer1\") The cluster controller is informed that the processing job performed in PM1 is complete. CC PM1 << << PRJobComplete.Req(JobID $\\ c =$ PM1Job1, TimeStamp,Status $_ { \\mathsf { \\Omega } } { = } \\mathsf { O } \\mathsf { K }$ )\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 12. PM1 TO TM WAFER HANDOFF (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 12. PM1 TO TM WAFER HANDOFF\n\nContent: The PM1 transfers the wafer to the TM through the handoff sequence, and the TM will keep the cluster controller informed of its transfer progress. The transport module informs the process module that it is proceeding with the \"getting\" of the wafer. PM TM << << HOReady.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM1\",HODir $\\scriptstyle : = G$ ET,MID $\\ c =$ \"Wafer1\") The process module informs the transport module to use the PICK sequence to get the wafer. PM1 TM >> >> HOPick.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM1\") PM1 TM << << HOPick.Rsp (Port $\\ c =$ Port1,AmID $\\ O =$ \"PM1\", Status $\\scriptstyle = \\supset \\mathbb { K }$ ) When the getting of the wafer has been successful, the process module informs the transport module with a verify sequence. PM1 TM >> >> HOVerify.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM1\") PM1 TM << << HOVerify.Rsp(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM1\", Status $_ { \\cdot = \\mathrm { O K } }$ ) Process module #1 then informs the cluster controller of its current status. CC PM1\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 12. PM1 TO TM WAFER HANDOFF (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 12. PM1 TO TM WAFER HANDOFF\n\nContent: <<- << TRJobComplete.Req(JobID $\\ c =$ IOJob4,TimeStamp, Status $\\scriptstyle = \\supset \\mathbb { K }$ )\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 13. TM TO PM2 WAFER HANDOFF (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 13. TM TO PM2 WAFER HANDOFF\n\nContent: The TM informs the cluster controller that it is proceeding with the transfer of the wafer. The TM informs the PM that it is proceeding with the putting of the wafer. PM2 TM << << HOReady.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM2\",HODir $\\scriptstyle \\mathbf { \\alpha = p }$ UT,MID $\\ c =$ \"Wafer1\") The process module informs the TM to use the EXTEND scenario as the put operation. PM2 TM >> HOExtend.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM2\") PM2 TM << << HOExtend.Rsp(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM2\", Status $\\scriptstyle = \\supset \\mathbb { K }$ ) During this particular handoff, an exception is generated stating that the pins in the process module failed to come up and receive the wafer from the end effector. The cluster controller is given three recovery options to select from in attempting to resume operation in the presence of this exception. CC PM2 <<- << EXPost.Req(EXID $\\ c =$ Error1, EXType $\\ c =$ Error, EXMessage $\\ c =$ \"pins failed to raise\", EXRecoveryList $\\ c =$\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 13. TM TO PM2 WAFER HANDOFF (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 13. TM TO PM2 WAFER HANDOFF\n\nContent: {\"Abort\",\"Retry\",\"Continue\"}, TimeStamp) The cluster controller selects the “continue” option. CC PM2 >> >> EXRecover.Req(EXID $\\ c =$ Error1, EXRecoverySelected $\\ c =$ \"Continue\") CC PM2 <<- << EXRecover.Rsp(EXID $\\ c =$ Error1, Status $\\scriptstyle = \\supset \\mathbb { K }$ ) CC PM2 <<- << EXRecoveryComplete.Rsp(EXID $\\ c =$ Error1, Status $= \\mathsf { O K }$ ) This action is successful, and the alarm (exception type) clears. CC PM2 EXCleared.Rsp(EXID $\\ c =$ Error1,EXType $\\ c =$ Error, TimeStamp) When the putting of the wafer is now successful, the PM commands the transport module to Retract. PM2 TM >> >> HORetract.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM2\") PM2 TM << << HORetract.Rsp(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM2\", Status $\\scriptstyle = \\supset \\mathbb { K }$ ) Upon successful completion of the handoff, a verify sequence is used to complete the transaction. PM2 TM >> >> HOVerify.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM2\") PM2 TM << << HOVerify.Rsp(Port $\\ c =$ Port1,AmID $\\ c =$\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 13. TM TO PM2 WAFER HANDOFF (Part 3)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 13. TM TO PM2 WAFER HANDOFF\n\nContent: \"PM2\", Status $= \\mathsf { O K }$ ) CC PM2 << << TRJobComplete.Req(JobID $\\ c =$ IOJob5,TimeStamp, Status $\\scriptstyle = \\supset \\mathbb { K }$ ) The TM then informs the cluster controller that the putting of material is complete and that the requested transfer job is complete. CC TM <<- << TRJobComplete.Req(JobID $\\ c =$ TMJob2, TimeStamp,Status $= \\mathsf { O K }$ ) The process module informs the cluster controller that now that is has received the material, it is ready to initiate processing on the wafer upon Start command. CC PM2 << << PRJobWaitingStart.Req(JobID $\\ c =$ PM2Job1)\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 14. PM2 JOB PROCESSING (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 14. PM2 JOB PROCESSING\n\nContent: The cluster controller commands the PM to start processing the wafer. CC PM1 >> PRJobStart.Req(JobID $\\ c =$ PM2Job1) CC PM1 << << PRJobStart.Rsp(JobID $\\ c =$ PM2Job1,Status $- \\mathsf { O } \\mathsf { K }$ ) When actual processing is initiated, the PM informs the cluster controller of its current status. CC PM2 <<- << PRJobProcessing.Req(JobID $\\ c =$ PM2Job1, TimeStamp) A data collection is enabled to allow parameters to be sent from the PM to the cluster controller while the wafer processing is taking place. A previously defined event is enabled and the report structure is established. CC PM2 >>- >> Set.Req(EREvent,EventID $\\ c =$ Event1, Enabled $\\ c =$ TRUE) CC PM2 <<- << Set.Rsp(EREvent,EventID $\\ c =$ Event1,Status $\\scriptstyle = \\supset \\mathbb { K }$ ) Two variables for time and temperature will be reported based on Event1 occurring. CC PM2 << << ERReport.Req(EventID $\\ c =$ Event1,ReportID $\\mid =$ Rpt1 , ValueList $\\ c =$ {time,temp}) When wafer processing is complete on the PM, the\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 14. PM2 JOB PROCESSING (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 14. PM2 JOB PROCESSING\n\nContent: cluster controller is informed of the current status. CC PM2 << << PRJobProcessingComplete.Req(JobID $\\ c =$ PM2Job1 TimeStamp,Status $_ { \\cdot = \\mathrm { O K } }$ ) Data collection is then disabled. CC PM2 >> Set.Req(EREvent,EventID $\\ c =$ Event1, Enabled $\\ c =$ FALSE) CC PM2 << << Set.Rsp(EREvent,EventID $\\ c =$ Event1,Status $_ { \\cdot = \\mathrm { O K } }$ )\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 15. PM2 to CM TRANSFER JOB SETUP\n\nThe CC informs the TM that a wafer transfer is required from the PM2 to CM.  \nCC TM\n>>\nTRJobCreate.Req(MID $\\ c =$ \"Wafer1\",\nTRSourceAmID $\\ c =$ \"PM2\",\nTRDestinationAmID $\\mid =$ \"CM\")  \nThe transport module assigns an identifier for this particular transfer job. The transfer job is then started by the transport module.  \nCC TM <<- << TRJobCreate.Rsp(JobID $\\ c =$ TMJob3,Status $\\ c =$ OK) CC TM << << TRJobStarted.Req(JobID $\\ c =$ TMJob3, TimeStamp)\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 16. CC TO PM2 SEND WAFER\n\nThe CC informs the PM2 that a wafer is to be transferred to the TM.  \nCC PM2 >> >> TRJobCreate.Req(MID $\\ c =$ \"Wafer1\",Port $\\ c =$ \"Port1\", Dir $\\mathbf { \\bar { \\rho } } = \\mathbf { \\rho }$ Send)) CC PM2 << << TRJobCreate.Rsp(JobID $\\ c =$ IOJob6,Status $_ { \\cdot = \\mathsf { O K } }$ ) CC PM2 << << TRJobStarted.Req(JobID $\\ c =$ IOJob6, TimeStamp)  \nWhen the process module is ready, it directly communicates with the transport module to indicate its readiness for wafer handoff.  \nTM PM2 <<- << HOReady.Req(PortID $\\ c =$ \"Port1\",AmID $\\ c =$ \"PM2\", HODir $\\mathbf { \\bar { \\rho } } = \\mathbf { \\rho }$ GET,MID $\\ c =$ \"Wafer1\")\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 17. CC TO CM RECEIVE WAFER\n\nThe CC informs the CM that a wafer is to be transfered from the TM.  \nCC CM >>\nTRJobCreate.Req(MID $\\ c =$ \"Wafer1\",Port $\\ c =$\n\"Port1\", Dir $\\ c =$ Receive)\nCC PM2 <<- << TRJobCreate.Rsp(JobID $\\ c =$ IOJob7,Status $- \\mathsf { O } \\mathtt { K }$ ) CC PM2 << << TRJobStarted.Req(JobID $\\ c =$ IOJob7, TimeStamp)  \nWhen the cassette module is ready, it directly communicates with the transport module to indicate its readiness for wafer handoff.  \nTM CM <<- << HOReady.Req(PortID $\\ c =$ \"Port1\",AmID $\\ c =$ \"CM\", HODir $\\ c =$ PUT,MID $\\ c =$ \"Wafer1\")\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 18. PM2 TO TM WAFER HANDOFF (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 18. PM2 TO TM WAFER HANDOFF\n\nContent: The PM2 transfers the wafer to the TM through the handoff sequence, and the TM will keep the cluster controller informed of its transfer progress. The transport module informs the process module that it is proceeding with the “getting” of the wafer. PM2 TM << << HOReady.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM2\",HODir $\\scriptstyle = \\mathsf { G }$ ET,MID $\\ c =$ \"Wafer1\") The process module informs the TM to use the EXTEND scenario as the put operation. PM2 TM >> >> HOExtend.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM2\") PM2 TM << << HOExtend.Rsp(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM2\", Status $\\scriptstyle = \\supset \\mathbb { K }$ ) When the putting of the wafer is now successful, the PM commands the transport module to Retract. PM2 TM >> >> HORetract.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM2\") PM2 TM << << HORetract.Rsp(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM2\", Status $= \\mathsf { O K }$ ) Upon successful completion of the handoff, a verify sequence is used to complete the transaction. PM2 TM >> >>\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 18. PM2 TO TM WAFER HANDOFF (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 18. PM2 TO TM WAFER HANDOFF\n\nContent: HOVerify.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM2\") PM2 TM <<- << HOVerify.Rsp(Port $\\ c =$ Port1,AmID $\\ c =$ \"PM2\", Status $= \\mathsf { O K }$ ) CC PM2 <<- << TRJobComplete.Req(JobID $\\ c =$ IOJob6, TimeStamp) The cluster controller is informed that the processing job in PM2 is complete. CC PM2 << << PRJobComplete.Req(JobID $\\ c =$ PM2Job1, TimeStamp,Status $= \\mathsf { O K }$ )\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 19. TM TO CM WAFER HANDOFF (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 19. TM TO CM WAFER HANDOFF\n\nContent: The TM now has possession of the wafer and is ready to proceed with the putting of the wafer into the cassette module. First, the TM informs the cluster controller that it is proceeding with the transfer of the wafer to CM through the handoff sequence. CM TM <<- << HOReady.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"CM\", HODir $\\mathbf { \\bar { \\rho } } = \\mathbf { \\bar { \\rho } }$ PUT,MID $\\ c =$ \"Wafer1\") The cassette module informs the transport module to use the PLACE sequence to put the wafer. CM TM >> >> HOPlace.Req(Port $\\ c =$ Port1,AmID $\\ c =$ \"CM\") CM TM << << HOPlace.Rsp(Port $\\ c =$ Port1,AmID $\\ c =$ \"CM\", Status $\\mathtt { \\Gamma } = \\mathtt { O K }$ ) When the putting of the wafer has been successful, the cassette module informs the transport module with a verify sequence. CM TM>> >>HOVerify.Req(Port $\\ c =$ Port1,AmID $\\mid =$ \"CM\")CM TM<< <<HOVerify.Rsp(Port $\\ c =$ Port1,AmID $\\ c =$ \"CM\",Status $\\ c =$ OK) The cassette module then informs the cluster controller of its current status.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 19. TM TO CM WAFER HANDOFF (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 19. TM TO CM WAFER HANDOFF\n\nContent: CC CM << << TRJobComplete.Req(JobID $\\ c =$ IOJob7, TimeStamp,Status $_ { \\cdot = \\mathrm { O K } }$ ) The TM then informs the cluster controller that the putting of material is finished and that the requested transfer job is complete. CC TM <<- << TRJobComplete.Req(JobID $\\ c =$ TMJob3, TimeStamp,Status $= \\mathsf { O K }$ )\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 20. CM TO FACTORY CASSETTE HANDOFF (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 20. CM TO FACTORY CASSETTE HANDOFF\n\nContent: The cassette is passed from the cluster tool to the factory environment. CC CM >> >> TRJobCreate.Req(MID $\\ c =$ \"Carrier1\", Port $\\ c =$ Port2,Dir $\\mathbf { \\bar { \\rho } } = \\mathbf { \\rho }$ Send) CC CM <<- << TRJobCreate.Rsp(JobID $\\ c =$ IOJob8,Status $- \\mathsf { O K }$ ) CC CM <<- << TRJobStarted.Req(JobID $\\ c =$ IOJob8, TimeStamp) At this point, it is assumed that the cassette module performs actions such as loadlock venting, door opening, and initiating communication with the user (human or host) to perform the handoff to the factory. The cluster controller is informed of progress. When the transfer to the factory is complete, the cluster controller is informed. CC <<- << TRJobComplete.Req(JobID $\\ c =$ IOJob8, TimeStamp,Status $_ { \\tt = \\mathrm { { O K } } }$ ) NOTICE: These standards do not purport to address safety issues, if any, associated with their use. It is the responsibility of the user of these standards to establish appropriate safety and health practices and\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 20. CM TO FACTORY CASSETTE HANDOFF (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 20. CM TO FACTORY CASSETTE HANDOFF\n\nContent: determine the applicability of regulatory limitations prior to use. SEMI makes no warranties or representations as to the suitability of the standards set forth herein for any particular application. The determination of the suitability of the standard is solely the responsibility of the user. Users are cautioned to refer to manufacturer’s instructions, product labels, product data sheets, and other relevant literature respecting any materials mentioned herein. These standards are subject to change without notice. The user’s attention is called to the possibility that compliance with this standard may require use of copyrighted material or of an invention covered by patent rights. By publication of this standard, SEMI takes no position respecting the validity of any patent rights or copyrights asserted in connection with any item mentioned in this standard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and the risk of infringement\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 20. CM TO FACTORY CASSETTE HANDOFF (Part 3)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 20. CM TO FACTORY CASSETTE HANDOFF\n\nContent: of such rights, are entirely their own responsibility. Copyright by SEMI® (Semiconductor Equipment and Materials International), 3081 Zanker Road, San Jose, CA 95134. Reproduction of the contents in whole or in part is forbidden without express written consent of SEMI.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 1  Purpose\n\nThe purpose of this standard is to specify the communication environment for communication with and among modules in a cluster tool.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 2  Scope\n\nThe scope of this standard is communication within a cluster tool as defined in the standard Cluster Tool Module Communication Standard (CTMC, SEMI E38). This standard specifies the transmission of SECS-II messages by HSMS (SEMI E37), HSMS-GS (SEMI E37.2), and Ethernet. Other methods of message communication are possible but beyond the scope of this standard.  \nThis standard is intended to be one of possibly several supplements to the CTMC SEMI E38.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 3.1  SEMI Standards1\n\nThe following SEMI standards are related to the Communications Environment standard:  \nSEMI E5 SEMI Equipment Communication Standard 2 - Message Content (SECS -II).  \nSEMI E37 — High-Speed SECS Message Services (HSMS) Generic Services  \nSEMI E37.2 — High-Speed SECS Message Services General Session (HSMS-GS)  \n3.2  IEEE Standards2  \nThe following IEEE standard is related to the Communications Environment standard:  \nIEEE 802.3 — Carrier Sense Multiple Access with Collision Detection\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 4  Definitions (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 4  Definitions\n\nContent: The following definitions are arranged in alphabetical order. Some are defined using terms defined elsewhere within this section. No definitions beyond this section and the referenced standards should be necessary for a basic understanding of these terms. 10 BASE 2 — a common physical medium for the transmission of Ethernet signals. AUI (Attachment Unit Interface) — a specification of the connector, pins, and signals used to interface a computer to a MAU. Defined formally in IEEE 802.3. Cluster Tool Environment a collection of interconnected modules forming a cluster tool. Communications Stack — a specification of successive layers of interfaces through which communication services are provided. Ethernet — a method of transmitting signals. Ethernet is defined formally by IEEE 802.3 MAU (Medium Attachment Unit) — an adaptor from the AUI interface to a physical wire or medium such as 10 BASE 2. Defined formally in IEEE 802.3 Platform — a physical computer in a cluster tool that contains the Ethernet Interface\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 4  Definitions (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 4  Definitions\n\nContent: or station as defined in IEEE 802.3. In a cluster tool, a platform may have one or more logical modules residing on it.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 5  Required Sessions\n\nIn order to support the Services specified in the CTMC standard, there is an associated set of Protocol standards that specify a set of SECS-II messages to support these Services. This standard specifies the transmission of these SECS-II messages using HSMS sessions.  \nIn order to communicate with a given logical module, a separate HSMS connection (TCP/IP connection) is required per logical module.  \nFor correct operation of a cluster tool using these facilities, a set of standard sessions, given in Table 1, is required. Other sessions are possible, but are not required. In order to be compliant a module must not require further sessions in order to operate.  \nTable 1  Required Sessions\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification\n\nContent: There are many layers of software required in order to communicate using a facility such as HSMS. In order to interoperate, modules shall have identical or equivalent protocols at each layer on both sides of a physical connection. HSMS does not specify a particular physical layer. In order to ensure interoperability between modules, of possibly different origin, a complete interoperable communication stack is required. 6.1 SECS-II Messages — The Clu ster Tool Module Communications (CTMC) standard specifies a set of messaging services from applicable standards for use by a cluster tool module. Each service standard has a supplemental protocol standard which defines the SECS-II message support. This standard specifies a method for transporting these SECS-II messages. In order to be compliant with this standard, these SECS-II messages must be used. The detail of the SECS-II messages is found in SEMI E5. SECS-II message definitions refer to messages communicating between a host and\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification\n\nContent: equipment. With reference to implementing CTMC, the host is the service-user or clustercontrolling entity, and the equipment is the serviceprovider or cluster module entity. 6.2 HSMS Messaging — For the p urposes of communication of SECS-II messages within the cluster tool communication environment, SEMI High-Speed SECS Message Service (HSMS) shall be used (SEMI E37). CTMC defines a number of services. For inter-module, and service user-to-module communication, many services will be required simultaneously. As a result, the capabilities of the HSMS General Session (SEMI E37.2) are required and shall be used for communication of all services specified by the CTMC. 6.2.1 IP Addresses, Port Numbers, a nd Session IDs — HSMS defines the setting of IP Addresses, Port Numbers, and Session IDs. In order to uniquely specify a service, all three are required as configuration parameters. The actual numbers shall be within the allowed range and unique within their respective domains. Table 2 shows\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification (Part 3)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification\n\nContent: these parameters, what they define, and their respective domains. Table 2 Configuration Parameters 6.2.2 Session ID’s — Each associati on required by CTMC (such as Processing, Material Movement, Exception, etc.) shall have a session within a connection. These Session ID’s shall be documented by the service provider, and, if configurable, the method of configuration shall be documented. The Session ID for a given service shall be defined and may be dictated by the service provider (at the server end of a connection). In order to use a service, the service user (which is the client end of the connection) shall select the service by Session ID. Thus, the Session ID shall be configurable for the service user and the method of configuring shall be documented for each service user. Session IDs shall be as shown in Table 3. Object services shall use Session ID 1; all other services shall use Session ID’s from the range labeled “Available” in Table 3. Table 3 Allowed Session ID’s 6.2.3\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification (Part 4)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification\n\nContent: Linktest — The linktest proced ure is an optional facility of HSMS. For the purposes of cluster tool communications, the linktest procedure as described in the HSMS standard shall be supported. On detection of a linktest timeout, a communication failure will be considered to have occurred, and higher communication layers shall be notified of this failure. 6.2.4 Connection Mode — HSMS provides for Active, Passive, and Alternating Connection Modes. For the purposes of establishing connections in a cluster tool, either Active or Passive shall be used. For each service provided, there is a service provider (server) and a service user (client). With respect to each service, the client shall connect in the Active mode and the server in the Passive mode. Table 1 specifies the client and server (and hence connection mode) of the required sessions. In addition to establishing the connection, the client shall initiate the sessions with the Select message, as defined in HSMS. As a result, all\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification (Part 5)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification\n\nContent: sessions at the client end of a connection shall be service users and all sessions at the server end of the connection shall be service providers. 6.3 Use of TCP/IP — HSMS defin es the use of TCP/IP for communication of messages. Other simultaneous uses of TCP/IP are possible but beyond the scope of this standard. Within TCP, Port Numbers are used to uniquely identify the connection on a given platform. A port number may be any value between 0 and 65535, but TCP reserves port numbers starting at 0. Refer to HSMS and the references given in HSMS for the definition of the reserved port numbers. Multiple logical modules may exist on a given platform. Each service for a logical module on a given platform must use a unique session within a connection. It is possible to configure a module so that each logical module uses a separate connection, but it is also possible for several logical modules to share a connection. Each service requires a unique connection for each external entity, but an\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification (Part 6)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification\n\nContent: external entity may, depending on the configuration, access the services of several logical modules on a platform, identifying them by unique session, except for Object Services. Object Services is always identified by Session ID 1. Connection to a specific module shall be established using a non-reserved port number which is unique among modules on that platform. A given service may have several simultaneous connections. 6.3.1 Setting Port Number — The port numbers used for establishing HSMS connections shall be configurable for both the service user and service provider. This is because the port numbers may be used by some other software entity on the same platform. Port numbers shall be chosen that are not in the reserved range and do not conflict with any other software entity on the platform. The method of configuration of the port numbers shall be documented. 6.4 Physical Layer — HSMS allows for many different physical layers. In order for modules to interoperate, a single\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification (Part 7)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification\n\nContent: physical layer is required. This standard specifies Ethernet — as defined in the standard IEEE 802.3 — to be used for physical layer transmission of HSMS messages. Other physical layers could be used, but the use of other such physical layers is not supported by this standard. It is anticipated that other related standards will be developed to support other physical layers. In such a case, only those modules compliant with the same standard would be interoperable. 6.5 Media and Connectors — Wit h Ethernet, there is a choice of media used (twisted pair, coax, etc.). It is beyond the scope of this standard to specify the media used. The media is thus left to the configuration of a specific cluster tool and may depend on the available media used in the factory. Most Ethernet interfaces provide a media-independent AUI interface. A transceiver is then used to access the physical media. In order to be compliant with this standard, a module shall provide an AUI interface. Many interfaces also\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification (Part 8)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 6  Communication Stack Sp ecification\n\nContent: provide a media-specific interface. This media specific interface may be used in the event that the cluster tool media is the same as the media specific interface.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # 7  Compliance\n\nCompliance with this standard includes adherence to all stated requirements where implemented. In order to be compliant to this standard, an implementation shall:  \n1. use SECS-II messages as specified by CTMC document,\n2. use SEMI E37 (HSMS) and SEMI E37.2 (HSMSGS),\n3. allow and document IP Address configuration,\n4. allow and document Session ID configuration,\n5. allow and document Port ID configuration,\n6. use Ethernet as defined in IEEE 802.3,\n7. provide an AUI connector.  \nSome Ethernet interfaces provide additional connectors (such as 10 BASE 2 or thinnet). These may be used in cases where this is the medium chosen, but for compliance, an AUI connector shall be provided.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # APPENDIX 1 APPLICATION NOTES\n\nNOTE: This appendix was approved as a part of SEMI E38.1 by full letter ballot procedure.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-1  Example Configuration (Part 1)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-1  Example Configuration\n\nContent: The following example shows configuration of a cluster tool consisting of an existing process module with a new cluster controller and other modules. The cluster consists of a Cluster Controller, two Process Modules (PM1, PM2), and a combined Transport/Cassette Module (TM/CM). A1-1.1 IP Addresses — IP addresses are chosen so that they are unique to each platform on the network and consistent with the conventions used at the facility. For this example, the convention is to use 192.25.63.X for IP Addresses, where X is between 0 and 255. PM1 had an existing IP address of 192.25.63.122, which will not be changed. IP addresses starting at 205 are unused and thus available. Thus, the following $\\mathrm { I P }$ addresses are chosen: As part of the configuration, the IP Address of each module is identified as shown above, on all of the platforms. This configuration depends on the TCP/IP software used on the respective platforms. A1-1.2 Port Numbers — TCP reserves port numbers below 1024 in RFC1340.\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-1  Example Configuration (Part 2)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-1  Example Configuration\n\nContent: There are no other TCP/IP programs on any of the platforms in the cluster using port number in the range 2000-10000, so the following port numbers are chosen: 2000 first TM 5000 first CM 8000 first PM 8001 second PM The cluster controller is always a client and initiates the connections, so no port number assignment is required. A1-1.3 Session ID Assignment — Before defining the Session ID’s, recall that the following connections are required: The Session ID’s are arbitrary. PM1 already has ID’s which are as follows: PM1 IDs Clients Object Services 1 CC, TM Processing Management 100 CC Recipe Management 101 CC Material Movement 102 CC, TM Exception Management 103 CC Event Reporting 104 CC The other modules have not yet been set, so we choose to begin with ID 64. The session IDs are established as follows: PM2 Ids Clients Object Services 1 CC, TM Processing Management 64 CC Recipe Management 65 CC Material Movement 66 CC, TM Exception Management 67 CC Event Reporting 68 CC TM IDs Clients Object\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-1  Example Configuration (Part 3)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-1  Example Configuration\n\nContent: Services 1 CC Material Movement 64 CC Exception Management 65 CC Event Reporting 66 CC CM IDs Clients Object Services 1 CC, TM Material Movement 64 CC, TM Exception Management 65 CC Event Reporting 66 CC NOTICE: These standards do not purport to address safety issues, if any, associated with their use. It is the responsibility of the user of these standards to establish appropriate safety and health practices and determine the applicability of regulatory limitations prior to use. SEMI makes no warranties or representations as to the suitability of the standards set forth herein for any particular application. The determination of the suitability of the standard is solely the responsibility of the user. Users are cautioned to refer to manufacturer’s instructions, product labels, product data sheets, and other relevant literature respecting any materials mentioned herein. These standards are subject to change without notice. The user’s attention is called to the possibility that compliance with\n\nSEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-1  Example Configuration (Part 4)\n\nTitle: SEMI E37.2-95 (Reapproved 0303) HIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION (HSMS-GS) - # A1-1  Example Configuration\n\nContent: this standard may require use of copyrighted material or of an invention covered by patent rights. By publication of this standard, SEMI takes no position respecting the validity of any patent rights or copyrights asserted in connection with any item mentioned in this standard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and the risk of infringement of such rights, are entirely their own responsibility.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES\n\nThis standard was technically approved by the Global Information & Control Committee and is the direct responsibility of the North American Information & Control Committee. Current edition approved by the North American Information & Control Committee on March 12, 2003.  Initially available at www.semi.org May 2003; to be published July 2003. Originally published in 1995; previously published November 2002.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # CONTENTS\n\n1  Purpose\n2  Scope\n3  Referenced Standards\n4  Terminology 4.1 Definitions 4.2.1 Requirements 4.2.2 Objects 4.2.3 Services 4.2.4 Data Type\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 5  Conventions\n\n5.1 OMT Object Information Model\n5.2 Object Attribute Representation\n5.3 Service Message Representation\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8.2 Object Attributes\n\n8.2.3 Use of Text\n8.2.4 Object Type\n8.2.5 Object Identifier\n8.2.6 Object Handle  \n8.3 Object Definition\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships\n\n9.2 Object Hierarchy\n9.3 Scope and Ownership\n9.4 Multiple Inheritance Hierarchy\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations\n\n10.2 Create and Delete\n10.2.1 Create\n10.2.2 Delete\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10.3 Attachment\n\n10.3.3 Attach\n10.3.4 Attach Set Attributes\n10.3.5 Detach\n10.3.6 Reattach\n10.3.7 Attach Supervised Object\n10.3.8 Detach Supervised Object\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11  Services and Scenarios\n\n11.2 Scope\n11.3 Filtering\n11.4 Object Services Parameter Dictionary\n11.5 Get and Set Attributes\n11.6 GetType\n11.7 GetAttrName\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 12  Additional Services\n\n12.2 Object Services Parameter Dictionary\n12.3 Create\n12.4 Delete\n12.5 Attach\n12.6 AttachSetAttr\n12.7 Detach\n12.8 Reattach\n12.9 AttachSupervisedObject\n12.10 DetachSupervisedObject\n12.11 ObjectAction\n12.12 ObjectActionCompletion Notification\n12.13 Get Service Names\n12.14 Get Service Parameters\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 13  Applications\n\n13.2 Get All of an Object' s Attributes  \n13.3 Determine All Objects of a Specific Type and\nwith Specific Characteristics\n13.4 Determine Specific Attributes of a Specific\nObject Instance\n13.5 Determine Types of Subordinate Objects\n13.6 Determine Names of Attributes of Sub\nordinate Objects\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 14  Requirements for Compliance\n\n14.2 Fundamental Requirements\n14.3 Additional Capabilities 14.3.1 Filters 14.3.2 Owner Objects 14.3.3 Multiple Inheritance Hierarchy\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # APPENDIX 1\n\nA1-1  Overview of Object Terminology A1-2  Object Modeling Technique (OMT) Notation  \nA1-2.1  Basic Notation A1-2.2  Associations A1-3  Generalization and Inheritance A1-3.1  Object Composition and Containment\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # LIST OF TABLES\n\nTable 1  Top Object Attribute Definition\nTable 2  Object Services\nTable 3  Object Services Parameter Dictionary\nTable 4  GetAttr Service\nTable 5  SetAttr Service\nTable 6  GetType Service\nTable 7  GetAttrName Service\nTable 8  Additional Object Services\nTable 9  Additional Object Services Parameter\nDictionary\nTable 10  Create Service\nTable 11  Delete Service\nTable 12  Attach Service\nTable 13  AttachSetAttr Service\nTable 14  Detach Service\nTable 15  Reattach Service\nTable 16  AttachSupervisedObject Service\nTable 17  DetachSupervisedObject Service\nTable 18  ObjectAction Service\nTable 19  ObjectActionCompletion Notification\nTable 20  GetServiceNames Service\nTable 21  GetServiceParameters\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES\n\nThis standard was technically approved by the Global Information & Control Committee and is the direct responsibility of the North American Information & Control Committee. Current edition approved by the North American Information and Control Committee on March 12, 2003.  Initially available at www.semi.org May 2003; to be published July 2003. Originally published in 1995; previously published November 2002.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 1  Purpose\n\n1.1  The purpose of the Object Services Standard (OSS) is to provide general terminology, conventions, and notation for describing behavior and data in terms of objects and object attributes. In addition, it provides basic services for reading object attributes, setting their values, and for asking for an object' s contents. This standard is intended to be referenced by other standards which define specific objects to reduce redundancy.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 2  Scope\n\n2.1  The scope of this standard is to provide concepts, behavior, and services common to a variety of public objects.  \n2.2  Object models are common to multiple standards. Object Services provide basic object-related definitions, and basic services for getting object attributes and setting attribute values, that can be used by all standards defining public objects. These services allow basic management of data based on objects.  \n2.3  The object services defined in this document may be included in the services provided by other standards. They may also be provided independently of such other standards.  \nNOTICE: This standard does not purport to address safety issues, if any, associated with its use.  It is the responsibility of the users of this standard to establish appropriate safety and health practices and determine the applicability of regulatory or other limitations prior to use.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 3.1  ISO Standard1\n\nISO 9595 — Common Management Information Service (CMIS)\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 3.2  Other Standards\n\nJames Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, William Lorensen, Object-Oriented Modeling and Design, Englewood Cliffs, New Jersey: Prentice-Hall, 1991.  \nNOTICE: Unless otherwise indicated, all documents cited shall be the latest published versions.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4  Terminology\n\n4.1  The following basic definitions are provided in a logical order.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.1  Requirements\n\n4.2.1.1  fundamental compliance — conformance to all fundamental requirements for an object or service resource.  \n4.2.1.2  fundamental requirements — the requirements for information and behavior that must be satisfied for compliance with a standard. Fundamental requirements apply to specific areas of application, objects, or services.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.2  Objects (Part 1)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.2  Objects\n\nContent: 4.2.2.1 object2 — an entity with a specific set of data and behaviors. Objects may be physical or conceptual. 4.2.2.2 standardized object — a object formally defined in SEMI standards and in compliance with the fundamental requirements of SEMI E39 (Object Services Standard: Concepts, Behavior, and Services). 4.2.2.3 object model — a static graphic model of objects to show structure — the identity of objects, their attributes and operations, and their relationships with one another. 4.2.2.4 object type — a formal classification of a group of similar objects. Synonym: object class. Examples: equipment, wafer, carrier. 4.2.2.5 object instance — an instance of an object type. An object type is like a template, while an object instance is the actual object. Example: an actual and specific optical stepper installed in a particular fab is an instance of the type “Optical Stepper.” 4.2.2.6 object attribute (attribute) — information concerning an object. Examples for object type “equipment”: manufacturer, model, serial number.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.2  Objects (Part 2)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.2  Objects\n\nContent: 4.2.2.6.1 Attributes are classified in various ways, according to their visibility (public/private), optionality, and access: • fundamental attribute — an attribute that is required for fundamental compliance with a standard service. optional attribute — an attribute that is required only in support of one or more optional standard services. private attribute — an attribute that is used strictly for internal purposes and is unknown (invisible) through public services. public attribute — an attribute that is known (visible) and whose current value is provided as a service to other entities upon request. read-only attribute (RO) — may not be changed through public services. read/write attribute (RW) — may be changed through public services. 4.2.2.7 attribute name — the formal name of the attribute that is used to identify it. The names (and data types) of public attributes are included with the object’s definition and are unique for that object. 4.2.2.8 object identifier — a set of one or more items of information, concerning a\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.2  Objects (Part 3)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.2  Objects\n\nContent: particular instance (instantiation) of an object of a given type, that together uniquely distinguish that instance from all other instances of that object within a defined scope. NOTE: An object may have more than one identifier. An identifier may be simple (consist of only one attribute) or complex (consist of more than one attribute). Example: The combination of equipment' manufacturer, model, and serial number serve as an identifier that uniquely identifies a specific installation. 4.2.2.9 object handle — a numeric or binary identifier assigned by an application for internal use. NOTE: A handle may also be available as a public attribute but cannot generally be guaranteed to be either persistent or unique outside of the current relationship between service user and service provider. The persistence of the handle is specified by the standard that defines the object. 4.2.2.10 operation — a function performed by, or inherent to, an object. Example: for equipment, “run,” “stop,” “abort.” 4.2.2.11 aggregation object — an object\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.2  Objects (Part 4)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.2  Objects\n\nContent: that is composed (made up) of other objects. An aggregation may lose some degree of integrity if one of its components is missing. 4.2.2.12 component object — an object that is part of an aggregation. 4.2.2.13 container object — an object that is intended to hold other types of objects. The contents may or may not be ordered. 4.2.2.14 contents — an object that is in a container. Examples: a wafer in a cassette, a book in a library. 4.2.2.15 owner object — an object that is an aggregation, container, or supervisor of another object. The owner object is said to own the other object. 4.2.2.16 owned object — an object that is a component of, contained in, or supervised by, another object. The owned object is said to be owned by the other object. 4.2.2.16.1 An object may have multiple owners. For example, it may be a shared resource.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.3  Services (Part 1)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.3  Services\n\nContent: 4.2.3.1 scope — the specification of one or more objects that starts with a specific owner object and proceeds downward through a hierarchical sequence of “owns” relationships. 4.2.3.2 service (or message service) — represents a function offered to a user by a provider. A service consists of a sequence of service primitives, each described by a list of parameters. A service excludes definition of message structure and protocol. 4.2.3.2.1 A service may or may not be processed by the provider of the service. The invocation of some service may have to interact with other objects to fulfil its requirement completely; an exception will be raised if the service can not fulfill all its pre or post conditions. The object that provides the service may reject the service request or restrict the completion of the service to prevent an illegal action due to the equipment condition. 4.2.3.3 notification service — initiated by the service provider and sent to the service consumer/subscriber. No response is expected.3 4.2.3.3.1\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.3  Services (Part 2)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.3  Services\n\nContent: Notifications consist of two service primitives a message from the sender to the communications facility and an indication to the receiver from the communications facility. 4.2.3.4 request service — initiated by the service consumer. Requests ask for data or for an activity (operation) from the provider. Requests expect a specific response message. 4.2.3.4.1 A request consists of a message that requires a response from the receiver. The primitives for a request are the same as those of the notification, while the response defines additional primitives called the response and the confirmation. 4.2.3.5 service resource — a logical group of one or more services within a specific area of functionality.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.4  Data Type (Part 1)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.4  Data Type\n\nContent: 4.2.4.1 form — type of data: positive integer, unsigned integer, integer, enumerated, boolean, text, formatted text, structure, list, ordered list. 4.2.4.2 positive integer — may take the value of any positive whole number. Messaging protocol may impose a limit on the range of possible values. 4.2.4.3 unsigned integer — may take the value of any positive integer or zero. Messaging protocol may impose a limit on the range of possible values. 4.2.4.4 integer — may take on the value of any negative or unsigned integer. Messaging protocol may impose a limit on the range of possible values. 4.2.4.5 floating point — may take on any single (real) numeric value, positive or negative. Messaging protocol may impose a limit on the range of possible values. 4.2.4.6 enumerated — may take on one of a limited set of possible values. These values may be given logical names, but they may be represented by any single-item data type. 4.2.4.7 boolean — may take on one of two possible values, equating to TRUE or FALSE. 4.2.4.8 text — A text\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.4  Data Type (Part 2)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 4.2.4  Data Type\n\nContent: string. Messaging protocol may impose restrictions, such as length or ASCII representation. 4.2.4.9 formatted text — a text string with an imposed format. This could be by position, by use of special characters, or both. 4.2.4.10 structure — a complex structure consisting of a specific set of items, of possibly mixed data types, in a specified arrangement. 4.2.4.11 list — a set of one or more items that are all of the same form (one of the above forms). 4.2.4.12 ordered list — a list for which the order in which items appear is significant.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 5  Conventions (Part 1)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 5  Conventions\n\nContent: Defined terms are presented in boldface when introduced for the first time. Formally reserved text strings, such as attribute names, are underlined. 5.1 OMT Object Information Model — The object models are presented using the Object Modeling Technique (OMT) developed by Rumbaugh, James, et al, in Object-Oriented Modeling and Design, Prentice Hall, Englewood Cliffs, NJ, c1991. 5.1.1 Overviews of this notation are provided in the Appendix. A brief discussion of terminology is also provided in the Appendix. 5.2 Object Attribute Representation — The object information models for standardized objects will be supported by an attribute definition table with the following column headings: 5.2.1 The Access column uses RO (Read Only) or RW (Read and Write) to indicate the access that users of the service have to the attribute. 5.2.2 A “Y” or “N” in the Requirement (Reqt) column indicates if this attribute must be supported in order to meet fundamental compliance for the service. 5.2.3 The Form column is used to indicate the format of\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 5  Conventions (Part 2)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 5  Conventions\n\nContent: the attribute. (See Section 4.2.4 for definitions.)\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 5.3  Service Message Representation\n\n5.3.1  Service Resource Definition — A service resource definition table defines the specific set of messages for a given service group, as shown in the following table:  \n5.3.1.1  Type can be either $\\boldsymbol { \\mathrm { ~ N ~ } } =$ Notification or ${ \\textbf { R } } =$ Request.  \n5.3.1.2  Notification type messages are initiated by the service provider, and the provider does not expect to get a response from the consumer/subscriber.  \n5.3.1.3  Request messages are initiated by a service consumer or subscriber. Request messages ask for data or an activity from the provider. Request messages expect a specific response message (no presumption on the message content).  \n5.3.2  Service Parameter Dictionary — A service parameter dictionary table defines the parameters for one or more services, as shown in the following table:  \n5.3.2.1  A row is provided in the table for each parameter of the service. The first column contains the name of the parameter. This is followed by columns describing the form and contents of the corresponding primitive.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 5.3.2.2  The Form column is used to indicate the type of data contained in a parameter. (See Section 4.2.4 for definitions.) (Part 1)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 5.3.2.2  The Form column is used to indicate the type of data contained in a parameter. (See Section 4.2.4 for definitions.)\n\nContent: 5.3.2.3 The Description column in the Service Parameter Dictionary table describes the meaning of the parameter, the values it can assume, and any interrelationships with other parameters. 5.3.2.4 To prevent the definition of numerous parameters named “XxxList,” this document adopts the convention of referring to the list as “(List of) Xxx.” In this case, the definition of the variable Xxx will be given, not of the list. The term “list” indicates a collection (or set) of zero or more items of the same data type. Where a list is used in both the request and the response, the list order in the request is retained in the response. A list must contain at least one element unless zero elements are specifically allowed. 5.3.3 Service Message Definition — A service message definition table defines the parameters used in a service, as shown in the following table: 5.3.3.1 The columns labeled Req/Ind and Rsp/Conf link the\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 5.3.2.2  The Form column is used to indicate the type of data contained in a parameter. (See Section 4.2.4 for definitions.) (Part 2)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 5.3.2.2  The Form column is used to indicate the type of data contained in a parameter. (See Section 4.2.4 for definitions.)\n\nContent: parameters to the direction of the message. The message sent by the initiator is called the “Request.” The receiver terms this message the “Indication” or the request. The receiver may then send a “Response,” which the original sender terms the “Confirmation.” 5.3.3.2 The following codes appear in the Req/Ind and Rsp/Conf columns and are used in the definition of the parameters (e.g., how each parameter is used in each direction): “M” — Mandatory Parameter — must be given a valid value. “C” — Conditional Parameter — may be defined in some circumstances and undefined in others. Whether a value is given may be completely optional or may depend on the values of other parameters. “U” — User-Defined Parameter “-” — The parameter is not used. “=” — (for response only) Indicates that the value of this parameter in the response must match that in the primary (if defined).\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 6  Background\n\n6.1  During the development of proposals for several other service standards, it was discovered that they shared a common need for terminology and services related to objects. Originally each proposal included a service-specific message for getting the values of an object' s attributes, and some also provided a servicespecific message for setting these values.  \n6.1.1  The decision was made to eliminate this redundancy through provision of a standard to provide those definitions and services used by the other separate service standards.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 7  Applicable Documents\n\nSEMI Book of Standards, Equipment Automation/ Software Volumes 1 and $2 ^ { 5 }$  \nISO/TR 8509:1987,6  Information Processing Systems, Open Systems Interconnection — Service Conventions  \nWilliam Stallings, Networking Standards, A Guide to OSI, ISDN, LAN, and MAN Standards, Addison-Wesley Publishing Company\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8  Basic Concepts and Behavior (Part 1)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8  Basic Concepts and Behavior\n\nContent: 8.1 This section defines the concepts and behavior that are common to public objects. 8.1.1 Object-oriented analysis is a widely accepted tool, both for applications that are implemented using object-oriented technologies and those using traditional technologies. Object information models provide a powerful method for describing relationships that can be intuitively understood. 8.1.2 For those unfamiliar with object-oriented terminology, a brief discussion of terms is provided in the Appendix. 8.2 Object Attributes — An object attribute is a data value that is held by all instances of a given object type. For communication purposes, public attributes are assigned a logical name that is unique for that object. An object' s attributes may be individually referenced either by an enumerated numeric value or by a reserved attribute name that conforms to the use of text defined in Section 8.1.1. 8.2.1 An attribute that can be requested or referenced through formal public services is a public attribute. Other\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8  Basic Concepts and Behavior (Part 2)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8  Basic Concepts and Behavior\n\nContent: attributes may exist in specific implementations but are invisible through public services and are called private attributes. 8.2.2 Specific attributes may be designated as fundamental for a specific object. These shall be supported by all implementations that use or reference the specified object. Attributes that are not fundamental are optional. 8.2.3 Use of Text — Values defined as text, when given in ASCII, are subject to certain restrictions. This includes object attribute values, attribute names, and service parameters. 8.2.3.1 Text in ASCII is restricted to the characters between $2 0 _ { 1 6 }$ and $7 \\mathrm { E } _ { 1 6 }$ , excluding the question mark “? ”, the asterisk “\\*”, and the tilde “\\~ ”. 8.2.3.2 The question mark and asterisk are reserved for use as “wild characters” in filters and searches, while the tilde is reserved to allow systems that cannot use spaces to convert spaces to tildes for internal use. 8.2.3.3 Text used in specific contexts may have additional restrictions. 8.2.3.4 Unless\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8  Basic Concepts and Behavior (Part 3)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8  Basic Concepts and Behavior\n\nContent: otherwise stated, case is not significant for purposes of comparison. However, case is used to improve readability and should be preserved whenever possible. 8.2.4 Object Type — An object always knows its type. For this reason, the attribute for object type, ObjType, is required for all public objects. ObjType is a text string containing the formal classification of an object. The text string shall conform to the convention defined in Section 8.1.1, with the additional restriction that the “greater than” symbol “>” and the colon “:” are also excluded. The text string shall not start or end with a space. 8.2.4.1 Object types (the values for ObjType) for standardized objects are reserved. Types reserved are specific to individual standards. 8.2.5 Object Identifier — Every instance of an object shall have one or more attributes that together uniquely distinguish that instance from all other instances of objects of the same object type. An object may have more than one identifier. The identifier(s) are defined as\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8  Basic Concepts and Behavior (Part 4)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8  Basic Concepts and Behavior\n\nContent: part of the object definition. 8.2.5.1 ObjID is a text-based fundamental attribute of all public objects and provides an attribute of a known form to serve as an identifier for an object of any type. The text string shall conform with the convention defined in Section 8.1.1 and with the additional restriction that the “greater than” symbol $^ { * * } >$ ” and the colon “:” are also excluded. The text string shall not start or end with a space. 8.2.5.2 From the point of view of objects such as managers, aggregates, and containers that have responsibilities for other objects (see Sections 9.1 and 9.2) the combination of ObjType and ObjID for these other objects shall be unique. For example, if several process chambers have a single vacuum pump, each process chamber may have direct access to at most one ObjType:ObjID> combination of “Pump:Vacuum”. However, the combination is not required to be unique across the different chambers. The host differentiates between the several vacuum pumps by their belonging to\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8  Basic Concepts and Behavior (Part 5)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8  Basic Concepts and Behavior\n\nContent: different aggregations. 8.2.5.3 The object definition for each object shall specify the particular identifier used for general access. For objects that normally use an identifier with a numeric value as an identifier (such as “handle,” described below), the value of ObjID is a numeric text string set to the value of that attribute.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8.2.5.4  An object may also have other identifiers in addition to ObjID. (Part 1)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8.2.5.4  An object may also have other identifiers in addition to ObjID.\n\nContent: 8.2.6 Object Handle — An object' shandle is an attribute with a numeric value that is assigned by the application that created the object. The handle may be used for the object' s identifier. It is generally intended for local use and may or may not be defined as a public attribute in the object' s formal definition. 8.2.6.1 Where used, the handle may be guaranteed to be unique only within a specific context and within a single association between service-provider and service-user for a specific service resource. The handle may or may not be persistent beyond a certain context within that association or beyond it. Persistence of the handle is specified as part of the definition of the object and is beyond the scope of OSS. 8.3 Object Definition — An object definition includes an attribute definition table described in Section 5.3. 8.3.1 The object that is the super-type of all public objects is called the top object. The attributes and operations of the top object,\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8.2.5.4  An object may also have other identifiers in addition to ObjID. (Part 2)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 8.2.5.4  An object may also have other identifiers in addition to ObjID.\n\nContent: shown in Figure 1, are fundamental requirements for all public objects. That is, all objects shall respond to the object attributes ObjType and text strings, and all public objects shall recognize and respond to the operations get attributes and set attributes. 8.3.2 Formal definition of an object shall include a table defining the object' s pbulic attributes. The Object Attribute Definition table for the top object is given in Table 1 below. It contains the two fundamental attributes required of all public objects. Table 1 Top Object Attribute Definition 8.3.3 Access refers to the ability to read and write the value of the attribute through OSS services. An object’s type and identifier may not be changed through OSS services. However, it may be possible for the service user to assign a value for the object' s identifier at the time the object (instance) is created. This depends on the object and the services provided.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships (Part 1)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships\n\nContent: 9.1 This section addresses relationships between objects that affect communications, either by restricting communications or through information concerning relationships. 9.2 Object Hierarchy — Certain objects may be specified as aggregation objects or as container objects when they are defined. 9.2.1 An aggregation object is composed of other objects called the components of the aggregation. This is illustrated in Figure 2. Components may be of one or more different types, or they may be of the same type. 9.2.2 Container objects contain other objects, of the same or different types, but are not made up of them. 9.2.3 Figure 3 shows two object types that are associated with a relationship called “contains.” The solid circle indicates that Type-1 may contain zero or more objects of Type-2 type. An example of a common container type is a file directory. Figure 3 Container and Contents 9.2.4 An aggregation loses some degree of integrity if certain of its components are missing, while a container retains full integrity\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships (Part 2)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships\n\nContent: even if it has no contents. An automobile is an aggregation of many components, some of which are themselves aggregations. An automobile may also have contents (driver, passengers, belongings) which are removable and not considered as components. Other examples of container objects include lists, dictionaries, and libraries. A container that has no contents is said to be empty. 9.2.5 The aggregation or container is called the superior object and its components or contents are called subordinate objects. 9.2.6 In addition to the relationships of “is composed of” (roles: aggregate/component) and “contains” (roles: container/contents), the other hierarchical relationship that occurs naturally in factories and in control systems is that of “supervises” (roles: supervisor/supervised). This denotes a control relationship where the supervised object accepts part or all of its directions from the supervisor. The supervisor, in turn, has responsibilities that it delegates to the supervised. The supervisor typically will also\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships (Part 3)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships\n\nContent: have a relationship of “is composed of” or “contains” with its supervised subordinates. 9.3 Scope and Ownership — The hierarchical relationships of aggregations, containers, and supervisors may at times be required for pointing to a specific object. These relationships may be shown with a multi-level tree structure, as shown in Figure 4. Subordinate objects at one level may be the superior objects at the next lower level. The superior object at the highest level is called the root of the tree. NOTE 1: Figure 4 is not drawn in OMT notation. 9.3.1 An owner object is an object that is an aggregate, container, or supervisor. An owned object is an object that is a component of, contained in, or supervised by, an owner object. 9.3.2 Scope7 is the concept and method of pointing to a specific owned object through the use of sequence of hierarchical relationships. Scope allows any particular object (type or instance) within such a hierarchical tree to be fully specified by providing a unique path down this tree using a\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships (Part 4)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships\n\nContent: concatenation of object types and identifiers. 9.3.3 This path is used to create an object specifier that is represented as a sequence of concatenated text strings of the form “type:id>”, which may be repeated as necessary to form the complete path. The character “>” is used to terminate the object type field, and the colon character “:” is used to terminate the identifier field. The object specifier uniquely identifies an object within the entire domain of objects and is able to extend the domain within which a search for an object would otherwise occur. 9.3.4 Formally, an object specifier is a formatted text string of the form: “type $^ 1$ :id1>...typen:idn>” where “typei” and $\\mathrm { \\tilde { \\ v } _ { i d _ { i } } \\mathrm { \\overline { { \\ v } } _ { i } } } ,$ represent the object type and object identifier, respectively, of the ith object instance in the sequence, and where the ith object is owned by the (i-1)th object and is the owner of the $( \\mathrm { i } + 1 \\mathrm { \\dot { \\Omega } }$ )th object.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships (Part 5)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships\n\nContent: 9.3.5 Figure 5 shows an example of a typical set of hierarchical relationships in the factory. An application of scope might be through Cell AB, Cluster BB, Process Module (PM) CB, to Device DB. In this example, the object specifier for Device DB would be: “FactoryHost:Hilda>Cell:AB $\\cdot >$ Cluster:BB>PM:CB> Device:DB>” 9.3.6 It is generally not necessary to start with the root object. It is sufficient to start with an object that is owned by the communications partner. However, it is invalid to omit a level in the hierarchy that is between the starting object and the final object in the path. 9.3.7 Some systems may be able to guarantee the uniqueness of object identifiers for their owned objects. For example, equipment may be able to guarantee that all of its owned objects have unique identifiers regardless of type. In this case, an object’s identifier is sufficient to point to a specific object instance. Object type may be omitted without ambiguity, as it may be obtained as an attribute of the specified object.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships (Part 6)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships\n\nContent: The form of the path then becomes \" $\\mathrm { i d } { > } \\mathrm { i d } _ { 2 } { > } . \\mathrm { i d } _ { \\mathrm { n } } { > } \"$ . In the previous example, this might be \" $\\mathrm { A B { > } B B { > } C B { > } D B { > } \" }$ 9.3.8 Object type may also be omitted in applications where it may be inferred without ambiguity within a particular context. A service that is dedicated to a specific object type X, for example, that is always owned only by another specific object type Y, may specify usage for object type X. Since object type may then be inferred from the context, object types X and Y need not be included in a specifier for an object of type X. 9.3.9 The terminator of the final identifier is optional. This allows a single object identifier to be used as a simple object specifier. As a result, however, it may be necessary to provide string delimiters to prevent premature termination of string parsing in the event an identifier contains one or more embedded spaces. 9.3.10 Scope can be applied to any set\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships (Part 7)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships\n\nContent: of hierarchical relationships, given a minimum set of requirements for public objects: an object always knows its own type (ObjType), an object always knows its own identifier(s) (including ObjID), an owner object knows the types of objects that are its components and/or contents, or that it otherwise supervises, and is able to determine their identifiers (see GetType, Section 11.6), an owner object is able to determine the types and identifiers of its owned objects. 9.4 Multiple Inheritance Hierarchy — Multiple hierarchical inheritance may be required as an optional capability for pointing to a specific object that provides the same services from the inherited objects. Usually, inherited services are implemented by the domain object such that specifying “overrides” of attributes or services from inherited objects is not required. Sometimes the capability to override specified attributes and services from inherited object is necessary to resolve duplicated attribute names or services or to allow duplicated names in\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships (Part 8)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 9  Object Relationships\n\nContent: user extended objects. 9.4.1 If Andy an object TypeA inherits from object TypeB and TypeC and a service requestor is focusing services or attributes of the object TypeB rather than those with the same name in the object TypeC, the following text string form could specify the focused part of the object Andy:\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # TypeA@TypeB:Andy\n\n9.4.2  If any names of service and/or attribute that TypeB provides are the same as those provided by TypeA or TypeC, then, the object Andy will have to be specified with the complete explanation from the supplier as how the object handles the exception and the differences from the original attribute or services. So, the above expression is the same as “TypeA:Andy” without notes to describe difference.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations (Part 1)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations\n\nContent: 10.1 This section defines operations that are common to many types of public objects but are not required for all types of public objects. These operations are not required for OSS compliance. However, they may be required for support of specific object types defined by other standards that use OSS services. 10.2 Create and Delete — Creation and deletion are optional services for object lifecycle management. Object definitions may specify conditions under which the services are supported. Objects may be created and/or deleted in other ways. For example, the creation and deletion of certain types of persistent objects may be outside of the scope of OSS services, while transient objects may be created and/or deleted automatically by their owners as the result of other activities. 10.2.1 Create — The create operation creates an instance of an object type. 10.2.1.1 Initial settings for one or more attributes may be specified by the service user. Initial settings may be required, prohibited, or optional, depending upon\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations (Part 2)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations\n\nContent: the specific object type. The ability to set attribute values through the create operation shall be clearly identified as part of the object definition for those objects supporting the create operation. For example, the ability to set the value of the object identifier ObjID may be required, optional, or prohibited, depending upon the type of object. 10.2.1.2 The object definition may also specify attributes of the new object instantiation that are returned to the service user by the service provider. 10.2.1.3 A request to create an object is invalid if it does not provide all required attribute settings, if it attempts to set prohibited attributes, or if it provides values invalid for a given attribute. 10.2.1.4 The definitions of certain objects may specify that the delete service only be provided to, or under the authority of, the service user that requested the original create operation. In this case, a private attribute (that is, an attribute not accessible through services defined in Section 11) named Delete\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations (Part 3)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations\n\nContent: Token shall return a unique integer as an attribute of the new object. This attribute is then used in a subsequent request to delete the object. The service user may delegate this token at its own discretion. 10.2.1.5 The create operation is invoked by the service Create sent to the owner that is to instantiate the specified object. In order for the Create service to be accepted if no owner for the object to be created is defined in the target entity or if it is physically outside of the domain of the entity; the object specifier shall define the owner as “ ” (an empty string). If the entity is just the equipment rather than a component of the equipment; the owner may be defined as“Equipment” even if no such object is defined. 10.2.2 Delete — The delete operation is the inverse of the create operation. Individual object types may restrict deletion based on well-defined set of criteria. For example, the definition of a type of container may specify that a container may only be deleted when it is empty. 10.2.2.1 If\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations (Part 4)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations\n\nContent: an object to be deleted requires the authority of the service user that invoked the original create operation, then the Delete Token attribute of the target object shall be provided by the user of the delete service. 10.2.2.2 A request to delete an object is invalid if it does not provide all required attribute settings or if it provides values invalid for a given attribute. 10.2.2.3 The delete operation is invoked by the service Delete sent to the object to be deleted. 10.3 Attachment — When an object receives a remote request for an operation, it may be unable to identify the requestor. At the same time, it may be necessary for an object to determine if certain messages were sent by its supervisor. This conflict is resolved by formalizing the relationship between a supervised object and its supervisor. 10.3.1 Attachment is a dynamic behavioral binding between two objects in a hierarchical relationship where it is important that the attached (supervised) object be able to differentiate certain service requests\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations (Part 5)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations\n\nContent: made by its supervisor from other requests. An attached object has exactly one supervisor, as illustrated in Figure 6. 10.3.2 An attached object may be detached from its current supervisor, or it may be reattached to a different supervisor. The latter operation is used when the previous supervisor has become damaged and is not intended as a general method for moving the object’s attachment, as the former supervisor is not notified of the change. 10.3.3 Attach — When sent to an unattached object, the attach operation creates a logical connection between the object and a supervisor. The object that is being attached creates a unique, private, non-zero numeric value, called an attach token. The attach token is treated as an attribute named AttachToken. It is a private attribute of the attached object, not visible through basic OSS services (see Section 11). 10.3.3.1 When an object is first created, it is unattached, and the value of its attach token is set to a default value of zero. An object is attached to another\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations (Part 6)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations\n\nContent: object as a formal relationship. The operation of attach generates the attach token, which is returned to the service user. The supervisor uses this token in subsequent critical service requests to identify itself to the attached object. 10.3.3.2 The attach operation also may accept settings for one or more attributes of the attached object, as defined for the attached object type. This allows the supervisor to provide values for attributes that are otherwise regarded as read-only values and cannot be set through the SetAttr service defined in Section 11. An example of an attribute value that it is often desirable to access in this way is the object specifier of the supervisor. 10.3.3.3 Requests to attach an object that attempt to set attributes shall be denied unless the attributes are among those accessible to the supervisor and all specified settings represent valid values of those attributes. The object type and identifier shall not be changed by the supervisor. 10.3.3.4 An attached object is owned by its\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations (Part 7)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations\n\nContent: supervisor. 10.3.3.5 The attach operation is invoked by the message service Attach by an intended supervisor. Requests to attach an already attached object shall be denied. 10.3.4 Attach Set Attributes — A supervisor may need the ability to set certain read-only attributes of one of its attached objects subsequent to the attach operation. The set attached attributes operation provides this capability to a supervisor of attached objects. The supervisor identifies itself by using the attach token for that object. 10.3.4.1 The definition of the attached object type may restrict the attributes that may be set by this operation. The attach set attributes operation shall be denied if the attributes or settings are invalid for this operation. 10.3.4.2 The attach set attributes operation is invoked by the message service AttachSetAttr sent by the object’s supervisor and is otherwise invalid. 10.3.5 Detach — The detach operation breaks the logical connection between an attached object and its supervisor. The attach token is\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations (Part 8)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations\n\nContent: reset to zero, and the object becomes unattached. 10.3.5.1 The detach operation is invoked by the message service Detach sent by the object’s supervisor and is otherwise invalid. 10.3.6 Reattach — The reattach operation is similar to the attach operation, except that it is sent only to an attached object to change the logical connection from the attached object to a new supervisor. This operation is used to replace a damaged supervisor. Any existing connections to the old supervisor shall be closed. Note the reattach operation is vulnerable to misuse. Applications supporting the reattach operation may have additional requirements, such as notification sent to the previous supervisor, to provide a trace of misuse. 10.3.6.1 The reattach operation provides a unique attach token that has not been previously used by the attached object. This effectively disables its previous supervisor. 10.3.6.2 An attempt to reattach an object shall be denied unless the attributes and settings are valid for the operation. 10.3.6.3 The\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations (Part 9)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations\n\nContent: reattach operation is invoked with the message service Reattach sent to an attached object by the object’s new supervisor and is otherwise invalid. 10.3.7 Attach Supervised Object — The attach supervised object operation is invoked by a service user to request a supervisor to attach to itself a valid target object. If the supervised object does not already exist or is not a valid target type for the supervisor, then the attached supervised object operation shall fail. The results of the operation are returned to the service user. 10.3.7.1 The attach supervised object operation is invoked with the service AttachSupervisedObject. 10.3.8 Detach Supervised Object — The detach supervised object operation is invoked by a service user to request a supervisor to detach from itself an attached object. The supervisor sends a detach request to the specified attached object. Regardless of any response from the specified supervised object, the supervisor shall consider it thereafter as unattached. This is required to allow a\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations (Part 10)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 10  Additional Operations\n\nContent: damaged attached object to be removed. This operation is successful except when the target object is not already attached to the supervisor. 10.3.8.1 The detach supervised object operation is invoked with the service DetachSupervisedObject.\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11  Services and Scenarios (Part 1)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11  Services and Scenarios\n\nContent: 11.1 The services defined by OSS are contained in Table 2. Table 2 Object Services 11.2 Scope — Scope is supported through the object specifier parameter. The object specifier provides a method for pointing to objects owned by the service provider that are otherwise not accessible to the service user. That is, the service provider may not provide direct services for, or to, that object. This can occur when an object for which the service provider offers services is an owner object, such as an aggregate or file directory, as described in Section 9. In some cases, the owned object may itself be remote from the service provider. For example, the owned object may be provided by a separate system. 11.2.1 The service provider may be an owner object with managerial responsibilities, and therefore it may prohibit direct access to one of its component or contained objects. In this case, requests concerning an owned object from a service consumer shall be directed to the owner object instead. 11.2.2 Object services use the\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11  Services and Scenarios (Part 2)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11  Services and Scenarios\n\nContent: object specifier for the owner of the target object(s). The construction of the object specifier is defined in Section 9. 11.2.3 Object type may be omitted from the object specifier where it may be otherwise determined without ambiguity. However, inclusion of type is always valid. 11.3 Filtering — An attribute filter is an optional set of one or more attribute qualifications. An attribute qualification is a boolean expression that makes a statement about the presence or values of attributes in a target object. It identifies an attribute, a qualifying value of that attribute, and a qualifying relationship that the value has to the target attribute. The attribute filter is a boolean that consists of the expression formed by an AND of the set of qualifications. 11.3.1 If the attribute is of text form, the qualifying value may be used as a mask with the embedded wild characters “? ” (question mark) and “\\*” (asterisk). The character “? ” may be used within the mask to represent “any single character” and may be\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11  Services and Scenarios (Part 3)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11  Services and Scenarios\n\nContent: repeated. The string “? ? ? ? ? ” represents any text string with a length of fi characters. 11.3.2 The character “\\*” may be used in the mask to represent a variable-length string, including a null string. The string $\\mathbf { \\mu } ^ { 6 6 } \\mathbf { \\ddot { x } } ^ { 3 }$ represents a string of any length that ends in $^ { 6 6 } \\mathrm { X } ^ { 7 3 }$ ; the string $^ { 6 6 } \\mathrm { X } ^ { * } { } ^ { , , , }$ represents any string that begins with $^ { 6 6 } \\mathrm { X } ^ { 3 5 }$ . 11.3.3 When the character “\\*” is used by itself as the string “\\*”, however, it represents any string of any nonzero length. It may also be repeated within a string, as in “\\*x\\*y\\*”, which represents any string with embedded characters $\\mathbf { \\dot { \\vec { x } } } _ { \\mathbf { \\vec { X } } } ^ { , \\vec { \\mathbf { \\vec { \\nu } } } }$ and “y”, such as “abxaby”, “x_y”, and “xy”\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11.3.4  The comparison for text characters shall be case insensitive. (Part 1)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11.3.4  The comparison for text characters shall be case insensitive.\n\nContent: 11.3.5 The qualifying value specifies a qualifying relationship, “R”, between the value specified in the attribute qualification and the matching attribute of object instances. The qualifying value for the attribute is compared with the attribute of an instance of the target object to test the relationship. 11.3.6 If the qualifying value has the relationship “R” to the attribute of the target object, then the instance qualifies for the relationship and is included in the set of objects for which requested attributes are returned. For example, if the attribute name is “Length,” qualifying value is the number 5, and the qualifying relationship is “is less than,” then the Length attributes of all instances of the target object are tested. All instances with a “Length” attribute greater than 5 or equal to 5 qualify. 11.4 Object Services Parameter Dictionary — Table 3 defines all of the parameters, including the elements of complex parameters, used in object services. Table 3\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11.3.4  The comparison for text characters shall be case insensitive. (Part 2)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11.3.4  The comparison for text characters shall be case insensitive.\n\nContent: Object Services Parameter Dictionary 11.5 Get and Set Attributes — The GetAttr and SetAttr services are provided for reading and setting values of an object' s attributes. Theyaddress attribute values of instances of objects. Figures 7 and 8 show the message flow for the GetAttr service. is particularly useful when the list of contents may be quite long. 11.5.4 The attribute value (all or a part of the list of ObjSetting) returned by the GetAttr service may be invalid if the acknowledge code of ObjStatus indicates a failure. In that case; the value(s) requested by the invocation of GetAttr service may be unknown, invalid or unavailable by any reason (e.g. corresponding hardware status, lack of privilege, mutual exclusion or other requirement not fulfilled by the application). Supplier shall document all conditions or timing requirements of any attributes if they are not always available. 11.5.5 The attribute value (all or a part of the list of ObjSetting) replied by the\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11.3.4  The comparison for text characters shall be case insensitive. (Part 3)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11.3.4  The comparison for text characters shall be case insensitive.\n\nContent: SetAttr service may be still unchanged if the acknowledge code of ObjStatus indicates a failure. In that case; the attribute value may be unchangeable, inhibited or blocked internally by any reason (e.g. corresponding hardware status, lack of privilege, mutual exclusion or other requirement not fulfilled by the application. The object providing the SetAttr service shall identify whether or not it is valid to change or set an attribute value. Supplier shall document all conditions and timing requirements of each attribute if they are not always allowed to be set. 11.5.1 GetAttr and SetAttr allow access to attributes of objects that are owned by another object and are capable of addressing multiple levels of ownership (object hierarchy). 11.5.1.1 For example, GetAttr may be used as a “get directory” request to find the identifiers of all instances of one or more owned objects. 11.5.2 GetAttr and SetAttr may be used for objects that use a complex identifier, such as recipes\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11.3.4  The comparison for text characters shall be case insensitive. (Part 4)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11.3.4  The comparison for text characters shall be case insensitive.\n\nContent: with separate attributes for name and version. 11.5.3 GetAttr and SetAttr allow searching for those instances of an object that satisfy certain conditions through the specification of one or more qualifiers or filters. Only attributes of those instances of the desired object type that satisfy the conditions defined in the filters are returned by the service provider. 11.5.3.1 The filter is familiar to users of file services as a convenient way to obtain a partial directory of files, such as files with a date later than a specified date. This 11.5.6 Object Specifier — This parameter is used for specifying an owner object and may be omitted from the message. When included, it is a formatted text string that conforms to the description in Section 9. An object specifier is rejected by service providers that do not use owner or owned objects. 11.5.7 Filter — This is a optional list of qualifications to be applied to specifed attribute and may be omitted from the message. When\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11.3.4  The comparison for text characters shall be case insensitive. (Part 5)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11.3.4  The comparison for text characters shall be case insensitive.\n\nContent: included, the complete filter is formed by a logical AND of each attribute qualification in the list. 11.5.8 Requested Attribute — The final parameter in the GetAttr service gives the names of one or more attributes of interest. These are the attributes whose values shall be returned in the response, in the order requested. 11.5.9 Settings — In the SetAttr service, a list of one or more attribute name/value pairs is specified. This is the set of desired attribute values. SetAttr rejects any attempt to set a read-only attribute and returns information in Status, indicating the error and the attribute. 11.5.10 ObjStatus — This is a required parameter in the response message. It is a structure that consists of an acknowledge code and a list of status parameters. The acknowledge code is used to indicate errors that apply to the response as a whole. A status parameter is a structure consisting of a code indicating a specific error and accompanying text providing additional\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11.3.4  The comparison for text characters shall be case insensitive. (Part 6)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11.3.4  The comparison for text characters shall be case insensitive.\n\nContent: information. Text is often used to inform a person of the results of an operation. Table 4 GetAttr Service 11.5.11 Tables 4 and 5 define the parameters for the GetAttr and SetAttr services, respectively. Table 5 SetAttr Service 11.6 GetType — GetType is a service that is directed at object types rather than object instances. It is used to ask an owner object for the object types that it owns. 11.6.1 Figure 9 shows the message flow for the GetType service. 11.6.2 Comments for the ObjSpec and ObjStatus parameters of GetAttr and SetAttr also apply to the parameters for the GetType service. 11.6.3 Table 6 defines the parameters for the GetType service. Table 6 GetType Service 11.7 GetAttrName — GetAttrName is a service that is directed at object types rather than object instances. It is used to ask for the names of the attributes of one or more objects owned by the service provider. 11.7.1 Figure 10 shows the message flow for the GetAttrName service. 11.7.2 Wild characters\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11.3.4  The comparison for text characters shall be case insensitive. (Part 7)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 11.3.4  The comparison for text characters shall be case insensitive.\n\nContent: may be used in the object types requested. 11.7.3 Comments for the ObjSpec and ObjStatus parameters of GetAttr and SetAttr also apply to the parameters for the GetAttrName service. 11.7.4 Table 7 defines the parameters for the GetAttrName service. Table 7 GetAttrName Service\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 12  Additional Services (Part 1)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 12  Additional Services\n\nContent: 12.1 Additional services described in this section may have some restrictions when invoked. In some cases, services that are invoked may report a failure. For example: the owner of an object shall not delete the object during its lifecycle or while it is valid and required by another agent. Existence of an object may depend on preconditions, provided parameters, state of another object, corresponding operation, context of application, etc. Supplier shall document any restrictions or information regarding the validity of the additional services listed below. 12.1.1 This section defines the services required for additional operations defined in Section 10. These services are listed in Table 8. Table 8 Additional Object Services 12.2 Object Services Parameter Dictionary — Parameter definitions are provided in Section 11.1. 12.2.1 Table 9 defines the parameters used in services defined in Section 12, in addition to those parameters defined in Table 3. Table 9 Additional Object Services Parameter Dictionary 12.3 Create —\n\nSEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 12  Additional Services (Part 2)\n\nTitle: SEMI E39-0703 OBJECT SERVICES STANDARD: CONCEPTS, BEHAVIOR, AND SERVICES - # 12  Additional Services\n\nContent: The service user may request the service provider to create a new object and assign the value of one or more of its attributes. The request may be denied if an attempt is made to set attributes that are not allowed for that object type.",
  "images": []
}