{
  "doc_id": "semi_docs_047",
  "chunk_id": 1,
  "content": "SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 5.3  Definitions (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 5.3  Definitions\n\nContent: Module). For a Process Module, the Module Parameters might represent temperatures, pressures, flow rates, etc. An equipment recipe typically manipulates Module Parameters to accomplish its purpose. 5.3.4 PDE (Process Definition Element) — an executable specification of an activity or process on an equipment. The recipe for a particular equipment activity may consist of multiple PDEs. A $P D E$ is the smallest process definition unit that can be individually managed with FICS participation or knowledge. Each $P D E$ includes a PDEheader and a PDEbody. 5.3.5 PDEbody — the executable portion of a Process Definition Element. The PDEbody is typically contained within the $P D E$ construct. In some cases, a PDEbody may exist as a separate entity, but it is always exclusively related to its PDE. 5.3.6 PDEeditor — a software system that provides the ability to create, delete, and modify a PDE. A PDEeditor may exist as a subsystem of an equipment or as a standalone system provided either by the manufacturer of the equipment or a third\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 5.3  Definitions (Part 3)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 5.3  Definitions\n\nContent: party. 5.3.7 PDEheader — the descriptive portion of a Process Definition Element. The PDEheader is a collection of information related to a PDEbody. This information is sufficient to manage and utilize the $P D E$ without accessing its PDEbody. 5.3.8 uuid — universally unique identifier. This 128-bit field (often represented as a 36-character string) is calculated according to the standard ISO/IEC 11578:1996 – Remote Procedure Call (RPC). The field is guaranteed to be unique over all space and time. The uniqueness holds even though the uuids are created independently by separate entities. 5.3.9 Variable Parameter — a formally defined variable (setting) defined in the body of a recipe, permitting the actual value to be supplied externally.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 6  Conventions\n\n6.1  The following conventions are used in this document:  \n• To highlight terms specific to RaP, a term appears in italics within the specification.  Italicized terms include class names, attributes, and services.  Service names also end in (), for example “getPDE()”. To prevent the definition of numerous message parameters named \"XxxList,\" this document adopts the convention of referring to the list as \"list of Xxx\".  In this case, the definition and data type of the parameter will be given (not the type of the list).  The term \"list\" indicates a collection (or set) of zero or more items of the same data type.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 6.2  Object Modeling\n\n6.2.1  Unified Modeling Language (UML)  \n6.2.1.1  This specification uses UML notation for all class diagrams and for any object diagrams provided as examples.  No other types of object modeling diagrams are used in this specification.  \n6.2.2  Class Diagrams  \n6.2.2.1  UML class diagrams have clearly defined meaning and are a part of this specification.  Detail contained in these diagrams is not necessarily repeated in the text.  \n6.2.3  Name of a Class  \n6.2.3.1  The text capitalizes class names.  Class attributes and services begin with lowercase letters.  \n6.2.4  Abstract and Concrete Classes  \n6.2.4.1  Each class is specified as Abstract or Concrete.  Abstract classes are not directly implemented (that is, there are no instances).  All classes defined as concrete may be directly implemented.  In UML class diagrams, abstract class names are shown in italics.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 6.2.5  Class Attribute Definition (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 6.2.5  Class Attribute Definition\n\nContent: 6.2.5.1 The attributes of a class are defined in table format as illustrated by Table 1 below. Note that the $^ { 6 6 } + ^ { 5 9 }$ sign in front of attributes in UML class diagrams indicates “public” attributes. All attributes defined in this specification are public, therefore the $^ { 6 6 } + ^ { 5 9 }$ sign is omitted. Table 1 Attribute Table Format 6.2.5.1.1 Access — Attributes may be settable (ReadWrite or RW) or not settable (ReadOnly or RO) through an interface to the service provider.4 6.2.5.1.2 Reqd — Is this attribute required? Y – Yes, or $\\Nu - \\Nu _ { 0 }$ . 6.2.5.1.3 Form — Defines the data type of the attribute. Data types in this specification are high-level definitions and should be mapped to the data types of a specific technology as appropriate. In this specification, these data types are also used for the parameters of message services. Binary — A sequence of bytes that may have any value. Binary values are sometimes called “unformatted” because their structure is not apparent. • Boolean\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 6.2.5  Class Attribute Definition (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 6.2.5  Class Attribute Definition\n\nContent: — Takes the value of “true” or “false”. • Enumeration — A format that allows a specified list of possible values. In this document, these values are represented as text strings, but may be implemented differently (e.g. as integers that correspond to the named values). Error — The Error type is a structure that contains information about an error that has occurred. The form of the structure is implementation dependent and shall be defined by each sub-specification of RaP that describes messaging using a specific technology (for example SECS-II or XML/SOAP). Integer — A numeric value. Integers are always whole numbers. The form and number of bytes is left to the implementation definition. Real — A numeric value that may represent any whole or fractional number. The form and number of bytes is left to the implementation definition. String — A text string. Limitations on length are left to the implementation technology unless otherwise specified in this document. Strings are recommended to be implemented as\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 6.2.5  Class Attribute Definition (Part 3)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 6.2.5  Class Attribute Definition\n\nContent: UTF-8. • Checksum — A checksum value calculated on a specific stream of data using a specific method of calculation. . Time — Representation of the date and time of the occurrence of interest. The structure and form of items of this type is left to the implementation. UUID — Universally unique identifier created according to the ISO specification referenced in $\\ P 4 . 2$ and represented as ASCII characters. Note that this type is represented by all-caps “UUID” to differentiate it from the “uuid” ISO standard string definition that defines the content of an attribute of type “UUID”. • Any — The format may be any of the others listed in this section. Format is determined by the implementation. • list of xxx — An item that can hold multiple instances of a specified type (where xxx is the data type). 6.2.6 Association Documentation 6.2.6.1 Associations are documented using the form of Table 2. Only Navigable Associations for the class of interest are included in the table. See $\\ P 6 . 2 . 7$ for explanation of\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 6.2.5  Class Attribute Definition (Part 4)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 6.2.5  Class Attribute Definition\n\nContent: Navigable Associations. 6.2.6.2 For each association, the table lists the Type, Description, Associated Class, Role, and Cardinality • Type — The type of association. The possible values include Composition, Aggregation, and Association. See the UML standard in $\\ P 4 . 3$ for an explanation of these types of association. • Description — Text describing the association. • Associated Class — The name of the class connected by this association. • Role — The role name of the associated class in the association taken from the UML diagram. Composition associations are not given roles in this document, since it usually implies containment of the aggregated objects. • Cardinality — How many of the associated class may be associated with this class – documented in UML form. Table 2 Navigable Associations for Class xxx\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 6.2.7  Association Navigability\n\n6.2.7.1  UML associations include the concept of “Navigability”.  When an association is navigable, the association may be traversed to reach the class instance at the opposite end of the association (target object).  \n6.2.7.2  By default, an association is navigable in both directions.  If an arrowhead is shown on one end of an association, then navigability exists only in that direction.  \n6.2.7.3  From any object, it must be possible to obtain a reference to the target objects of any of its navigable associations.  For any navigable association defined in this document, this is required of the implementer.  The method of referencing the target objects is implementation dependent and is not specified in this document.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7  Overview of RaP\n\n7.1  The RaP specification is focused on the definition, management, and transfer of equipment recipes.  In RaP, the recipe components are called ProcessDefinitionElements or $P D E s$ .  This section describes the high level view of the concepts and the requirements that contribute to meet the purpose of this specification as described in $\\ S 1$ .  \n7.2  This RaP overview makes reference to requirements defined later in the document.  However, no statement in this overview section defines a requirement.  This overview is intended to provide a general understanding of the RaP concepts so that the detailed requirements that follow can be more easily understood.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.3  RaP Participants\n\n7.4  RaP assumes that there are three participants in the management of recipes – the FICS, the Equipment, and the PDEeditor.  When these provide RaP services, they become “RaPnodes” – the FICS becomes an FICSnode, the Equipment becomes an EquipmentNode, and the PDEeditor becomes an EditorNode.  \n7.5  These three participants must work together to achieve the goals of recipe management.  They may exist as independent entities using defined message services (RaPnodes) or may be combined in some cases (as the editor is often integrated into the equipment).  Since integrated modules need no standardized communications, RaP defines the services and data needed for these participants to exist independently as shown in Figure 2.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.6  RaP Environment\n\n7.6.1  In discussing recipe management, one can divide the topic into three logically separate activities:  \nExecution of recipes Creation and editing of recipes Tracking and storage of recipes  \n7.6.2  RaP does not specify exactly how to perform any of these three activities.  However, these activities define the context in which RaP defined services and concepts are to be applied.  The recipes themselves must reflect certain aspects of these activities.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.7  Execution of Recipes (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.7  Execution of Recipes\n\nContent: 7.7.1 When an activity is performed on an equipment, that activity must be fully specified in order for execution to occur. RaP describes the main specification (recipe) and also parameters that can be set to amend the recipe. It does not define the process for execution of the recipe. $7 . 7 . 2 \\mathrm { R a P }$ assumes that the equipment or some component of the equipment represents the target for the execution of a recipe. In this document, that target is referred to as a Process Module. RaP assumes that there is a way to identify a Process Module and that certain characteristics of that Process Module are known to the factory (make, model, supplier, etc.). $7 . 7 . 3 ~ \\mathrm { R a P }$ is compatible with SEMI E120. In terms of SEMI E120, the Process Module corresponds to the “AbstractModule” class. The AbstractModule class models parts of the equipment structure capable of processing material. Its attributes include “recipeType” which specifies the type of recipes that the AbstractModule can execute. These\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.7  Execution of Recipes (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.7  Execution of Recipes\n\nContent: are the recipes that RaP proposes to manage. RaP does not require use of or compliance with SEMI E120. However, if SEMI E120 compliance exists, then the source EquipmentElement of much of the RaP related data (both input and output) would be more explicitly identified. 7.7.4 From the FICS point of view, enough must be known about the recipe so that it can select the correct one for each situation (combination of machine, substrate, process step, etc.).\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.8  Creation and Editing of Recipes\n\n7.8.1  RaP considers creation and editing of recipes to be an independent concept.  This means that the editing capability can reside on the equipment, within the factory system, as a separate entity independent of both, or in combinations of all of these.  There are advantages and disadvantages to each and these will change over time. Therefore, RaP makes no requirement on where the PDEeditor must reside.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.9  Tracking and Storage of Recipes\n\n7.9.1  Storage of at least some recipes on the equipment is necessary to support processing.  Storage of recipes at the PDEeditor is also necessary, for example, to support creation of multi-part recipes.  Most factories would also be expected to store a copy of most recipes for safekeeping.  So all participants in recipe management might reasonably be expected to store at least some recipes.  \n7.9.2  RaP also makes available characteristics of the recipes that support tracking and validation (id, checksum, creation date, etc.).\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.10  Communication Overview\n\n7.10.1  RaP is focused on the communications among the three “RaPnodes” defined above:  FICSnode, EquipmentNode, and EditorNode.  There are three types of functions that can be performed via a RaP interface:  \n• Transfer PDEs — request PDEs from or send PDEs to a node.\n• Manage PDEs — obtain information about the PDEs on a node and delete them when desired.\n• Verify — determine which PDEs are needed for a job and check that all are present and well-formed.  \n7.10.2  These three categories represent the eight services defined by RaP.  Detailed definition of the communication services is provided in $\\ P 8 . 4$ .  That section also defines which RaPnodes must support which of these functions. $\\ P 8 . 5$ defines additional requirements on the RaPnodes.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.11  Key Recipe Concepts\n\n7.11.1  In order to fulfill its purpose, RaP must provide more than simple recipe transfer services.  This section describes key concepts used in this specification to enhance the basic functions above to yield a robust “Recipe and Parameter Management” capability.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12  ProcessDefinitionElement\n\n7.12.1  A recipe can be a single component or it can be made up of multiple components.  The components of a recipe are called ProcessDefinitionElements or PDEs.  The $P D E$ is the central artifact of RaP.  This section describes the PDE.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.1.1  PDE –Two Parts (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.1.1  PDE –Two Parts\n\nContent: 7.12.1.1.1 One barrier to automation of recipe handling is the opaque nature of the contents. For several reasons, suppliers have been reluctant to allow the user (and thus the automation system) visibility to the recipe contents. RaP addresses that problem by dividing the recipe component (or now, PDE) into two parts: documentation and executable. This is illustrated in Figure 3. 7.12.1.1.2 The documentation part of the PDE includes the PDEheader. This part is always public and available to the user. The PDEheader contains such information as the name, description, and author of the $P D E$ as well as its antecedents (PDEs upon which this one was based) and the Process Module(s) for which it is intended. More detail about the PDEheader content can be found in $\\ P 8 . 3 . 2$ . 7.12.1.1.3 The second part of the $P D E$ contains the settings and executable instructions. The format of the PDEbody is not specified and is allowed to be private (that is, proprietary and opaque). Note that during job execution, the\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.1.1  PDE –Two Parts (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.1.1  PDE –Two Parts\n\nContent: equipment relies upon the content of the PDEbody, not the PDEheader.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.1.2  Assuring Identity\n\n7.12.1.2.1  An important aspect of the PDEheader information is that it can provide assurance that this $P D E$ is exactly the one that the factory expects it to be.  This is done primarily with two data values:  uid and checksum. The uid is a universally unique identifier that contains a uuid value as defined in the referenced ISO standard (see $\\ P ( . 2 )$ . Each time a $P D E$ is modified, the uid of that $P D E$ is required to be changed.  Therefore, if the uid is matched, the $P D E$ is guaranteed to be the expected one.  \n7.12.1.2.2  There are checksum values provided for the $P D E$ as an additional assurance that no changes to the PDE have occurred.  The checksum for a given item is calculated using the MD5 technique defined by the IETF (see $\\ S 1 0 )$ .  This computed value could be compared with the previously calculated value stored within the $P D E$ to ensure that no changes have been made.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.1.3  Separate PDEbody\n\n7.12.1.3.1  When the PDEbody is contained within the PDE, it is of the same format5 as the PDEheader and its contents are typically comprehensible to the user.  When the PDEbody is opaque to the user or of a format that is not compatible with the header information, that PDEbody is stored separately from the PDE.  This is illustrated in Figure 4.  In this case, the separate PDEbody has its checksum stored in the $P D E$ .  \n7.12.1.3.2  Tracking of separate PDEbodies requires some care by the FICS, because the identity cannot be obtained from the PDEbody itself.  Thus, a method for maintaining the relationship of the $P D E$ to its body must be employed by the FICS.  \n7.12.1.3.3  The Equipment and PDEeditor can interpret the PDEbody contents, and so are able to resolve the relationship without such careful tracking.  The PDEbody must include key information, such as the uid, that enables the equipment and the PDEeditor to make the association between PDEheader and PDEbody (see $\\$ 123,45$ ).\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.1.4  Input Parameters\n\n7.12.1.4.1  The PDEbody may also define input parameters that can be set at run-time.  The PDEheader documents these PDEparameters.  Parameterization is discussed further in ${ \\ P } \\mathrm { { . } } 1 2 . 3$ .\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.1.5  Reference To Other PDEs\n\n7.12.1.5.1  The PDE may need to access other PDEs during execution (for example, a subroutine call).  The PDEheader documents these references.  There are two ways to reference a $P D E$ .  The first is by a unique identifier (uid).  The uid is a reference to a specific PDE.  The second way to reference is by a group identifier (gid).  PDEs in a group can be substituted for one another and so must share the same set of input parameters.  This type of reference is resolved to a specific member of the group before execution.  See $\\Vert 7 . 1 2 . 2 . 5 \\$ for more on how references are resolved.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.1.6  Transition To RaP (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.1.6  Transition To RaP\n\nContent: 7.12.1.6.1 The approach for defining the $P D E$ provides a good transition path from traditional proprietary recipes. Old style recipes can become the PDEbody when RaP is applied. Since the “PDEbody” can be a separate entity (in the case of proprietary content), there should be many cases where little or no modification of the original recipes will be needed. The PDE construct, including the PDEheader, acts as a wrapper. 7.12.1.6.2 There are two areas where RaP requirements may result in changes to an existing recipe structure. The first area is the requirement that an EquipmentNode be able to match a PDEheader with its external PDEbody. This would be done best by inserting the uid value into the PDEbody. However, there is a “bodyChecksum” value in the PDEheader that can be used without changing the PDEbody. This would require recalculating the checksum of the PDEbody, however. The second area is the requirement that the user be allowed to specify which PDEparameters exist. The PDEbody must contain information\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.1.6  Transition To RaP (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.1.6  Transition To RaP\n\nContent: about the user-specified PDEparameters. However, in the case of an existing recipe with no user-specified PDEparameters, no change is necessary until the user edits the PDE to add such parameters. For example, the implementer may choose to support the old recipe format for existing recipes, but convert all new recipes to a new format that includes PDEparameter support.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.2  Recipe Structure (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.2  Recipe Structure\n\nContent: 7.12.2.1 When a recipe has multiple components, RaP documents the relationships among these components (see $\\ P 7 . 1 2 . 1 . 5 )$ . This results in a hierarchical recipe structure as illustrated in Figure 5. 7.12.2.2 The recipe hierarchy must have a single $P D E$ at the apex. This PDE is called the “Master PDE”. It is this $P D E$ that will be referenced when a job is specified. So, for example, in SEMI E40/Processing Management, the RecID (or RCPSPEC) will contain the uid of the Master PDE. See Related Information $\\ S _ { \\mathbf { R } 2 - 2 }$ for more discussion of RaP support for SEMI E40 and SEMI E30. As an alternative, a gid may be supplied and later resolved to a uid. 7.12.2.3 The recipe structure implies that the Master PDE is the first $P D E$ to be executed. Beyond the Master PDE, the recipe structure does not document the order of execution of $P D E s$ or the flow path of wafers through equipment. It is recommended that the equipment supplier provide a $P D E$ that contains this flow information in an\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.2  Recipe Structure (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.2  Recipe Structure\n\nContent: open format (human readable) PDEbody. 7.12.2.3.1 Here are a few other items of note: • The Master PDE is a designation, not a type of PDE. A Master PDE must be marked as “executable” (see Table 5). • There is no restriction on multiple references to the same PDE. The number of levels in the recipe hierarchy is not limited. However, it is to be expected that two to three levels would be sufficient in most cases. In the case where the Master PDE contains the entire recipe, only one level is needed. A PDE may appear in the hierarchy of multiple recipes. Such reuse of recipe components is expected and encouraged.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.2.4  Recipe Maintenance Considerations (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.2.4  Recipe Maintenance Considerations\n\nContent: 7.12.2.4.1 Group IDs (gids) exist to make it easier to maintain multi-part recipes. It is possible to create recipes where all $P D E$ references are done with uids. However, this can lead to problems when a change is made to one of the components. 7.12.2.4.2 Remember that when any change is made to a $P D E$ , it must become a new $P D E$ with a new uid. In order to begin using this “new version” of the old $P D E$ , some (or all) $P D E s$ that referenced the original $P D E$ must now reference the new one. When the referencing $P D E s$ are changed to refer to the new version, each of them becomes a new $P D E$ . And these have the same problem with any $P D E s$ that reference them. The problem cascades to every level above the first $P D E$ . 7.12.2.4.3 Any PDE reference that contains a gid can be satisfied with any member of that group. When a $P D E$ is changed, it can keep the same gid, even as the uid changes. Therefore, the PDEs that reference the original $P D E$ do not need to change.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.2.4  Recipe Maintenance Considerations (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.2.4  Recipe Maintenance Considerations\n\nContent: This solves the problem of cascading references. 7.12.2.4.4 Use of gids as PDE references does add a burden, however. At some point, the gid must be resolved.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.2.5  Resolving PDE References (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.2.5  Resolving PDE References\n\nContent: 7.12.2.5.1 ¶7.12.1.5.1 discussed the fact that $P D E$ references can be either uids or gids. When gids are used as references, they must be resolved to uids before the referenced $P D E$ can be executed. Resolution must occur one level at a time beginning with the Master PDE. Only when the specific $P D E ( \\mathrm { { s } ) }$ referenced by the current level are known can one know the references these $P D E s$ make to the next lower level. 7.12.2.5.2 Resolution of a gid to a uid can be performed by either the equipment or the client of the equipment. If configured to do so, the equipment will resolve any gids that the client does not. If the equipment is required to resolve a gid, it will choose the member of that group currently at the equipment that has the newest createDate. 7.12.2.5.3 The client can specify gid resolutions for a specific processing job through a predefined Variable Parameter as input to the job. In this “PDEmap” parameter, the client provides a list of gids with the corresponding uid\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.2.5  Resolving PDE References (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.2.5  Resolving PDE References\n\nContent: for each. The equipment will then preferentially use the entries in this list as it resolves the recipe. If during the resolution process the equipment encounters any gids that are not on the PDEmap, then it will attempt to resolve the gid as mentioned above. If the client does not supply a PDEmap, the equipment will resolve all gids it encounters. Allowing the equipment to select the final PDEs without supervision is not advised. 7.12.2.5.4 The client can interact with the equipment to determine the best PDEmap values. Using the resolvePDE() service, the client can supply a $P D E$ and receive the corresponding (fully resolved) “outputMap” from the equipment. The outputMap contains a list of the gid – uid pairs that result from the resolution process – the equivalent of a PDEmap. If desired, the client can supply an “inputMap” listing some gid – uid pairs and the equipment will use these preferentially as it resolves the outputMap. See the scenarios defined in Related Information 1 for examples of this\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.2.5  Resolving PDE References (Part 3)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.2.5  Resolving PDE References\n\nContent: interaction.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.3  Parameterization (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.3  Parameterization\n\nContent: 7.12.3.1 Parameterization of process jobs is an important concept for process control. There are other SEMI standards that define how parameters can be passed to the equipment to affect processing (for example, see SEMI E40 and SEMI E30). RaP supports the definition of those parameters. Figure 6 illustrates the flow of parameters in a RaP recipe. $7 . 1 2 . 3 . 2 \\mathrm { R a P }$ assumes that recipes are executed as part of a larger job specification. When the “Process Job” is to be executed, settings can be passed to the job to complete its specification. In RaP, these settings are called Variable Parameters. Figure 6 shows Variable Parameters passed to the Process Job. 7.12.3.3 The Process Job references the Master PDE as the process recipe. During execution of the Process Job, the equipment passes Variable Parameter values to the Master PDE to satisfy its PDEparameters. 7.12.3.4 The Master PDE and each successive level of PDEs coordinate the activity of the PDEs at the next lower level. Each PDE is responsible\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.3  Parameterization (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.3  Parameterization\n\nContent: for passing values to its referenced PDEs to satisfy their PDEparameters. 7.12.3.5 Each PDE can also directly set “Module Parameters”, the settings that affect the Process Module (or other equipment components). Each Process Module offers a fixed set of these input parameters that can be set from within a recipe. Note that Module Parameters are not formally defined by RaP. They are used to represent internal equipment settings that recipes need to manipulate. 7.12.3.6 For a particular $P D E$ , an incoming PDEparameter value may affect an outgoing setting of another PDEs PDEparameter or of a Module Parameter. This affect may be direct, where the incoming value is used as the outgoing value, or it may be indirect, where some sort of transformation is done to the incoming setting to determine the outgoing values. An example of an indirect affect is a time setting that is consumed within the $P D E$ and is used to determine when a particular Module Parameter is to be set. 7.12.3.7 Notice that a $P D E$ can set Module\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.3  Parameterization (Part 3)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.3  Parameterization\n\nContent: Parameters to different values during processing according to need. For example, a process chamber might have a “ChamberTemperatureSetpoint” Module Parameter. A $P D E$ might require that the value for this be $4 5 0 ^ { \\circ } \\mathrm { C }$ for the first stage of the process and $5 0 0 ^ { \\circ } \\mathrm { C }$ for the second stage. The $P D E$ could set these values directly at the proper time. However, an alternative would be to define two PDEparameters for this purpose: FirstStageTemp and SecondStageTemp. Each would map to ChamberTemperatureSetpoint and their default values could be set to the corresponding values. Then, when the appropriate first stage temperature is determined to be $4 3 0 ^ { \\circ } \\mathrm { C }$ , the change can be made through a parameter setting at runtime without changing the $P D E$ . In this way, multiple PDEparameters might map to the same Module Parameter.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.4  TransferContainer (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.4  TransferContainer\n\nContent: 7.12.4.1 $\\ P 7 . 1 0$ mentions the transfer of PDEs. RaP provides for the definition of a process activity to span multiple, inter-related $P D E s$ . To promote efficiency of messaging and organization of these PDEs, RaP defines the TransferContainer. A TransferContainer bundles together multiple PDEs for transfer. 7.12.4.2 A TransferContainer contains PDEs, PDEbodies, and a Manifest. It is convenient to conceptualize the TransferContainer as an archive file (for instance, a compressed “zip” file for efficient transfer) and the $P D E$ and PDEbodies as files contained within. 7.12.4.3 There is no requirement that the PDEs contained in a TransferContainer be related in any way. Nor is there any requirement that all PDEs required for a particular equipment activity to be transferred together. However, RaP does insist that an external PDEbody always be accompanied by its PDE (and thus, its PDEheader). 7.12.4.4 The Manifest lists which PDEs are included in the TransferContainer and associates each $P D E$ with its\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.4  TransferContainer (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.4  TransferContainer\n\nContent: external PDEbody (if one exists). The Manifest can also specify a storage location on the equipment for each recipe (for example a directory). 7.12.4.5 More detail is provided in ¶8.4.2.13. 7.13 Realizing the Purpose 7.13.1 The purpose of RaP was discussed in $\\ S 1$ . In that section, six primary elements of the purpose were provided. This section will review these six elements and show how each is satisfied by the concepts defined in $\\ S 7$ . On-tool & Off-tool Recipe Management — RaP provides the ability to uniquely identify each $P D E$ . This is done independently of the versioning systems that may be used by the host or equipment recipe managers. Ontool management information is embedded in the $P D E$ header (version, antecedent, etc.), but the host may choose to ignore this information and follow its own management procedures. Few requirements are placed on the host or equipment with regard to how management of $P D E s$ is to be done. Recipe Integrity — To guarantee integrity of the recipes, it must be\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.4  TransferContainer (Part 3)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.4  TransferContainer\n\nContent: possible to uniquely identify each $P D E$ and recognize that any change makes it a different $P D E$ . The unique identification requirement is satisfied by the definition of a unique identifier (uid) containing a uuid value and by the requirement to change the uid with any change to the PDE. Checksums provide added certainty that no change was made. Process Integrity — RaP addresses this requirement by making all Module Parameters available for setting by a PDE, either directly or as input parameters to be supplied at execution time. RaP cannot guarantee that all possible parameters have been made available to the $P D E s$ . This is left to the supplier and user communities to ensure. Adjustable Parameter Definition — RaP provides a flexible system for defining parameters for process jobs in a way that is compatible with SEMI standards (for example SEMI E40). See ¶7.12.3. On-tool & Off-tool Recipe Creation & Editing — RaP requires that recipe creation and editing capability exist. It defines the interfaces\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.4  TransferContainer (Part 4)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 7.12.4  TransferContainer\n\nContent: necessary to standardize communication with an off-tool editor. RaP does not require an off-tool editor. Information Accessibility — The PDEheader contains a large amount of user-accessible information about individual PDEs and how they relate to one another.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8  Requirements\n\n8.1  Requirements Overview  \n8.1.1  This section contains all of the requirements specified by RaP.  This is divided into three parts.  \nThe first is the Recipe Object Model, which describes the data content of the recipe components.\n• The second part is RaP Services, which defines the communications between participants in recipe management. The third part is RaPnode Requirements and Clarifications, which defines the responsibilities of each recipe management participant.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.2  Recipe Object Model (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.2  Recipe Object Model\n\nContent: 8.2.1 RaP recipes consist of a hierarchy of recipe components. Each recipe component is a PDE. In this hierarchy, each $P D E$ may use other $P D E s$ in order to do its job. Note that a $P D E$ may appear multiple times in the hierarchy. Each appearance represents a different use of this $P D E$ . 8.2.2 At the apex of the hierarchy is a single $P D E$ that represents the entire recipe . This topmost $P D E$ is referred to as the “Master $P D E ^ { , }$ . The only additional RaP requirement on a PDE in order to serve as a Master PDE is that it shall have its “executable” attribute set to “True” (see Table 5). 8.2.3 The Recipe Object Model specifies the requirements that RaP places on the content of PDEs. These PDEs are the subject of the RaP Services (see $\\ P 8 . 4 )$ . Certain information about PDEs can be accessed directly by $P D E$ services (for example, see getPDEdirectory()). That information is also defined in the Recipe Object Model. 8.2.4 The Recipe Object Model specifically applies to the form of the PDEs\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.2  Recipe Object Model (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.2  Recipe Object Model\n\nContent: during transfer. RaP does not place any requirements on the stored form of any $P D E$ so long as the meaning of the $P D E$ is not lost and the exact transfer form can be reconstructed for later transfer.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3  PDE Class Diagram\n\n8.3.1  The $P D E$ Class Diagram (Figure 7) represents the information contained in the $P D E$ .  In addition to the executable instructions, the $P D E$ provides a public description of itself.  This provides accessibility to the user of key information about the $P D E$ , while allowing the equipment supplier to protect the integrity and any proprietary value of the actual processing instructions.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3.1.1  PDE Class\n\n8.3.1.1.1  The $P D E$ includes a PDEheader that describes the $P D E$ and a PDEbody that contains the executable instructions.  The PDEheader stores key information about the $P D E$ , its purpose, its history, etc.  \n8.3.1.1.2  The PDEbody may be internal to the PDE (as represented by the PDEbody class) or external (as represented by the PDEbodyReference class).  The PDEbody shall be internal to the $P D E$ only if its format corresponds to the same formatting rules as the PDEheader.  The formatting rules are defined in one or more subordinate specifications of this document.  \n8.3.1.1.3  PDEs have no state.  Therefore, there are no events defined for reporting the state change of a $P D E$ However, see $\\$ 123.5.4.7$ for a discussion of events relating to changes in an equipment’s recipe collection.  \nTable 3  PDE Class Attributes  \nTable 4  Navigable Associations for PDE\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3.2  PDEheader Class (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3.2  PDEheader Class\n\nContent: 8.3.2.1 The PDEheader documents the contents of the PDEbody. A PDEheader contains no executable instructions, but simply reflects the executable instructions contained by the PDEbody as well as key context and descriptive information. 8.3.2.2 A PDEheader shall be created by the PDEeditor each time a PDE is produced. The PDEheader and PDEbody are a matched pair and shall not be modified independently. 8.3.2.3 The PDEheader attributes are defined in Table 5. In addition, the PDEheader is composed of a list of AntecedentData, ReferencedPDEs, PDEparameters, and ExecutionTargets. These associations are described in Table 5 and the associated classes are described below. Table 5 PDEheader Class Attributes 8.3.2.4 A gid is used to identify PDEs that are substitutable for one another. In addition to sharing the same groupName and gid, the following shall be true for all PDEs in the same group: • They shall have the same set of PDEparameters. The existence of PDEparameter default values shall be the same (the actual default\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3.2  PDEheader Class (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3.2  PDEheader Class\n\nContent: values may differ). Table 6 Navigable Associations for PDEheader 8.3.2.5 Multiple ExecutionTarget objects are defined when multiple sets of criteria are acceptable. For example, two similar models of an equipment might be able to run the same recipe.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3.3  AntecedentData Class\n\n8.3.3.1  The AntecedentData class documents the predecessors of the current $P D E$ .  When a $P D E$ is created, if a PDE is used as the basis for the new one, the older $P D E$ ’s relevant data is copied into the first AntecedentData instance.  Then the older PDEs AntecedentData is appended to that of the new PDE.  This provides a chronologically ordered sequence of AntecedentData instances.  Since the antecedent PDEs may not be available at a later time, some of their attributes are included in the AntecedentData class.  \n8.3.3.2  Note that portions of multiple PDEs may be used to create the new one.  AntecedentData sequences may branch as they move back in time.  \n8.3.3.3  The user may limit the number of AntecedentData instances by setting the maxAntecedents attribute of the PDE.  This leaves only the most recent entries in each branch of AntecedentData.  See Table 7 for more on maxAntecedents.  \nTable 7  AntecedentData Class Attributes  \nTable 8  Navigable Associations for AntecedentData\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3.4  ReferencedPDE Class\n\n8.3.4.1  This class contains a reference to a PDE that is needed by the current $P D E$ to complete its task.  At any point in the structure of a recipe, the set of ReferencedPDEs provides the identities of the $P D E s$ at the next lower level.  \n8.3.4.2  The value of the id attribute can be either a uid or gid.  Since all UUID type values are universally unique, there is no conflict.  If the id contains a uid value, the reference is explicit and no further work is needed.  If the id contains a gid value, then it will be resolved to a uid at a later time (see $\\ P { \\mathrm { 8 } } . 5 . 1 . 3$ for more detail).  \n8.3.4.3  A PDE shall ensure that the PDEparameters of all of its ReferencedPDEs are satisfied, by either providing a value or allowing the default to be used (if one exists).\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3.5  ExecutionTarget Class\n\n8.3.5.1  ExecutionTarget describes the Process Module(s) on which this $P D E$ can be executed.  The supplier, make, model, and recipeTypes attributes define the type of Process Module that can execute this $P D E$ .  Based on the definition of these attributes, an ExecutionTarget may represent a general set of acceptable Process Modules.  If the identifier attribute is also be specified, the ExecutionTarget is limited to one specific unit.  The PDEeditor shall ensure that the ExecutionTarget definition shall describe only equipment that are able to execute this $P D E$ .  \n8.3.5.2  A PDE’s ExecutionTarget instances should correspond to its scope of execution.  A Master PDE’s scope would typically be the equipment.  \n8.3.5.3  An equipment can contain multiple Process Modules that match ExecutionTarget definitions for a PDE.  In this case, the equipment, with possible guidance from the recipe, shall select which to use during processing.  \nTable 10  ExecutionTarget Class Attributes\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3.6  PDEparameter Class (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3.6  PDEparameter Class\n\nContent: 8.3.6.1 PDEparameters are inputs to a $P D E$ that help determine how it will perform its task. PDEparameter input values are supplied by the next higher level of the recipe hierarchy. For the Master $P D E$ , they are supplied by the equipment itself (as it executes the job/recipe). For all other PDEs, the PDEparameter values shall be supplied by the referencing $P D E$ . 8.3.6.2 The group of $P D E s$ that make up a recipe are responsible for satisfying all the settings (or Module Parameters) and any other conditions required to perform the defined activity. These Module Parameters can be set by $P D E s$ at any level in the hierarchy. The value of a PDEparameter may affect the eventual value of one or more Module Parameters. The PDE may set the Module Parameters directly or it may set a PDEparameter that will affect the value of a Module Parameter. In either case, the affected Module Parameters are considered relatedParameters. 8.3.6.3 A PDE may set a Module Parameter to different values at different times during\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3.6  PDEparameter Class (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3.6  PDEparameter Class\n\nContent: execution. In this case, there may be multiple input PDEparameters that affect the same Module Parameter. Table 11 PDEparameter Class Attributes 8.3.6.4 The name of the PDEparameter shall be unique within the scope of the $P D E$ . Also, the name of the Module Parameters shall be unique within the scope of a Process Module. 8.3.6.5 In the case where a PDEparameter maps directly to another (lower level) PDEparameter, the inputBounds defined shall be the same or more restrictive than those for the corresponding lower level PDEparameter. If no inputBounds are defined, then those for the corresponding lower level PDEparameter shall be used (if any are defined). 8.3.6.6 This specification does not define how or when the inputBounds are enforced. This is an issue of recipe execution and is out of scope for this specification.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3.7  PDEbody Class\n\n8.3.7.1  The PDEbody contains settings and/or executable instructions required by the equipment to perform a run. It may be internal to the PDE (represented as PDEbody class) or external to the PDE (represented as PDEbodyReference).  This section defines the former.  \n8.3.7.2  The PDEbody class is used when the content of the PDE instructions is visible to the user.  No attributes or associations are defined for the PDEbody.  The implementer is expected to create a subclass of PDEbody that represents the content of their specific PDEbody.  The format of the PDEbody must follow the same formatting rules as for the PDEheader.  These rules are defined in one or more subordinate specifications attached to this document.  \nTable 12  PDEbody Class Attributes\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.3.8  PDEbodyReference Class\n\n8.3.8.1  When the PDEbody format does not correspond to the same formatting rules (as defined on one or more subordinate specifications attached to this one) as the PDEheader, it is stored separate from rest of the $P D E$ .  In this case, the PDE has a PDEbodyReference to identify that separate PDEbody.  \nTable 13  PDEbodyReference Class Attributes\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4  RaP Services\n\n8.4.1  The purpose of this section is to define the message services required to support RAP functionality.  Providers of RaP services are called RaPnodes.  This section will define the different kinds of RaPnode and then define the services provided by each.  \n8.4.2  All RaP services are based on request/response semantics.  Any service may be requested at any time.  There are no state models associated with RaPnodes.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.1  RaPnodes (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.1  RaPnodes\n\nContent: 8.4.2.1.1 RaP defines RaPnodes as the providers of RaP services. There are three types of RaPnodes EquipmentNodes, FICSnodes, and EditorNodes. • EquipmentNode — The EquipmentNode provides RaP Services for accessing the equipment. • FICSnode — The FICSnode provides RaP Services for accessing the Factory Information and Control System (FICS). EditorNode — The EditorNode provides RaP Services for accessing the PDEeditor. 8.4.2.1.2 Figure 8 is a UML class diagram illustrating the relationships of the RaPnodes. As the diagram shows, there are some services that are common to all RaPnodes. Other services are unique to certain types of RaPnodes. This is more fully specified in Table 14 below. 8.4.2.1.3 The clients of RaP services can be any entity with communication access to a RaPnode. If the client for RaP services is also a RaPnode, then more robust interactions are possible with messages initiated from both RaPnodes. For more discussion on communication scenarios, see Related Information. 8.4.2.1.4 The class diagram also\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.1  RaPnodes (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.1  RaPnodes\n\nContent: identifies the nodeID attribute (see Table 14). All RaPnodes shall define a nodeID that can be used for identification in communications. The nodeID is referenced by the createNode attribute of the PDEheader class. Table 14 RaPnode Class Attributes\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.2  Required Services Per Node\n\n8.4.2.2.1  As discussed in $\\ S 2$ , RaP defines services that apply to three different communication nodes:  the FICS, the Equipment, and the PDEeditor.  Each of those nodes is required to provide certain services to be compliant to RaP. Table 15, Service Descriptions, describes each service defined by RaP and which node must provide that service. This listing corresponds to the services listed in Figure 8.  \n8.4.2.2.2  The Service Descriptions table has six columns:  \nThe first column lists the services. The second column defines the type of service.  This may be a request/response message pair (denoted by “R”) or a notification message (denoted by “N”). • The third column is a textual description of the service. Columns 4–6 each represent a RaP communication node.  For each service, a checked box in this column indicates that the node is required to provide this service.  An empty box indicates that the service shall not be provided.  \nTable 15  Service Descriptions\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.3  Service Message Parameters\n\n8.4.2.3.1  The following service parameter dictionary (Table 16) defines the name, description, and format for parameters used by RaP services.  The format column uses data types defined in $\\yen 123,456,7$ .\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.4  Service Message Definitions\n\n8.4.2.4.1  This section specifies the allowable/required parameters for each service.  Table 17 shows the format of the Service Parameters tables used for this purpose.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # Table 17  Service Parameters\n\n8.4.2.4.2  Each service has an initial message (Request to the sender, Indicator to the receiver, hence Req/Ind). Services that are “Request/Response” have a return message (Response to the sender, Confirmation to the receiver, hence $\\mathrm { R s p / C n f ) }$ .  The Req/Ind and Rsp/Cnf columns indicate in which message each parameter is to be included. The codes from Table 18 are used in these columns to give further information.  \nTable 18  Req/Ind and Rsp/Cnf  Codes\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.5  getPDEdirectory()\n\n8.4.2.5.1  The getPDEdirectory() service is used by the FICS to request a list of $P D E s$ maintained by the service provider. The requestor may supply a filter that will yield a subset of the full list of $P D E s$ .  A subset of the PDEheader’s attributes can be reported for each returned PDE if desired.  \n8.4.2.5.2  When multiple PDEFilters are specified, these filters are to be AND’ed together.  That is, each filter is applied in turn with the reduced list that is output from one becoming the input for the next.  Note that no PDEDirItems are returned when no PDE’s are found that pass the filters.  \n8.4.2.5.3  The requestor may choose not to include PDEFilters or PDEAttributes in the request.  \nTable 19  getPDEdirectory() Service Parameters\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.6  deletePDE()\n\n8.4.2.6.1  The deletePDE() service is used by the FICS to request that specified PDEs be deleted from the service provider.  The request includes a list of the $P D E s$ to be deleted.  The requestor may wish to first use the getPDEdirectory() service to obtain a list of the available PDEs.  \n8.4.2.6.2  The delRspInfo lists any errors encountered by the service provider in the completion of the deletePDE() request.  All PDEs not referenced by delRspInfo shall be deleted.  \n8.4.2.6.3  If the list of uid contains multiple references to the same PDE, the RapNode shall delete the $P D E$ and provide a successful response.  \nTable 20  deletePDE() Service Parameters  \n8.4.2.6.4  RaP allows deletion of a $P D E$ , even if it is referenced by another $P D E$ .  The user should be aware that deletion of PDEs may make execution of one or more Master PDEs impossible due to unsatisfied references.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.7  getPDEheader() (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.7  getPDEheader()\n\nContent: 8.4.2.7.1 The getPDEheader() service is used to request that the headers of one or more $P D E s$ be returned from the service provider. Prior to sending a response, the service provider shall be responsible for locating the PDEs requested, extracting the headers, packaging them in a TransferContainer, and generating a tcid for the TransferContainer. 8.4.2.7.2 When reported separately from its PDEbody, a PDEheader serves only a documentation role and is not usable as part of a recipe. The PDEbody is never transferred separately from its PDEheader. 8.4.2.7.3 The getRespInfo parameter contains information about any errors that occur. If errors are encountered, then the TransferContainer shall contain all requested PDEheaders for which no error is reported. 8.4.2.7.4 If the list of uids contains duplicate entries, the RapNode shall combine these requests and (in the absence of other problems) return only one copy of the requested PDEheader. The returned getRspStat value for each original request shall reflect the status\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.7  getPDEheader() (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.7  getPDEheader()\n\nContent: of the combined request (that is, “OK” if one copy is returned). Table 21 getPDEheader() Service Parameters\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.8  getPDE()\n\n8.4.2.8.1  The $g e t P D E ( )$ service is used to request that one or more $P D E s$ be returned from the service provider. Prior to sending a response, the service provider shall be responsible for locating the PDEs requested, packaging them in a TransferContainer, and generating a uuid for the TransferContainer.  \n8.4.2.8.2  The getRespInfo parameter contains information about any errors that occur.  If errors are encountered, then the TransferContainer shall contain all requested PDEs for which no error is reported.  \n8.4.2.8.3  If the list of uids contains duplicate entries, the RapNode shall combine these requests and (in the absence of other problems) return only one copy of the requested $P D E$ .”  The returned getRspStat value for each original request shall reflect the status of the combined request (that is, “OK” if one copy is returned).\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.9  requestToSendPDE()\n\n8.4.2.9.1  Request for permission to send a TransferContainer containing $P D E s$ to the service provider.  The size of the proposed TransferContainer is provided so that the service provider can ensure that room is available.  \n8.4.2.9.2  The response to the request is contained in the rtsRspStat.  If the returned value is “OK”, the service provider is indicating that the proposed sendPDE() service should succeed.  The requestToSendPDE() service shall not be required to be send prior to the sendPDE() service.  It provides an opportunity to check on a proposed transfer before that transfer is attempted.  \n8.4.2.9.3  The tcid appears in both the requestToSendPDE() and sendPDE() services.  This provides a way for the RaPnode to match a received TransferContainer with the earlier requestToSendPDE() message.  \nTable 23  requestToSendPDE() Service Parameters\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.10  sendPDE()\n\n8.4.2.10.1  The sendPDE() service is used to transfer PDEs contained in a TransferContainer to the service provider.  Any response other than success (“OK”) shall be considered an indication that the recipe was not accepted.  If a duplicate $P D E$ is contained in the TransferContainer, the service provider shall store one and discard the other.  This shall not be considered an error.  If a $P D E$ in the TransferContainer is already stored on the service provider, the newly received $P D E$ shall overwrite the existing one.  \n8.4.2.10.2  Refer to $\\$ 1.3$ for requirements related to PDE transfer that apply to EquipmentNodes.  \nTable 24  sendPDE() Service Parameters\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.11  resolvePDE() (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.11  resolvePDE()\n\nContent: 8.4.2.11.1 In the recipe hierarchy, each reference of a $P D E$ is either a uid or a gid value. All gids must be resolved to uids before a recipe can be executed. The EquipmentNode is responsible for the final resolution of any gids not resolved by the client (see $\\ P 8 . 5 . 4 )$ . The resolvePDE() service is a request for the EquipmentNode to provide the resolution of all gids in a hierarchy. The EquipmentNode shall resolve the recipe hierarchy exactly the same as if the recipe was to be executed at the time of the resolvePDE() request. 8.4.2.11.2 The structure of a recipe can be determined by successively resolving the ReferencedPDEs at a level of the hierarchy and then moving downward to the next level. Note that the resolution of a gid at one level will affect the recipe structure at the next level down. The response to the resolvePDE() service shall comprehend the entire hierarchy below the targetPDE. 8.4.2.11.3 While the targetPDE will typically be a Master PDE, there is no requirement for this to be the case.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.11  resolvePDE() (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.11  resolvePDE()\n\nContent: This service can be used to resolve a subset of a complete recipe. The targetPDE shall contain a gid or a uid value. 8.4.2.11.4 The inputMap parameter specifies a list of $P D E$ references with the corresponding uid that resolves each. This is a list of client specified resolutions for the gids that may be encountered during the resolution process. If, during this process, the EquipmentNode encounters any of the gids listed in the inputMap, it shall use the corresponding uid from the inputMap in its resolution. This inputMap allows the client to override the normal resolution method by the equipment (see $\\ P [ 8 . 5 . 1 . 3 )$ . 8.4.2.11.5 Some gids listed in the inputMap may not be encountered during the resolution process. This is not considered an error and shall be ignored by the EquipmentNode. If a gid from the inputMap appears in the recipe hierarchy, but the corresponding uid is not available on the equipment, then the EquipmentNode shall note the situation as an error (see resPDEstat) and resolve that gid as\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.11  resolvePDE() (Part 3)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.11  resolvePDE()\n\nContent: if it had not appeared in the inputMap. 8.4.2.11.6 If ResolvePDEreferences is set to false (see $\\ P [ 8 . 5 . 1 . 3 )$ , then only the entries in the inputMap are used to resolve the specified PDE. In this case, if a needed gid reference in the recipe structure is not included in the inputMap, it shall be treated the same as if no member of the group were available in the equipment store of $P D E s$ (resPDEstat $\\ O =$ MissingReferencedPDE).” 8.4.2.11.7 The outputMap parameter lists each PDE reference found during the resolution process and the resolution for each. The targetPDE is a PDE reference and shall be included in the outputMap. The targetPDE may contain a gid value. 8.4.2.11.8 If any gid from the recipe structure cannot be resolved to a uid, that gid shall appear in the outputMap with a zero length string for the corresponding uid. This error shall also be noted in resPDEstat. 8.4.2.11.9 All outputMap values that contain no errors shall be acceptable to the equipment as inputMap or PDEmap values. Table 25\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.11  resolvePDE() (Part 4)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.11  resolvePDE()\n\nContent: resolvePDE() Service Parameters\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.12  verifyPDE() (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.12  verifyPDE()\n\nContent: 8.4.2.12.1 The verifyPDE() service is used to check the validity of a specified PDE. It may be used to check a single $P D E$ or all $P D E s$ that it directly or indirectly references (see verifyDepth). Multiple levels of verification are available (see verifyType). The highest level, “Validity” is dependent on the supplier. The supplier shall document the verification steps it takes when verifyType is set to “Validity”. 8.4.2.12.2 The verification process yields only the current status of a PDE. A successful verification does not guarantee that a later verification (or execution) will succeed. 8.4.2.12.3 Verification results shall be independent of the status of the equipment and its components. For example, if a processing module is out of service, it shall not change the outcome of the verification process. Equipment status is out of scope of this specification. 8.4.2.12.4 When verifyDepth is “All”, the verifyPDE() service must resolve any $P D E$ references that contain gids. The inputMap parameter allows the client\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.12  verifyPDE() (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.12  verifyPDE()\n\nContent: to specify the resolution for some or all of these gids.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.13  TransferContainer (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.13  TransferContainer\n\nContent: 8.4.2.13.1 Some of the RaP services reference a TransferContainer. This section defines the TransferContainer. 8.4.2.13.2 The TransferContainer bundles one or more PDEs together for transfer. This provides messaging efficiency, logical grouping of PDEs where appropriate, and also creates a potential for data compression of the PDEs. 8.4.2.13.3 This specification allows any combination of PDEs to be included in the TransferContainer. They need not be related. However, the user may choose logical groupings. For instance, the FICS may choose to always download Master PDEs and all their related PDEs together. 8.4.2.13.4 The details of data compression are left as an implementation decision. For example, if the implementation chose to represent $P D E s$ as files, it might be logical to implement the TransferContainer in the form of one of the popular file compression formats. 8.4.2.13.5 Figure 9 provides an illustration of a TransferContainer. It contains a set of PDEs, a set of independent PDEbodies (as needed) and a\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.13  TransferContainer (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.13  TransferContainer\n\nContent: Manifest that describes the contained PDEs. 8.4.2.13.6 The $P D E s$ and the PDEbodies are in document form for transfer. The form of these documents is left as an implementation detail. It is assumed that the document form of the $P D E$ will have some sort of descriptor (for example, a filename). 8.4.2.13.7 The Manifest associates the uid of each PDE contained with the descriptor of the document form of that PDE and the descriptor of its corresponding PDEbody (if not contained inside the PDE). It is arranged as a series of entries, each of which contains a single uid, the descriptor of the corresponding $P D E$ , the descriptor of the PDEbody (if applicable), and a Location string. The Location string is not required, but it allows the client to specify where the recipe is to be stored (or the equipment to specify where it had been stored). The format of the Location string is supplier specified. Each of these entries in the Manifest allows the receiver of the Transfer Container to quickly identify the PDE, find\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.13  TransferContainer (Part 3)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.4.2.13  TransferContainer\n\nContent: its corresponding PDEbody, and store it appropriately. See Table 27 for more information on Manifest entry data. Table 27 Manifest Entry Data Definitions 8.4.2.13.8 Manifest and the TransferContainer exist only for the purpose of transfer of $P D E s$ . They are not tracked and cannot be accessed using any RaP defined interfaces outside of the context of the transfer operation for which they are created.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications\n\nContent: 8.5.1 This section defines and clarifies requirements on the RaPnodes. 8.5.2 General RaPnode Requirements And Clarifications 8.5.2.1 A RaPnode is a provider of RaP defined services. Clients of RaP services are not required to be RaPnodes. However, in many cases RaPnodes will be clients of other RaPnodes. 8.5.2.2 Of the three defined RaPnodes, RaP requires only that an EquipmentNode be present and fully support the RaP services defined for it. 8.5.2.2.1 The other two types of RaPnodes may be present and if so, they shall fully support the RaP services defined for them. 8.5.2.3 RaPnodes may be combined into a single node. For example, an EditorNode may be combined with an EquipmentNode. This combined node shall support the superset of capabilities defined for these two types of nodes. 8.5.2.3.1 The combined RaPnode entity is a single node, therefore there is no requirement that RaP services be used internally (for instance, between the internal EditorNode and the internal EquipmentNode capabilities).\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications\n\nContent: 8.5.2.4 When a PDEbody is opaque to the user (for example, of a binary format), it shall be separated from the PDE/PDEheader construct as described in $\\ P 8 . 3 . 7$ . 8.5.2.4.1 When the PDEbody is contained within the $P D E$ , it shall meet the same format requirements as the PDEheader. In this case, its contents shall be comprehensible by the user. 8.5.2.4.2 The format requirements for the $P D E$ are defined in subordinate specifications (sometimes called “do standards”). 8.5.2.5 When a TransferContainer is received, the RapNode shall extract the PDEs and store them in such a way that each PDE can be exactly re-created for later transfer such that the calculated checksum will be correct. 8.5.2.6 RaP does not address and is not affected by internal design decisions for the Equipment, PDEeditor, and FICS. It deals only with communication among the Equipment, the PDEeditor, and the FICS. 8.5.2.6.1 For example, a PDEeditor might provide a “thin client” interface in the form of a web browser-based\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications (Part 3)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications\n\nContent: implementation. RaP does not restrict such designs. In this case, the PDEeditor should still provide a RapNode that complies with this specification. 8.5.2.7 For all checksum values defined by this specification, the MD5 method for computing checksums shall be used. MD5 is defined by the IETF (see the reference in $\\ S 1 0$ ). 8.5.3 FICSnode Requirements And Clarifications 8.5.3.1 The factory environment is not required to provide a FICSnode or the associated services. 8.5.3.1.1 RaP supports a communications structure where all communications between FICS and the Equipment and PDEeditor are initiated by the FICS. 8.5.3.1.2 Improved efficiencies may be possible when other RaPnodes can utilize FICSnode services. RaP supports, but does not require this approach. 8.5.3.2 If an FICSnode is provided, it shall support all the services defined for it as noted in Table 15. 8.5.4 EquipmentNode Requirements And Clarifications 8.5.4.1 The Equipment shall provide a single EquipmentNode that supports all the\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications (Part 4)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications\n\nContent: services defined for it as noted in Table 15. 8.5.4.2 The EquipmentNode shall be able to perform all RaP related activities without the presence of an FICSnode or an EditorNode (that is, where all communications with the EquipmentNode are initiated by the client). 8.5.4.2.1 The EquipmentNode should provide alternate methods of performing these activities that take advantage of the services provided by FICSnodes and/or EditorNodes. 8.5.4.3 The EquipmentNode shall supply values for all PDEparameters of the Master PDE as needed by soliciting these values as input parameters to the definition of processing jobs. 8.5.4.3.1 These input parameters shall have the same name as the corresponding PDEparameters. 8.5.4.4 The equipment supplier shall determine what parameters (that is, Module Parameters) to make available for setting by the PDEs. 8.5.4.4.1 The equipment supplier shall document all Module Parameters. 8.5.4.4.2 The equipment supplier is encouraged to make available all settings that effect the\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications (Part 5)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications\n\nContent: outcome of processing. 8.5.4.4.3 Some settings, such as calibration settings, may not be accessible for setting by the recipe. 8.5.4.4.4 All collections of settings or instructions (scripts, support files, etc.) associated with the processing specification shall be PDEs. 8.5.4.4.4.1 If this $P D E$ contains settings not available for editing by the user (for example, calibration values), the equipment/PDEeditor may place appropriate restrictions on the $P D E$ . For example, there might be a PDE (or $P D E$ group) that contains calibration values that can be modified only by maintenance personnel and that cannot be downloaded to the equipment. In some cases, such a calibration $P D E$ is automatically updated just before the run and can be specified only by gid. 8.5.4.5 The EquipmentNode shall be able to positively confirm the association of a PDEheader to its external PDEbody based on matching of information contained in the PDEbody with public information contained in the PDEheader. 8.5.4.5.1 The\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications (Part 6)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications\n\nContent: suggested method is to embed the uid inside the PDEbody, but this is not a required solution. 8.5.4.5.2 This may also be accomplished by computing the checksum of the PDEbody and comparing it to the bodyChecksum value contained in the $P D E$ . This method requires no change to the PDEbody. 8.5.4.6 The EquipmentNode shall verify each $P D E$ upon receipt. This verification shall be the equivalent of that initiated by the verifyPDE() service with verify $T y p e =$ validity and verifyDepth $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ single. 8.5.4.6.1 The EquipmentNode shall reject any PDE that fails this verification process. 8.5.4.6.2 The equipment is encouraged to verify any recipes that are placed on the equipment from any source and via any method (for example, using removable media). 8.5.4.6.3 The equipment is encouraged to verify the Master PDE before execution. It is suggested that the verification performed be the equivalent of that initiated by the verify $P D E ( )$ service with verifyType\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications (Part 7)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications\n\nContent: $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ checksum and verifyDepth $\\ O =$ all. Note that no results can be reported to the client. Any $P D E$ that fails verification (except for the non-presence of a referenced $P D E$ ) should be removed from the recipe store on the equipment. If possible, a copy should be kept in a private area for debugging purposes. 8.5.4.7 The EquipmentNode shall monitor the collection of PDEs available at the equipment. When the collection changes (that is, a PDE is added or removed), then the EquipmentNode shall notify the FICS via the event data collection mechanism available on that equipment. Two events shall be defined to support this capability: PDEadded and PDEremoved. When multiple PDEs are added or deleted at the same time, the change shall be reported with a single event. A data collection parameter, PDElist, shall be provided to contain list of the uid’s of the affected PDEs. 8.5.4.7.1 The EquipmentNode shall define a Status Variable that contains the time and\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications (Part 8)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications\n\nContent: date of the last change of the recipe collection on that equipment. This Status Variable shall be accessible by the FICS (for example, using the S1,F3/F4 message defined in SEMI E5). 8.5.4.7.2 In the event that a client is disconnected from the EquipmentNode and then reconnected, the client may check the above resynchronize by using the getPDEdirectory() service. 8.5.4.8 The EquipmentNode shall provide a configurable Boolean setting named “ResolvePDEreferences”. 8.5.4.8.1 This setting shall be configurable by the FICS (for example, using the S2,F15/16 message defined in SEMI E5). 8.5.4.8.2 If ResolvePDEreferences is set to “True”, the EquipmentNode shall resolve any $P D E$ references left unresolved by the client when executing a recipe or processing the resolvePDE() and $\\nu e r i f y P D E ( )$ services. When the EquipmentNode is required to resolve any unresolved gid’s, it shall select the available $P D E$ with the same gid that has the newest createDate. In the rare instance that more than\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications (Part 9)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications\n\nContent: one $P D E$ has the same (newest) creation date, the equipment shall select one whose uid value comes first alphanumerically. 8.5.4.8.3 If ResolvePDEreferences is set to “False”, the EquipmentNode shall not resolve any PDE reference. 8.5.4.9 The EquipmentNode shall provide a predefined input parameter (Variable Parameter) for any job that executes a recipe consisting of PDEs. This Variable Parameter shall be named “PDEmap”. The equipment client shall be allowed to supply this value during definition of the job. The format of the PDEmap shall be the same as the inputMap and outputMap parameters of the resolvePDE() service (see ¶8.4.2.3). 8.5.4.9.1 The PDEmap parameter value shall be used by the equipment to resolve the recipe structure to be used for the corresponding job. This process is the same as that used for the resolvePDE() service. 8.5.4.10 The Equipment shall provide at least one entity capable of creating PDEs (for example, PDEeditor), either a) on the equipment or b) directly\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications (Part 10)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications\n\nContent: communicating with the equipment 8.5.4.10.1 This PDEeditor shall be capable of adding or removing PDEs to the equipment’s storage area. This may be done with RaP compliant services or by proprietary means. This requirement may also be met by having the PDEeditor and Equipment share storage space. 8.5.5 PDEeditor and EditorNode Requirements And Clarifications 8.5.5.1 A PDEeditor is any entity that can create PDEs. An EditorNode is a PDEeditor that supports RaP services Not all PDEeditors are EditorNodes. 8.5.5.2 PDEeditor 8.5.5.2.1 This section discusses requirements and clarifications related to the creation of PDEs. 8.5.5.2.1.1 A PDEeditor shall be capable of creating and modifying all PDEs needed by the equipment. 8.5.5.2.1.2 For any recipe it creates, the PDEeditor shall ensure that any ExecutionTarget definition shall describe only equipment that are able to execute this PDE. 8.5.5.2.1.2.1 The ExecutionTarget attributes of supplier, make, model, and recipeType are used for this purpose.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications (Part 11)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications\n\nContent: 8.5.5.2.1.3 All PDEeditors shall be able to positively confirm the association of a PDEheader to its external PDEbody based on matching of information contained in the PDEbody with public information contained in the PDEheader. 8.5.5.2.1.4 RaP does not restrict recipe creation to EditorNodes nor to only RaPnodes. Recipes can be created by any entity so long as the resulting PDE(s) meet all requirements of this specification. 8.5.5.2.1.5 During the PDE creation process, the PDEeditor shall provide the user the opportunity to enter userInfo text strings. 8.5.5.2.1.6 The PDEeditor shall enforce restrictions on $P D E s$ in the same group. All PDEs in a group shall have the same set of PDEparameters and they shall have default values on the same subset of these PDEparameters. The PDEeditor might need access to a member of the group (or key information from a group member) in order to create a new member. 8.5.5.2.1.7 When the PDEeditor creates a new PDE the following shall be true with regard to PDE\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications (Part 12)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications\n\nContent: groups: 8.5.5.2.1.7.1 The PDEeditor that creates the $P D E$ shall determine the gid during PDE creation 8.5.5.2.1.7.2 The PDEeditor shall determine (based on user input) whether a PDE will join an existing PDE group and if so, will enforce the rules for PDEs that are in the same group (see $\\ P 8 . 3 . 2$ for more information). 8.5.5.2.1.7.3 In all other cases, the gid shall be a new uuid value generated at recipe creation time (distinct from the uid). 8.5.5.2.1.8 During the PDE creation process, the PDEeditor shall allow the user the option of setting ExecutionTargets or omitting them. ExecutionTargets are intended to ensure that PDEs are executed on the correct equipment. By omitting the ExecutionTargets, the user chooses to bypass this protection by the equipment. 8.5.5.2.1.9 The PDEeditor shall allow the user to define the PDEparameters for a PDE and when, during processing, these PDEparameters shall be applied. 8.5.5.3 EditorNode 8.5.5.3.1 This section discusses requirements and\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications (Part 13)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications\n\nContent: clarifications related to communication with an EditorNode. 8.5.5.3.1.1 If EditorNode(s) are provided, each shall support all the services defined for it as noted in Table 15. 8.5.5.3.1.2 An EditorNode may choose to communicate with an EquipmentNode using RaP services, but it is no required to do so. 8.5.5.3.1.2.1 A proprietary interface may be used between PDEeditor and Equipment. 8.5.5.3.1.2.2 In either case, the equivalent of all RaP services defined between EditorNode and EquipmentNode shall be provided. 8.5.5.3.1.3 The EditorNode shall be able to perform all RaP related activities without the presence of a FICSnode (that is, where all communications with the FICS are initiated by the FICS). 8.5.5.3.1.3.1 The EditorNode should provide alternate methods of performing these activities that take advantage of the presence of a FICSnode. For example, at the PDEeditor, human triggered (EditorNode initiated) PDE upload may be supported. 8.5.5.3.1.4 The EditorNode can create a new $P D E$ group at any\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications (Part 14)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 8.5  RaPnode Requirements and Clarifications\n\nContent: time. There are no restrictions.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 9  Compliance\n\n9.1  Table 27 is intended to be used to document compliance to RaP.  One copy of the table shall be completed per RaPnode to be implemented.  \n9.2  The first row of the table declares the type of RaP node to be delivered.  The proper box shall be checked. Where two types of RaP node are combined, two boxes shall be checked.  The combination of Equipment and FICS is not allowed.  \n9.3  Each (non-header) row in the table references a subsection number from $\\ S 8$ (RaP Requirements).  A check in the checkbox for the “RaP Compliant” column shall indicate that all requirements in the named subsections for that row (and their subsections) are met.  \n9.4  For an equipment to be considered RaP compliant, it shall supply an EquipmentNode that complies with all applicable RaP requirements and in addition, all EditorNodes that are supplied (if any) shall be RaP compliant.  \nTable 28  RaP Compliance Table\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # 10  Related Documents\n\nGrady Booch, James Rumbaugh, and Ivar Jacobson, The Unified Modeling Language User Guide, Reading Massachusetts, Addison Wesley: 1999  ISBN 0-201-57168-4. Rivest, Ronald, The MD5 Message-Digest Algorithm, IETF RFC: 1992  http://www.ietf.org/rfc/rfc1321.txt. Uniform Resource Name (URN) Syntax, IETF RFC 2141, May 1997 http://www.ietf.org/rfc/rfc2141.txt.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # RELATED INFORMATION 1\n\nNOTICE:  This related information is not an official part of SEMI E139 and was derived from North American Information and Control Committee.  This related information was approved for publication by full letter ballot on December 10, 2004.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-1  Scenarios (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-1  Scenarios\n\nContent: R1-1.1 This section contains example scenarios to illustrate how RaP services might be used in practice. They represent only a subset of possible scenarios. The purpose of including these scenarios is to demonstrate how the RaP services can work together to perform complex tasks. R1-1.1.1 For these scenarios, certain assumptions were needed about how business rules of the FICS and about the outcome of certain services. These assumptions are stated. The FICS business rules are not intended to represent actual factory systems. Instead, they are designed to demonstrate possible combinations of services to perform a task. RaP is intended to work with a wide range of FICS business rules. It is not possible to demonstrate all situations. R1-1.1.2 Assumptions for all scenarios: (unless otherwise noted in the individual scenario) Equipment, Editor, and FICS nodes are separate nodes that communicate via RaP services (note that Equipment to Editor communications are not required to use RaP services). • The \"User\" entity represents any\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-1  Scenarios (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-1  Scenarios\n\nContent: source of stimulus, human or electronic. • All message receive positive or \"success\" (response unless otherwise noted). • The provided scenarios may not be the only way to accomplish each task. This set is not meant to be exhaustive. Response messages are not shown unless they add information for the reader.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-2  Scenario – Download PDEs\n\nR1-2.1  This scenario is representative of most uses of the sendPDE() service.  \nR1-2.1.1  Assumptions:  \nThe PDEs to be downloaded are not currently stored on the equipment.  \nFigure R1-1\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-2.1.1.2  Notes:\n\n• The EquipmentNode is the only one required to validate upon receipt of a TransportContainer.  Transfer to FICS or to Editor would be similar, but with the internal Verify step left off. Whether the PDEs are related (e.g. same recipe) or not does not affect this scenario.  If all PDEs for a recipe are available, a subsequent scenario to validate the full recipe can be executed.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-3  Scenario – Upload Selected PDEs\n\nR1-3.1  This scenario is representative of most uses of the getPDE() service.  \nR1-3.1.1  Assumptions:  \n• The equipment stores some PDEs.  It may or may not be the “System of Record”.\n• The user is searching for particular PDEs, based on some unspecified criteria that is beyond what can be returned in getPDEdirectory().\n• Once the PDEs are identified, they are to be uploaded to the FICS.  \nFigure R1-2\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-3.1.1.2  Notes:\n\n• The getPDEdirectory() service is used to get a complete list of PDEs available.\nThe getPDEheader() service is used to get detailed information about a subset of the PDEs available.\n• The final PDEs uploaded are selected based on the PDEheader information.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-4  Scenario – Delete Selected PDEs\n\nR1-4.1  This is a common usage of the deletePDE() service, but does not assume pre-knowledge of which PDEs are actually on the equipment.  \nR1-4.1.1  Assumptions:  \nThe user knows which PDEs should be on the equipment.  So he/she needs to see a list of PDEs actually on the equipment and will delete those that are not needed.  \nFigure R1-3\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-4.1.1.2  Notes:\n\n• The getPDEdirectory() service can return basic information about the $P D E s$ , including name, uid, description, createDate, etc. as needed to support the identification of PDEs.\n• Systems that track which recipes are on the equipment may not need to request a directory listing.  Such tracking is possible by monitoring the event reports when the recipe collection changes and checking the status variable that notes the last time the recipe collection changed.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-5  Scenario – Create PDE\n\nR1-5.1  There are many different ways to approach this scenario.  This is just one of those ways.  It is intended to demonstrate most of the services that might be used.  \nR1-5.1.1  Assumptions:  \nThe equipment is the “system of record” for PDEs in this example.\nThis $P D E$ is created based on an existing $P D E$ that is stored on the equipment.  \nFigure R1-4\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-5.1.1.2  Notes:\n\n• If the existing & resulting $P D E s$ were stored by the FICS, the scenario would be similar (replace Equipment with FICS).  \n“Editing” a $P D E$ is the same as creating a new PDE, since each new version must be given a new unique identifier.\nThe PDEeditor is responsible for verification of the new PDE.  Resolution of verification issues is between PDEeditor and User.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-6  Scenario – Preparation for Processing (1)\n\nR1-6.1  This scenario represents a central recipe management system with off-tool system of record.  \nR1-6.1.1  Assumptions:  \nThe equipment is configured to never resolve gid references in recipes.  The host must/will supply all needed resolutions. The FICS (per its Recipe Management System) knows exactly which PDEs should be used in any processing situation. • All PDEs used the last time that this process was run are on the equipment. • The user has updated one $P D E$ that must replace an older version; this PDE and its uses are managed by an FICS-level recipe management system. • The automatic verification of the downloaded PDE is assumed to succeed. While RaP recommends that an equipment perform a verification of the full recipe before executing it, this equipment does not perform that task. • A Process Job will soon use this newly verified Master PDE.  \nFigure R1-5\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-6.1.1.2  Notes:\n\n• The getPDEdirectory() service is used to determine what PDEs are on the equipment.\n• The FICS accesses the recipe management system to obtain the list of “needed PDEs”  This is compared with the $P D E$ directory to determine which, if any, are needed.\n• The TransferContainer contains only the PDE not currently on the equipment.\n• The verifyPDE() service refers to the Master PDE for the intended process job and has verifyType $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ Checksum and verifyDepth $\\ O =$ All.  A full inputMap is supplied. The PDEmap is used as the inputMap for the verifyPDE() service.\n• In this scenario, the “requestToSendPDE()” message is omitted.  Its use is at the option of the client to ensure a PDE download will not be rejected.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-7  Scenario – Preparation for Processing (2) (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-7  Scenario – Preparation for Processing (2)\n\nContent: R1-7.1 This scenario is intended to represent some aspects of early stage recipe management where recipes are stored on the equipment and central control and tracking is not available. R1-7.1.1 Assumptions: • PDEs are created at the equipment, which serves as the system of record. • The business practice of the FICS is that the latest version of each $P D E$ available on the equipment should always be used. For that reason, $P D E s$ are referenced by gid and the equipment always resolves these gids. The FICS records which PDEs were last used with each Master PDE. It detects when the current set differs from the previous execution of this Master PDE and seeks confirmation from the user that the change is appropriate. All PDEs used the last time that this Master PDE was executed are on the equipment. • The user has updated one $P D E$ that must now be used in place of an older version. • The equipment follows the RaP recommendation that an equipment perform a verification of the full recipe\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-7  Scenario – Preparation for Processing (2) (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-7  Scenario – Preparation for Processing (2)\n\nContent: before executing. Therefore, such verification is not necessary in this scenario. A Process Job will soon use this newly verified Master PDE. Figure R1-6\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R1-7.1.1.2  Notes:\n\n• The Master PDE is specified as the targetPDE in the resolvePDE() message.  \nThe getPDEdirectory() service is used to get further information about the new $P D E$ found in the outputMap of the resolvePDE() service.  Alternately, the getPDEheader() service could have been used if more detailed information were required.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # RELATED INFORMATION 2\n\nNOTICE:  This related information is not an official part of SEMI E139 and was derived from the North American Information and Control Committee.  This related information was approved for publication by full letter ballot on December 10, 2004.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-1  Implementation Suggestions\n\nR2-1.1  This related information is included to supplement the specification with some suggestions about the use of RaP and its capabilities.  Its purpose is a) to promote more uniform application of RaP and b) to share some insights of the creators of RaP that may lead to improved results from its use.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-2  Combining RaPnodes (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-2  Combining RaPnodes\n\nContent: R2-2.1 $\\ P 8 . 5 . 2 . 3$ mentions the possibility of combining RaPnodes. This section will briefly discuss this topic to outline when and why this might be appropriate. R2-2.1.1 In general, when multiple nodes are combined, efficiency can be gained by: • Coding the individual services only once (since most are common to all RaPnodes)6. • Sharing the computing platform where the software is run. • Eliminating the communication between the two separate RaPnodes by designing them to be a single entity. R2-2.1.1.1 Not all RapNode combinations are practical. In particular, the combination of EquipmentNode with FICSnode is not commercially feasible due to the many different suppliers’ equipment that must communicate with one FICS. The other two combinations may be useful in the some situations. R2-2.1.1.2 Combining the EquipmentNode and the EditorNode mirrors the traditional equipment “on-tool” editing capability. This approach might provide the easiest transition to RaP for some equipment suppliers. It also ensures that\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-2  Combining RaPnodes (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-2  Combining RaPnodes\n\nContent: the equipment will function “out of the box” without integration. Since multiple PDEeditors are allowed, the “off-tool” version could be provided later or as an add-on. R2-2.1.1.3 The combination of FICSnode with EditorNode might represent the integration of an off-tool editor with an off-tool recipe management capability. In the long term, there might be a movement to general PDEeditors that are compatible with many suppliers’ equipment recipes. Integrating a recipe management capability with that general editor would be a logical next step. R2-2.1.1.4 If the implementation for messaging is SECS-II only, then any equipment with an on-tool editor must combine the EquipmentNode and EditorNode. This is necessary since multiple SECS-II sessions are not well supported. R2-2.1.1.5 When two RaPnodes are combined, they are expected to act as a single entity with a union of the capabilities of the two types of RaPnodes. The combined RaPnodes are expected to share resources, including the recipe storage area. Messages to the\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-2  Combining RaPnodes (Part 3)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-2  Combining RaPnodes\n\nContent: combined RaPnodes will not differentiate which node type is being addressed.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-3  RaP Support For SEMI E40 and SEMI E30 (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-3  RaP Support For SEMI E40 and SEMI E30\n\nContent: R2-3.1 RaP can be used in conjunction with SEMI E40 Process Job Management or with SEMI E30 GEM. This section discusses how to map the key recipe-related parameters from those two standards to the RaP attributes. In both cases, the management of the recipes uses RaP services. This section discusses how the recipe is specified for the processing activity and how the Variable Parameters are communicated. R2-3.2 In SEMI E40, recipe information is specified as part of the job specification in the Stream 16 messages as RCPSPEC (recipe identifier - text) and RCPPARNM (recipe variable name - text). To satisfy RCPSPEC, a RaP implementation should supply the identifier (uid or gid) of the Master PDE. R2-3.3 The Variable Parameters defined in RaP were intended to correspond directly with the RecipeVariables defined in SEMI E40. The PDEparameters of the Master PDE should be mapped directly to RecipeVariables. The RaP PDEparameter class includes a name attribute. This name value can be supplied in the Steam 16\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-3  RaP Support For SEMI E40 and SEMI E30 (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-3  RaP Support For SEMI E40 and SEMI E30\n\nContent: messages as the value of an RCPPARNM parameter. R2-3.4 Support for SEMI E30 works differently. In this case, there is no concept of a process job. Instead, it is a two step process: 1) the recipe is “selected” for execution, and then 2) a START command is given to begin execution. Both of these requests are made using the S2,F49 message (Enhanced Remote Command – see SEMI E5). The Remote Command message accepts parameter values (called CEPVAL’s). Each CEPVAL has a corresponding identifier called CPNAME. R2-3.5 In the first step, the RCMD (remote command) is RCP-SELECT. The identifier of the recipe is contained in a CEPVAL. The uid (or gid) of the Master PDE is supplied as the CEPVAL to identify the recipe. The supplier determines the CPNAME of this parameter. R2-3.6 In the second step, the S2,F49 message requests the START remote command. In this message, the CEPVAL’s contain parameters that apply to the activity. The equipment may have some pre-defined parameters. The PDEparameter values may also\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-3  RaP Support For SEMI E40 and SEMI E30 (Part 3)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-3  RaP Support For SEMI E40 and SEMI E30\n\nContent: be specified here as CEPVAL’s. The name of the PDEparameter should be specified as the CPNAME.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-4  Factory Assigned Recipe Attributes (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-4  Factory Assigned Recipe Attributes\n\nContent: R2-4.1 Some factory systems track various attributes of specifications within their factory. Recipes are one type of specification and often have important attributes associated with them. For example, a recipe may need to undergo certain tests before it is qualified to use in production. Also, there may be some sort of management sign-off process. These and other such attributes are used by the factory to help determine what recipe can be run in a given situation. R2-4.2 The definition of recipe management practices of the factory is beyond the scope of RaP. However, a place has been provided within the PDEheader for the factory to store (and later retrieve) such information. The userInfo attribute provides a list of text strings that the factory can use for this purpose. R2-4.3 Any attribute that can be represented as a text string can be included. Using common text formatting approaches (for example, comma separated values), both simple and complex attributes can be stored. For example, one userInfo\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-4  Factory Assigned Recipe Attributes (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-4  Factory Assigned Recipe Attributes\n\nContent: field might contain a name/value pair something like this: “Approved, True”. R2-4.4 It is expected that the userInfo will not be used for very large data structures, such as photographic images. An attempt to include data much larger than the original $P D E$ might cause unexpected results. R2-4.5 Since the equipment will not try to interpret these values and undocumented changes to the recipe are not possible, this provides a secure place to store these values. R2-4.5.1 Some examples of userInfo strings include: Comment — The user can enter a detailed explanation of the need for this $P D E$ , the conditions that led to its creation, etc. This can help when transfer of duties to a new engineer occurs. • Approval Level — is the recipe approved for use?; what use is it approved for? • Version — what version number will the host assign to this $P D E$ for tracking purposes? • Classification — there are many ways to classify recipe components – the factory area of use, which step in the process, which\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-4  Factory Assigned Recipe Attributes (Part 3)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-4  Factory Assigned Recipe Attributes\n\nContent: process (or process version), etc.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-5  Supplier Assigned Recipe Attributes\n\nR2-5.1  The equipment supplier may need to provide information about each $P D E$ that is not standardized.  The supplierInfo attribute is provided to allow the supplier to include this information.  The format is the same as for userInfo – a list of text strings.  \nR2-5.1.1  Here are some examples of potential uses of supplierInfo:  \nformatVersion — Supplier assigned string that documents the version of  the format or language used to create this PDE.  This can help the user determine whether the PDE is compatible with a particular equipment. version — Version of the $P D E$ .  This represents the supplier-assigned version value.  If equipment-based recipe management is used, a versioning scheme may be helpful.  The equipment supplier should document its versioning strategy.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-6  Parameterization Notes (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-6  Parameterization Notes\n\nContent: R2-6.1 Parameterization of equipment recipes begins with the setting of Module Parameters according to Variable Parameters entered at run time. There are other uses of parameterization that may be very beneficial. Parameterization can also help with complex control situations. This section discusses such opportunities. R2-6.1.1 Selection of ExecutionTarget — The recipe documents which ExecutionTargets are allowed to execute each PDE. At execution time, it is possible that more than one specified ExecutionTarget will be available (for example, identical processing modules in a cluster tool). The selection is made by the equipment, in accordance with any instructions in the recipe. However, there may be times when one of the processing modules is not operating within specifications for certain products. In such a situation, how can the factory force the equipment to exclusively choose the other process module? One answer would be to provide an input parameter to the recipe for selection of process module for this $P\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-6  Parameterization Notes (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-6  Parameterization Notes\n\nContent: D E$ . The default might be “use both” with the opportunity to select one or the other exclusively. R2-6.1.2 Process Control For Multiple ExecutionTargets — There are situations where multiple, equivalent processing modules are available on the equipment and are all identified as ExecutionTargets. If wafers are sent to the next available process chamber, it would not be possible to predict which process module a given wafer might use. When process control is being applied to this equipment, this can cause complication. Each of the process modules can have very different control responses. So each would have different control settings for a specific material/job situation. To serve the user’s needs in this case, it should be possible to define one set of PDEparameters for each possible ExecutionTarget. These parallel parameter sets would all need to be set. The PDE would select the proper parameter set based on the choice of process module for a given wafer. R2-6.2 The reverse issue may also exist in this situation\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-6  Parameterization Notes (Part 3)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-6  Parameterization Notes\n\nContent: of multiple equivalent ExecutionTargets. Some ModuleParameters should take on the same value, no matter which ExecutionTarget is chosen. The implementation should allow for the specification of a single PDEparameter whose value will be applied correctly for any of the specified ExecutionTargets. R2-6.2.1 So, the user should have the option to specify different values per ExecutionTarget or a single value to be used for all.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-7  Traceability\n\nR2-7.1  Proper traceability of processing should include recording enough information to determine exactly what was done in any instance of processing.  An important part of this information set is a record of the instructions provided to the equipment.  This includes the specific PDEs used and the external setting values provided to satisfy the Variable Parameters.  \nR2-7.1.1  It is recommended that the equipment supplier create data collection parameters that allow the user to collect the following:  \n• The identifier of the Master PDE specified for the process job,\n• The PDEmap provided to resolve the recipe structure,\n• A list of all the PDEs actually used during processing,\n• All Variable Parameter values supplied for the process job, and\n• The PDE(s) used for each instance of processing (for example, when a wafer is processed in a process module. o Also include the PDEparameter settings that affected that instance of processing.  \no The settings for all Module Parameters of this process module.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-8  Recipe Security (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-8  Recipe Security\n\nContent: R2-8.1 The use of the universally unique identifier and checksum provide significant protection against misprocessing due to the use of the wrong recipe. However it is not completely secure from intentional tampering. R2-8.2 It is possible for someone to modify an existing $P D E$ without changing the uid. To complete the deception, a new checksum would need to be calculated and included in the PDE. A PDE changed in this way might not be detected in some factory systems. R2-8.3 There is a way to address this problem and ensure that only the correct recipes are used. This assumes that there is a factory level recipe management system where the known-good PDEs are all logged and their authorization for use is recorded. This system should log the uid of each $P D E$ , along with its checksum. R2-8.4 Recall that the equipment will check each $P D E$ against its internal checksum value when the $P D E$ is transferred to the equipment and most will check it again before execution. This ensures that each $P D E$ is\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-8  Recipe Security (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-8  Recipe Security\n\nContent: selfconsistent. R2-8.5 Whenever a recipe is to be used for processing, the FICS can perform a getPDEdirectory() service to list the PDEs to be used and their checksums. It can then compare the stored (known-good) checksum for that $P D E$ with the current checksum value. In this way, the FICS can detect any changes and ensure that the correct $P D E s$ are being used.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-9  PDEeditor/Equipment Synchronization\n\nR2-9.1  RaP defines services in support of an off-tool recipe editor.  When the editor is a separate entity, there arises a potential problem of synchronization.  Any modifications to the equipment software may require a corresponding change to the PDEeditor.  If these updates are not done in a coordinated way, then significant problem could develop.  RaP does not offer a solution to this problem.  It provides only this warning of the potential problem.  It is the responsibility of the users to put a process in place to ensure that their suppliers maintain synchronization of the equipment and editor software.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-10  Human Involvement In Recipe Selection (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-10  Human Involvement In Recipe Selection\n\nContent: R2-10.1 RaP is designed to work well in an automated factory system. In some situations, however, humans must be involved in the process. Unfortunately, the UUID format is not user-friendly. R2-10.1.1 When a system must rely on a human to select a recipe, there must be enough human-recognizable information to ensure the correct choice is made. This is a recommendation of how to support such a human selection of PDEs. uid/gid — It is not recommended that the uid and gid be displayed to the user. They are long strings with no human-parsable information. name — Name should be the most useful information to the user. However, it depends on the users defining a meaningful naming convention for PDEs. This is an important consideration. groupName — This can give the user a good idea of the intended use of this PDE. Again, it depends on a meaningful naming convention from the users. type — This allows the user to distinguish, for example, between a sequence recipe and a module recipe or between etch and\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-10  Human Involvement In Recipe Selection (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-10  Human Involvement In Recipe Selection\n\nContent: clean recipes. The use of type may vary, but it will typically help make important distinctions. createDate — Allows a user to get a sense of the chronology. description — If the users enter appropriate information, this can be very helpful. However, it can also be very long. This is good for an extended display about a PDE. • author — Who created a PDE is a very strong clue about what it is to be used for. userInfo — More good information for an extended display. supplierInfo — Again, good information for an extended display. R2-10.2 In general, a display of the name, groupName, type and createDate should be adequate to support a recipe selection in most cases. An extended display should be available when more help is needed.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-11  Optimizing getPDEdirectory() Service\n\nR2-11.1  A poor implementation of the getPDEdirectory() service may be inefficient.  It is clear that some getPDEdirectory() requests may require the RaPnode to return information from the header of all the recipes stored at this node.  Reading bits of information from hundreds of potentially large files can be time consuming.  It is suggested that steps be taken to optimize this implementation.  For instance, if key parts of the header from each PDE on the RaPnode are stored separately (for example, in a database), then retrieval of this information can be very fast.  However, this cataloging of all recipes requires careful management of the PDEs and some overhead to maintain.  The software designer should consider all these factors when implementing this service.\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-12  PDEeditor Identification (Part 1)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-12  PDEeditor Identification\n\nContent: R2-12.1 Not all PDEeditors are EditorNodes. There may be standalone editors that create PDEs that are moved to the equipment (or to the Recipe Management System) by other means – email, floppy disk, or other transport mediums. Some recipes may originate from the supplier. It is important that all PDEeditors embed meaningful nodeID’s that identify the source clearly to the eventual user of the recipe. It is recommended that all nodeID’s contain URN strings as defined in Internet standards. NOTICE: SEMI makes no warranties or representations as to the suitability of the standards set forth herein for any particular application. The determination of the suitability of the standard is solely the responsibility of the user. Users are cautioned to refer to manufacturer's instructions, product labels, product data sheets, and other relevant literature, respecting any materials or equipment mentioned herein. These standards are subject to change without notice. By publication of this standard, Semiconductor Equipment\n\nSEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-12  PDEeditor Identification (Part 2)\n\nTitle: SEMI E139-0705 SPECIFICATION FOR RECIPE AND PARAMETER MANAGEMENT (RaP) - # R2-12  PDEeditor Identification\n\nContent: and Materials International (SEMI) takes no position respecting the validity of any patent rights or copyrights asserted in connection with any items mentioned in this standard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and the risk of infringement of such rights are entirely their own responsibility.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE\n\nThis standard was technically approved by the global Information & Control Committee.  This edition was approved for publication by the global Audits and Reviews Subcommittee on April 7, 2005.  It was available at www.semi.org in June 2005 and on CD-ROM in July 2005.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # Table of Contents\n\n1 Purpose . 2\n2 Scope .2\n3 Limitations. 2\n4 Referenced Standards and Documents .2\n5 Terminology .. .2\n6 Conventions.. .3\n7 PDE Schema Definition.... .6\n8 Manifest Schema Definition 13\n9 Related Documents.. 14\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # List of Figures\n\nFigure 1 XML Example Diagram.\nFigure 2 XML for Sample .6\nFigure 3 PDE ..\nFigure 4 PDEheader... ..8\nFigure 5 ExecutionTarget .. ..9\nFigure 6 ReferencedPDE .. .9\nFigure 7 AntecedentData ... .10\nFigure 8 PDEparameter . 11\nFigure 9 PDEbody ... .11\nFigure 10 PDEbodyReference .. .11\nFigure 11 Manifest... 14\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # List of Tables\n\nTable 1 Example Translation Table.. .3\nTable 2 Altova XMLSPY $\\textsuperscript { \\textregistered }$ Schema Diagram Symbols.. .4\nTable 3 Translation Table For PDE Class . 7\nTable 4 Translation Table For PDEheader Class..\nTable 5 Translation Table For ExecutionTarget... ..9\nTable 6 Translation Table For ReferencedPDE.. 9\nTable 7 Translation Table For AntecedentData... .10\nTable 8 Translation Table For PDEparameter . ..10\nTable 9 Translation Table For PDEbody. .11\nTable 10 Translation Table For PDEbodyReference... .11\nTable 11 simpleTypes In The PDE Schema .12\nTable 12 complexTypes In The PDE Schema ... ..12\nTable 13 Translation Table For Manifest Class... ..13\nTable 14 simpleTypes In The PDE Schema .. .14\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 1  Purpose\n\n1.1  The purpose of this document is to define an XML-based format for transferring recipe components.  This includes an XML schema that corresponds to the UML model for the RaP Process Definition Element (PDE) as defined by SEMI E139.  In addition, an XML schema is defined for the Manifest that must be included in the TransferContainer with the PDE’s during transfer.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 2  Scope\n\n2.1  The scope of this document is the faithful representation of the PDE and Manifest definition from SEMI E139 in an XML schema.  It will not add new domain information or concepts to the model.  The only additions made are those needed to render a useful XML schema.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 3  Limitations\n\nNOTICE: This standard does not purport to address safety issues, if any, associated with its use.  It is the responsibility of the users of this standard to establish appropriate safety and health practices and determine the applicability of regulatory or other limitations prior to use.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 4  Referenced Standards and Documents\n\n4.1  SEMI Standards  \nSEMI E121 — Guide for Style & Usage of XML for Semiconductor Manufacturing Applications  \n4.2  OMG Standards  \nUnified Modeling Language (UML) Specification, Version 1.4, OMG Specification 01-09-67, (http://www.omg.org/technology/documents/modeling_spec_catalog.htm).  \n4.3  W3C Standards  \nCanonical XML Version 1.0 — W3C, 15 March 2001 (http://www.w3.org/TR/xml-c14n).  \nExtensible Markup Language (XML) 1.0 (Second Edition) W3C, 6 October 2000 (http://www.w3.org/TR/2000/REC-xml-20001006/).  \nNamespaces in XML — W3C, 14 January 1999 (http://www.w3.org/TR/1999/REC-xml-names-19990114/).  \nXML Schema Part 0: Primer — W3C, 2 May 2001 (http://www.w3.org/TR/xmlschema-0/).  \nXML Schema Part 1: Structures — W3C, 2 May 2001 (http://www.w3.org/TR/xmlschema-1/)  \nXML Schema Part 2: Datatypes — W3C, 2 May 2001 (http://www.w3.org/TR/xmlschema-2/).  \nXML Path Language (Xpath)  — W3C, 16 November 1999 (http://www.w3.org/TR/xpath/).\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 5  Terminology\n\n5.1  Abbreviations and Acronyms  \n5.1.1  UML — Unified Modeling Language  \n5.1.2  W3C — World Wide Web Consortium  \n5.1.3  XML — eXtensible Markup Language  \n5.2  Definitions And Acronyms  \n5.2.1  UML (Unified Modeling Language) — A notation for representing object-oriented designs and views created by Booch, Rumbaugh, and Jacobson in order to merge their three popular notations plus aspects of other existing notations into a single object-oriented notation intended to be usable by all.  \n5.2.2  XML (eXtensible Markup Language) — A markup language used for representing data rich with context and content in documents and in communications.  XML is an extension of SGML, a document-oriented markup language.  It was created by W3C for use on the Internet.  XML can represent object-oriented structures.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6  Conventions\n\n6.1  This section discusses the conventions used in this specification for translating UML to XML and for documenting the XML.  These conventions are heavily influenced by the SEMI E121 Guide for Style & Usage of XML for Semiconductor Manufacturing Applications.  \n6.2  The reader is expected to have a working knowledge of the UML, XML, and Schema specifications (See $\\ P 4 . 2$ and ¶4.3).  This document does not provide tutorial information on these subjects.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6.3  Translating UML to XML\n\n6.3.1  This document follows the guidelines for XML as outlined in SEMI E121 “Guide For Style & Usage of XML for Semiconductor Manufacturing Applications”.  \n6.3.2  Some of the key guidelines in this specification are summarized here:  \nAttributes of a class are generally represented as elements such that they can be easily extended by other applications.\n• Inheritance is modeled as element extension.\n• Compositions always turn into contained elements (or contained collections if multiples are allowed).\n• Associations and Aggregations are modeled as contained elements or arrays wherever possible to simplify the instance model.  \n6.3.3  The translation of a UML class to XML is documented using a table format illustrated by Table 1.  Note that the PDE model in SEMI E139 does not include services, so only attribute and association representations are addressed here.  Any superclass information is addressed in the text and the diagrams.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6.4  Translation Table Column Header Description\n\nAttribute or Role Name — If an attribute, the name of the attribute is placed here.  If an association (including aggregation or composition), the role name from the UML diagram is placed here.  Compositions are often not assigned role names.  In that case “none” is placed here. UML Type — If an attribute, the data type of the UML attribute is placed here.  If an association, the type of association is placed here.  The possible types are “Composition”, “Aggregation”, or the basic “Association”. UML defines these three types of association.\n• XML Element or Attribute — Lists the type of XML construct used to represent the UML attribute or association.\nXML Name/Type — Provides the name and data type of the resulting XML construct.  The type may be a built-in type (for example, xs:string), or a named type defined within the XML schema.  \nTable 1  Example Translation Table\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6.5  Documenting The XML With Diagrams (Part 1)\n\nTitle: SEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6.5  Documenting The XML With Diagrams\n\nContent: 6.5.1 This document provides graphical representations of the included XML. Although no standard graphical notation for XML could be found, various XML tools have their own notation. This document will use the notation provided by ${ \\mathrm { X M L S P Y } } \\circledast$ from Altova Corporation1. There is no requirement for use of $\\mathrm { X M L S P Y _ { \\textregistered } }$ in order to comply with this specification. Figure 1 shows a sample XML diagram that will be used to provide a basis for explanation of the XML graphical notation used in the rest of the document. 6.5.2 In the diagram, rectangular boxes represent XML elements. Ownership or containment is read from right to left in the diagrams. In the sample diagram, ParentType contains Child1, Child2, Child 3, and Child 4. In turn, Child2 contains Child2a, Child2b, and Child2c. The additional symbols (8-sided boxes) represent sequences or choices. See Table 2 for an explanation of these symbols. 6.5.3 Please note that “element”, “sequence”, “all”, and “choice” are XML\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6.5  Documenting The XML With Diagrams (Part 2)\n\nTitle: SEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6.5  Documenting The XML With Diagrams\n\nContent: terms (see the W3C standards referenced in $\\ P ( . 3 )$ . Table 2 Altova XMLSPY® Schema Diagram Symbols 6.5.4 A graphic using a solid line is a required element; using a dashed line represents an optional element. Numbers or ranges in the lower right hand corner represent cardinality. The default cardinality is one. 6.5.5 To simplify a diagram or help focus on a particular aspect, detail may be hidden. The 8-sided symbols have a small square on the right end. If a minus sign “-“ is in the box, then all detail is shown. If the box contains a plus sign $\\cdot _ { + } , \\cdot $ , then all detail to the right of that symbol is hidden. The example has no hidden detail. 6.5.6 The yellow (or gray if printed in monochrome) boxes indicate the use of other defined types. So, Child4 is of type “Child4Type”. Child4Type defines Child4a and Child4b. This detail may be hidden in the diagram. Object oriented inheritance is typically represented in XML as type extension. In Figure 1, ParentType extends Child1and2Type by adding a sequence that\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6.5  Documenting The XML With Diagrams (Part 3)\n\nTitle: SEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6.5  Documenting The XML With Diagrams\n\nContent: includes Child3 and Child4. 6.5.6.1 Reading Figure 1 would yield the following additional information: • Child1and2Type is an ordered sequence of two items: Child2 and Child1. Child1 contains an optional ordered sequence of Child1a, one or more Child1b, and (optionally) Child1c. • Child2 contains a choice of one or two of the following: Child2a, Child2b, and Child2c. • Child3 contains an unordered sequence of Child3a and Child3b.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6.5.7  XML Schema Sample (Part 1)\n\nTitle: SEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6.5.7  XML Schema Sample\n\nContent: 6.5.7.1 The sample XML for the example shown in Figure 1, is presented below. Refer to the XML documentation referenced in $\\ P 4 . 3$ for a complete description of the syntax and semantics of XML schemas. $- ? \\times \\mathsf { m l }$ version $\\lvert = \" 1 . 0 \"$ encoding $| = ^ { \\ l }$ \"UTF-8\"?> xs:schema xmlns:xs $\\vDash$ \"http://www.w3.org/2001/XMLSchema\" elementFormDefaul $\\cdot = \"$ ttributeFormDefaul $\\varXi ^ { \\prime }$ \"unqualified\" $\\ \" >$ <xs:complexType name $\\mathbf { \\Phi } = \\mathbf { \\dot { \\Phi } }$ \"ParentType\" abstract=\"true\"> <xs:complexContent> <xs:extension base $\\models ^ { \\prime \\prime }$ Child1and2Type\"> <xs:sequence> <xs:element name=\"Child3\"> <xs:complexType> <xs:all> <xs:element name $\\mathrel { \\mathop : } \\mathbf { \\Gamma }$ \"Child3a\"/> <xs:element name $\\ \" \\mathbf { \\Gamma }$ \"Child3b\"/> </xs:all> </xs:complexType> </xs:element> <xs:element name $= \"$ Child4\" type $\\models ^ { \\ \" }$ Child4Type\" nillable $\\mathbf { \\tau } = \\mathbf { \\dot { \\tau } }$ \"false\"/> </xs:sequence> </xs:extension> </xs:complexContent>\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6.5.7  XML Schema Sample (Part 2)\n\nTitle: SEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6.5.7  XML Schema Sample\n\nContent: </xs:complexType> <xs:complexType name $\\ c = \\ c ^ { \\prime }$ \"Child4Type\" abstrac $\\varXi ^ { \\prime }$ \"true\"> <xs:sequence> <xs:element name $\\ c = \"$ Child4a\" type $= \"$ xs:integer\" nillable $\\ c =$ \"false\"/> <xs:element name $= \"$ Child4b\" type $= \"$ xs:string\" nillable $\\ c =$ \"false\"/> </xs:sequence> </xs:complexType> <xs:complexType name $\\ c = \"$ Child1and2Type\" abstract=\"true\"> <xs:sequence> <xs:element name $= \"$ Child2\"> <xs:complexType> <xs:choice maxOccurs $= \" 2 \" >$ <xs:element name $\\ c = \\ c ^ { \\prime }$ \"Child2a\"/> <xs:element name $\\ c = \\ c ^ { \\prime }$ \"Child2b\"/> <xs:element name $\\ c = \\ c ^ { \\prime }$ \"Child2c\"/> </xs:choice> </xs:complexType> </xs:element> <xs:element name $= \"$ Child1\"> <xs:complexType> <xs:sequence minOccurs ${ \\bf \\tau } = \\ \" 0 \\ \\ \" >$ <xs:element name $\\ c = \\ c ^ { \\prime }$ \"Child1a\"/> <xs:element name $= ^ { \\prime }$ \"Child1b\" maxOccurs $\\ c = \\ c ^ { \\prime }$ \"unbounded\"/> <xs:element name $\\ c = \\operatorname { \\dot { \\Gamma } }$ \"Child1c\" minOccurs $= \" 0 \" / >$ </xs:sequence>\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6.5.7  XML Schema Sample (Part 3)\n\nTitle: SEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 6.5.7  XML Schema Sample\n\nContent: </xs:complexType> </xs:element> </xs:sequence> </xs:complexType> <xs:element name $\\ c = \\ c ^ { \\dagger }$ \"Parent\" type $\\ c = \\ c ^ { \\prime }$ \"ParentType\" fina $\\ c = \\dot { }$ \"#all\"/> /xs:schema>\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.1  PDE Class Mapping to XML\n\n7.1.1  This section describes how the PDE classes from SEMI E139 are mapped to XML.  The descriptions in this section are provided to support and explain the XML schema document for the PDE (attached, see $\\Vert 7 . 2 . 2 )$ .  This section contains no requirements.  Specific requirements are included in $\\ P 7 . 2$ .\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.1.2  Abstract Classes\n\n7.1.2.1  No classes in the PDE model for RaP are abstract.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.1.3  Concrete Classes\n\n7.1.3.1  This section contains the XML mappings for the concrete classes defined for the PDE in SEMI E139.  These are the classes that can be represented in an XML instance document based on the attached XML schema for the PDE.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.1.4  PDE\n\n7.1.4.1  The PDE class is mapped to the XML complexType also named PDE.  Table 3 shows how the associations and attributes of the PDE class are mapped into XML.  Figure 3 illustrates the resulting XML structure.  \n7.1.4.2  See $\\ P 7 . 2 . 1$ for instructions on the calculation of the value of the checksum element.  \nTable 3  Translation Table For PDE Class\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.1.4.3  PDEheader\n\n7.1.4.3.1  The PDEheader class is mapped to the XML complexType also named PDEheader.  Table 4 shows how the associations and attributes of the PDEheader class are mapped into XML.  Figure 4 illustrates the resulting XML structure.  \nTable 4  Translation Table For PDEheader Class\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.1.4.4  ExecutionTarget\n\n7.1.4.4.1  The ExecutionTarget class is mapped to the XML complexType also named ExecutionTarget.  Table 5 shows how the associations and attributes of the ExecutionTarget class are mapped into XML.  Figure 5 illustrates the resulting XML structure.  \nTable 5  Translation Table For ExecutionTarget\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.1.4.5  ReferencedPDE\n\n7.1.4.5.1  The ReferencedPDE class is mapped to the XML complexType also named ReferencedPDE.  Table 6 shows how the associations and attributes of the ReferencedPDE class are mapped into XML.  Figure 6 illustrates the resulting XML structure.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.1.4.6  AntecedentData\n\n7.1.4.6.1  The AntecedentData class is mapped to the XML complexType also named AntecedentData.  Table 7 shows how the associations and attributes of the ReferencedPDE class are mapped into XML.  Figure 7 illustrates the resulting XML structure.  \nTable 7  Translation Table For AntecedentData\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.1.4.7  PDEparameter\n\n7.1.4.7.1  The PDEparameter class is mapped to the XML complexType also named PDEparameter.  Table 8 shows how the attributes of PDEparameter are mapped to XML.  The resulting XML structure is illustrated in Figure 8.  \nTable 8  Translation Table For PDEparameter\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.1.4.8  PDEbody\n\n7.1.4.8.1  The PDEbody class is mapped to the XML complexType also named PDEbody.  Table 9 shows that the PDEbody is of type xs:any.  This type allows the implementation to place elements and attributes in an instance of PDEbody without restriction.  The resulting XML structure is illustrated in Figure 9.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.1.4.9  PDEbodyReference\n\n7.1.4.9.1  The PDEbodyReference class is mapped to the XML complexType also named PDEbodyReference. Table 10 shows how the attributes of PDEbodyReference are mapped to XML.  The resulting XML structure is illustrated in Figure 10.  \n7.1.4.9.2  See $\\ P 7 . 2 . 1$ for instructions on the calculation of the value of the bodyChecksum element.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.1.5  Added XML Constructs\n\n7.1.5.1  In the process of translating the UML model for the PDE into a useful XML schema, is was necessary to add certain types and constructs to the schema.  This section describes these XML constructs.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.1.5.2  XML simpleTypes\n\n7.1.5.2.1  Table 11 describes each simpleType2 added to the PDE schema.  \nTable 11  simpleTypes In The PDE Schema\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.1.5.3  Added XML complexTypes\n\n7.1.5.3.1  Table 12 describes each complexType2 added to the PDE schema.  \nTable 12  complexTypes In The PDE Schema\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.2  Requirements For PDE Schema\n\n7.2.1  This section contains all requirements specified for the PDE Schema. $\\ P 7 . 1$ above is included for documentation purposes.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.2.2  Checksum Calculation\n\n7.2.2.1  The method for calculation of checksum values is specified by the SEMI E139 RaP standard to be MD5. The MD5 calculation processes a sequence of bytes (or octets) to yield the checksum value.  This section specifies that sequence of bytes for the PDE and external PDEbody.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.2.2.2  PDE Checksum (Part 1)\n\nTitle: SEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.2.2.2  PDE Checksum\n\nContent: 7.2.2.2.1 The PDE checksum element value shall be calculated based on the XML instance document for the PDE. This applies to PDEs that have internal PDEbodies and also to those that do not. 7.2.2.2.2 XML documents can contain white space and layout information that is independent of the XML content. So, two XML documents that have identical XML content might not be identical byte for byte. Allowance has been made for these differences. 7.2.2.2.3 The W3C recommendation xml-c14n (http://www.w3c.org/TR/xml-c14n) defines a method for creating a canonical form of an XML document. This canonicalization process eliminates the white space and layout information from the checksum calculation. The xml-c14n recommendation shall be applied in the following way: The checksum calculation shall be performed on a canonicalized form of the RaP:PDE element. The computation of the checksum shall be equivalent to the procedure described below: o In the RaP:PDE element of the original PDE replace the value of the 'checksum' element by 00000000000000000000000000000000\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.2.2.2  PDE Checksum (Part 2)\n\nTitle: SEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.2.2.2  PDE Checksum\n\nContent: (that is, 32 zeroes). o Convert the modified PDE element to its canonical form according to W3C recommendation xml-c14n without comments (that is, the “with comments” option is not used). This yields an octet stream encoded in UTF-8. o Apply the MD5 algorithm to the resulting octet stream to compute the checksum. 7.2.2.2.4 The resulting checksum value can be used as needed. For example, if a new PDE is being created, the value may be placed into the checksum element. For an existing PDE, the value may be compared with the existing value of the checksum element to determine if the content is unchanged.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.2.2.3  PDEbody BodyChecksum\n\n7.2.2.3.1  The format of an external PDEbody is determined by the equipment supplier.  In this case, the entire PDEbody content as contained within TransferContainer shall be included in the checksum calculation process.  The calculation method for the bodyChecksum attribute of the PDEbodyReference element is MD5 as specified by the $\\operatorname { E 1 3 9 } \\operatorname { R a P }$ standard.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 7.2.3  XML Schema\n\n7.2.3.1  All PDE instance documents shall conform to the XML schema document named:\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # E139-1.V0705.RaP.PDE.xsd\n\n7.2.3.2  The contents of the above-mentioned schema document constitute a core part of this specification.  This schema document should be provided with this document.  \n7.2.3.3  In addition, all PDE instance documents shall conform to all requirements related to the PDE content as specified in SEMI E139.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 8.1  Manifest Mapping to XML\n\n8.1.1  This section describes how the Manifest definition from SEMI E139 is mapped to XML.  The descriptions in this section are provided to support and explain the XML schema document (attached, see $\\ P 8 . 2 )$ .  This section contains no requirements.  Specific requirements are included in $\\ P 8 . 2$ .\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 8.1.2  Manifest Class\n\n8.1.2.1  SEMI E139 does not represent the Manifest in UML.  To facilitate creation of the Manifest schema, the Manifest itself is treated as a single class containing an unordered sequence of Entries.  \n8.1.2.2  The first two columns of the Translation Table for this Manifest class (Table 13) hold little information because this class was not explicitly defined in SEMI E139.  However, the second two columns describe the XML form of the Manifest class.  Figure 11 shows the XML form of the Manifest.  \nTable 13  Translation Table For Manifest Class\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 8.1.3  XML simpleTypes\n\n8.1.3.1  Table 11 describes each simpleType added to the XML schema for the Manifest.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 8.2  Requirements For Manifest Schema\n\n8.2.1  This section contains all requirements specified for the PDE Schema.  ¶8.1 above is included for documentation purposes.  \n8.2.2  All Manifest instance documents shall conform to the XML schema document named:\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # E139-1.V0705.RaP.Manifest.xsd\n\n8.2.3  The contents of the above-mentioned schema document constitute a core part of this specification.  This schema document should be provided with this document.  \n8.2.4  In addition, all Manifest instance documents shall conform to all requirements related to the Manifest content as specified in SEMI E139.\n\nSEMI E139.1-0705 XML SCHEMA FOR THE RaP PDE - # 9  Related Documents\n\nRivest, Ronald, The MD5 Message-Digest Algorithm, IETF RFC: 1992  http://www.ietf.org/rfc/rfc1321.txt.  \nNOTICE: SEMI makes no warranties or representations as to the suitability of the standards set forth herein for any particular application. The determination of the suitability of the standard is solely the responsibility of the user. Users are cautioned to refer to manufacturer's instructions, product labels, product data sheets, and other relevant literature, respecting any materials or equipment mentioned herein. These standards are subject to change without notice.  \nBy publication of this standard, Semiconductor Equipment and Materials International (SEMI) takes no position respecting the validity of any patent rights or copyrights asserted in connection with any items mentioned in this standard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and the risk of infringement of such rights are entirely their own responsibility.\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING\n\nThis specification was technically approved by the Global Information & Control Committee and is the direct responsibility of the North American Information & Control Committee.  Current edition approved by the North American Regional Standards Committee on December 10, 2004.  Initially available at www.semi.org January 2005; to be published March 2005.  \nNOTICE:  The designation of SEMI M55 was updated during the 0705 publishing cycle to reflect the creation of SEMI E142.1.\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 1  Purpose\n\n1.1  This document defines the data items that are required to report, store and transmit map data for substrates such as wafers, frames, strips and trays.\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 2  Scope\n\n2.1  This version of the document applies to the substrate types; wafers, frames, strips and trays.  \n2.2  This document addresses assembly and packaging including the testing of semiconductor devices.  \nNOTICE: This standard does not purport to address safety issues, if any, associated with its use.  It is the responsibility of the users of this standard to establish appropriate safety and health practices and determine the applicability of regulatory or other limitations prior to use.\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 3  Limitations\n\n3.1  This document does not address the transmission, file naming conventions, storage or archiving of substrate maps.  These will be addressed in sub-documents of this specification.\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 4  Referenced Standards\n\n4.1  SEMI Standards  \nSEMI E39 — Object Services Standard; Concept, Behavior and Services  \nNOTICE: Unless otherwise indicated, all documents cited shall be the latest published versions.\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 5  Terminology\n\n5.1  Definitions  \n5.1.1  bottom side — the bottom side of the substrate as defined in the corresponding Appendix (Appendix 1, 2, or 3).\n5.1.2  device — the unit to which the device status code in the map is assigned including, but not limited to: die on a wafer, multi-chip modules, and packages.\n5.1.3  map — a two-dimensional array of bin codes derived from electrical test data of a substrate including, but not limited to: wafer, tray, strip, or tape.\n5.1.4  substrate — any carrier of a two-dimensional array of devices including, but not limited to: wafers, trays, strips, tape, panels, or boards.\n5.1.5  top side — the top side of the substrate as defined in the corresponding Appendix for that substrate (Appendix 1, 2, or 3).\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 6  Requirements\n\n6.1   This standard defines the data items that are required in a substrate map.  This standard places no special requirements on the file naming conventions, storage, or archiving of substrate maps.\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 7  Conventions (Part 1)\n\nTitle: SEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 7  Conventions\n\nContent: 7.1 Object Conventions — This document conforms to the conventions for objects established by SEMI E39, including object diagrams, object terminology, and requirements for standardized objects. Accordingly, notation is based on Unified Modeling Language (UML). 7.2 Object Attribute Representation — The object information models for standardized objects will be supported by an attribute definition table with the following column headings: 7.2.1 The Access column uses RO (Read Only) or RW (Read and Write) to indicate the access that service-users have to the attribute. 7.2.2 A ‘Y’ or ‘N’ in the requirement (Rqmt) column indicates if this attribute must be supported in order to meet fundamental compliance for the service. 7.2.2.1 The Form column is used to indicate the format of the attribute. 7.2.3 Formal Name of an Object — The text capitalizes formal object name references. Similar to the way capitalization is normally used when discussing entities. When describing something in the general (like cities) lower case is used, but when a specific\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 7  Conventions (Part 2)\n\nTitle: SEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 7  Conventions\n\nContent: entity is of interest (New York City), then first letters are capitalized. 7.2.4 Components of Complex Attributes — The names of object attributes defined in tables are left-justified. The individual elements of complex attributes are right-justified in order of appearance below the complex attribute. 7.3 Service Message Representation — Services are functions or methods that may be provided by either the equipment or the host. A service message may be either a request message, which always requires a response, or a notification message, that does not require a response.\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 7.3.1  Service Definition\n\n7.3.1.1  A service definition table defines the specific set of messages for a given service resource, as shown in the following table:  \n7.3.1.2  Type can be either $\\mathbf { \\dot { \\bar { \\rho } } } \\mathbf { N ^ { \\prime } } = \\mathbf { I }$ Notification or “R” $\\mathbf { \\sigma } = \\mathbf { \\sigma }$ Request & Response.  \n7.3.1.3  Notification type messages are initiated by the service provider (e.g., the equipment) and the provider does not expect to get a response from the service user.  Request messages are initiated by a service user (e.g., the host). Request messages ask for data or an activity from the provider.  Request messages expect a specific response message (no presumption on the message content).\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 7.3.2  Service Parameter Dictionary\n\n7.3.2.1  A service parameter dictionary table defines the description, format and its possible value for parameters used by services, as shown in the following table:  \n7.3.2.2  A row is provided in the table for each parameter of a service.\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 7.3.3  Service Message Definition\n\n7.3.3.1  A service message definition table defines the parameters used in a service, as shown in the following table:  \n7.3.3.2  The columns labeled REQ/IND and RSP/CNF link the parameters to the direction of the message. The message sent by the initiator is called the “Request”. The receiver terms this message the “Indication” or the request. The receiver may then send a “Response” which the original sender terms the “Confirmation”.  \n7.3.3.3  The following codes appear in the REQ/IND and RSP/CNF columns and are used in the definition of the parameters (eg., how each parameter is used in each direction):\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 8  Overview\n\n8.1  Substrate maps are two dimensional arrays of data that correspond to a physical substrate which may be a wafer, strip or tray as shown in the Appendices.  It is expected that other substrate types will be added to subsequent releases of this standard.  \n8.2  The data items are defined as attributes of the objects shown in Figure 1 Map Data Object Model.\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 9  MapData\n\n9.1  The MapData object contains a list of zero or more Layout objects, a list of zero or more SubstrateMap objects and a list of zero or more Substrate objects.  \nTable 1  MapData Attributes\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 10  Layout\n\n10.1  The Layout object defines the logical and physical dimensions of two-dimensional array of devices to which a SubstrateMap may be assigned.  A substrate must have a top level layout that defines the size of the substrate itself. Any layout object can reference other child layout objects.  In this way complex assemblies may be represented. See the examples in Related Information 1.  \nTable 2  Layout Attributes  \nTable 3  LogicalCoordinates Type  \nTable 4  XYDimensions Type  \nTable 5  ZDimensions Type\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 11  Substrate\n\n11.1  The Substrate object identifies a substrate to which a SubstrateMap may be assigned.  A Substrate object may have one or more AliasId objects.  \nTable 6  Substrate Attributes\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 11.2  AliasId\n\n11.2.1  The AliasId object contains other substrate identifiers that may be used to trace the substrate throughout the substrate’s life cycle.  \nTable 7  AliasId Attributes\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 12  SubstrateMap\n\n12.1  The SubstrateMap object relates to a single substrate and layout and contains a list of one or more Overlay objects.  It may also include a substrate type specific object depending on the value of [SubstrateType].  \n12.2  If there are more than one SubstrateMap assigned to a Substrate and Layout combination they should differ in either their Orientation, OriginLocation or both.  For example there may be a map for the top side and one for the bottom side of a Layout.  \nTable 8  SubstrateMap Attributes\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 13  Overlay\n\n13.1  The Overlay object is an array of data that corresponds to the dimensions on the Layout to which the containing SubstrateMap is assigned.  The specialized objects (e.g. BinCodeMap, DeviceIdMap, TransferMap) are extensions of the Overlay object which each define a different type of data.  See the definitions of the specialized objects in the sections below.  An Overlay object may have one or more ReferenceDevice objects.  \nTable 9  Overlay Attributes\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 13.2  ReferenceDevice\n\n13.2.1  The ReferenceDevice object defines a reference device on the substrate.\n\nSEMI E142-0705 SPECIFICATION FOR SUBSTRATE MAPPING - # 13.3  BinCodeMap\n\n13.3.1  The BinCodeMap object contains a list of zero or more BinDefinition objects and a list of one or more BinCode objects.  \nTable 11  BinCodeMap Attributes  \n#1  For readability when BinType $\\mathbf { \\tau } = \\mathbf { \\tau }$ ‘Decimal’ there must be spaces added between each device and each row of devices should be on a new line. #2  When BinType $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ ‘Ascii’ or ‘Hexadecimal’ or ‘Integer2’ there must not be spaces between each device and for readability, each row should be on a new line.",
  "images": []
}