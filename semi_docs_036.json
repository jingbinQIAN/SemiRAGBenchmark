[
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.6  Distributed Transactions (Part 3)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.6  Distributed Transactions\n\nContent: the ACID properties of a transaction, the server should be able to return to the state prior to the request for the operation in the event of a failure. In this sense, the server should be recoverable. Failures are either software or hardware events that prevent the completion of the transaction. The server is a recoverable server if it is able to maintain the ACID properties when faced with a failure. 6.6.5 Transactions should be designed in a manner such that they do not span a period of interaction with an external entity such as a person using a GUI or a piece of equipment. Waiting for the response from an external entity can result in locks being held for multiple seconds, minutes, or longer. This can adversely affect other transactions by causing time-outs or deadlocks. These types of transactions can usually be split into multiple serially executed transactions with some small amount of extra revalidation of current states at succeeding transactions. 6.6.6 Coordinating the completion of transactions may involve"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.6  Distributed Transactions (Part 4)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.6  Distributed Transactions\n\nContent: multiple servers and may entail either committing the successfully completed transaction or rolling back the unsuccessful transaction. This activity imposes additional overhead on a system. Suppliers and consumers should assess the impact of transactions on system performance during component design and selection of transactional events. 6.6.7 Transactions may cause physical effects in the manufacturing system that cannot simply be rolled back in accordance with the ACID properties. Application and system designers should include ways to modify the logical view of the system to match the physical reality of the manufacturing floor if such a mismatch occurs. 6.6.8 Transactions can create CIM Framework events as state changes occur. As the transaction may not be committed at the point of event creation, the event should not be visible outside the transaction until the final commit point. The details of performing this task are implementation dependent. For example, the event announcing the completion of a lot at a processing"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.6  Distributed Transactions (Part 5)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.6  Distributed Transactions\n\nContent: step should not be published until the processing step completion transaction is committed. Otherwise, the event could be published, but the transaction subsequently rolled back, creating a system inconsistency. 6.6.9 Transactions should be able to be nested, thus providing the ability to define transactions within other transactions. These sub-transactions can generate additional sub-transactions, thus forming a hierarchy of transactions. In the spirit of maintaining the ACID properties, each sub-transaction can issue a commit or rollback for its piece of work. The results of the subtransaction are only available to the parent transaction. The sub-transactions commit becomes permanent only after it issues a local commit and all ancestors commit. If the parent transaction does a rollback, all descendent transactions are rolled back regardless of any local commits. 6.6.10 There are two types of transactions widely supported for distributed object infrastructures. The OMA support for transactions is described in the OMG’s"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.6  Distributed Transactions (Part 6)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.6  Distributed Transactions\n\nContent: Object Transaction Service (OTS). Microsoft provides support for transactions with its Microsoft Transaction Server (MTS) product. The OTS closely aligns with other standards such as The Open Group Distributed Transaction Processing (DTP) model.7 Using industry standard protocols as a base, the OTS supports interfacing with products from the major database suppliers. Using the provided OTS interfaces and information about The Open Group standards, non-ORB supplied database interfaces could be developed to allow for interoperability with other cooperating transaction services. MTS also supports transactions with major database suppliers through use of The Open Group XA interface. Using the MTS Software Developer Kit, transaction support can be extended to other resources. 6.6.11 Combining heterogeneous components based on a combination of OTS and MTS is not straightfor-ward. Although both rely on the XA interface for dis-tributed transaction coordination, they are not designed to operate with each other. Both OTS and MTS"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.6  Distributed Transactions (Part 7)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.6  Distributed Transactions\n\nContent: hide the details of transactions from users. This makes either solution very convenient, but makes linking them together more difficult. For example, suppose a CORBA-based component adhering to OTS should interact with an MTS-based component. The scenario calls for the CORBA based component to use the XA interface to work with the MTS provided transaction coordinator (see Gray8 for additional information on distributed transactions). However, in hiding XA complexity, OTS also hides the ability to readily specify the transaction coordinator (OTS does this behind the scenes). CIM Framework component developers and consumers should determine the relative need for distributed transactions spanning OTS and MTS against the additional complexity of developing a XA-based mechanism for combined OTS and MTS transactions. 6.6.12 The ACID properties provided by either OTS or MTS may be used for CIM Framework transactions. Many implementation details are supplier specific; however, the major architectural principles have been described"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.6  Distributed Transactions (Part 8)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.6  Distributed Transactions\n\nContent: above."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.7  Component Management",
    "content": "6.7.1  A component refers to a collection of related interfaces that form a coherent subsystem. Components may have a component manager to assist in the tracking and management of the instantiated interfaces (objects). The objects that are managed by a component manager are called managed objects."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.7.2  Component Level Interface",
    "content": "6.7.2.1  Component managers provide services such as reporting on the collection of instances they manage and creating object instances. The component manager provides the following:  \nObject references to managed objects.  \nCollective queries for some aspect (usually a state) across all the objects it manages.  \nServices for:  \nCreating a managed object and returning a reference to it, or receiving an object reference to a newly created object. The component manager then “registers” the object reference.  \nRemoving managed objects.  \nFinding managed objects."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.7.3  Component Manager Classification",
    "content": "6.7.3.1  Component Managers are classified by their allowable number of instances."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.7.3.2  Unique Component Managers",
    "content": "6.7.3.2.1  A unique component manager describes a component manager for which there is only one running instance in an MES implementation. Unique component managers are used when a single point of factory level control or focus is required. An example use of this pattern might be an interface within a Dispatcher component called DispatchingManager. This might be a unique component manager because multiple dispatching systems on the factory floor could create problems with work scheduling."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.7.3.3  Non-Unique Component Managers",
    "content": "6.7.3.3.1  A non-unique component manager describes a component manager for which multiple instances may be running in an installed MES system. The component manager instances are derived from the same code base, but have separate instance data for each running instance. Non-unique component managers should be registered with the factory with some selection criteria in order for a requester to be able to obtain a handle to the correct instance. An example use of this pattern is the scenario in which several ProductManagers are employed within a production system."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8  Architecture For Service Requests",
    "content": "6.8.1  Services are implemented by a factory object that is the service provider. The productive entity in a factory invokes the service methods on that factory object."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.1.1  For example, a recipe server could offer the following interface:",
    "content": "interface RecipeManagementServer // upload a recipe void acceptRecipe( in string recipeName, in Recipe recipe); // download a recipe Recipe provideRecipe(in string recipeName);\n};  \n6.8.1.2  The problem with service requests is that they require a flow from the productive entity to the factory object that provides the service. This kind of reverse flow contradicts the principle of layered architecture by which the productive entity is supposed to be a more primitive entity, unaware of factory objects, their locations and their structures. The trading service addresses this problem."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.1  Using Trading Service",
    "content": "6.8.2.1.1  A trading helps clients to locate services. An object that must locate a service must know how to access the trading service.  \n6.8.2.1.2  A trading service relies on the description of the service itself, rather than any attribute relating to the server that provides the service (such as the name of the server). It must be able to describe the service it requires. The trading server locates a server that fulfills the required service profile.  \nNOTE 3: The trading service described here is based on the CORBA COS Trading Object Service, implementations of which  are available from vendors of CORBA environments. The solution however does not require the full generality of the COS Trading Object Service, and can be viewed as a strict subset of the latter."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.2  The Trading Concept",
    "content": "6.8.2.2.1  A trading scenario is based on a server that exports a service to a trader. The client then imports the service from the trader, receiving a reference to the server on which it can invoke the service.  \n6.8.2.2.2  This is depicted in the following diagram:  \noffer id, through which the server can further manipulate its offer.  \n6.8.2.4.6  Factory service offers are described as follows:"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.4.6.1  Service Type Name",
    "content": "6.8.2.4.6.2  The type is a string naming the service itself. We are yet to agree upon the services supported by this specification. The following are obvious candidates:  \nRecipe Service Wafer Map Service Fixtures Service8  \n6.8.2.2.3  The diagram suggests that the server exports its service to the trader. In practice any object aware of the server and its provided services could assume this job. For example, a factory configuration object could be responsible for exporting all services to the trader."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.3  Trading Service Models",
    "content": "6.8.2.3.1  The trader has to implement two interfaces:  \nThe Register interface allows other objects to register export service offers to the trader. NOTE 4: This interface is used e.g. by the service provider to inform the trader about the services the service provider offers. The Lookup interface allows other objects to lookup the trader for a required service. NOTE 5: This interface is used by e.g. the productive entity to find a service provider for a specific service."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.4  Export Use Cases",
    "content": "6.8.2.4.1  The trader offers an interface named Register, that allows a server to register its services with the trader.  \n6.8.2.4.2  The IDL definitions given below are for illustrative purposes. They are extracted from the COS Trading Object Service specification [OMG]. For clarity, not all services are included here."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.4.3  Exporting a Service",
    "content": "6.8.2.4.4  To export a service, the server uses:  \nOfferId export ( in Object reference, in ServiceTypeName type, in PropertySeq properties\n);  \n6.8.2.4.5  The server passes a reference to itself, and describes its offer by passing in a service type name and a list of properties of the service. The trader answers an"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.4.6.3  Properties (Part 1)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.4.6.3  Properties\n\nContent: 6.8.2.4.6.3.1 Properties are used to characterize and specialize the service. A property is a name/value pair, where the name is a string naming the property, and the value specifies the property value offered by the server. The constraint language defined by the COS Trading Object Service [OMG] limits the type of values to the basic data types (such as numbers, chars, booleans and strings) and sequences of these. 6.8.2.4.6.3.2 The following properties are to be used for registering factory services: “Serviced Productive entities” The value of this property is a list of the ids of the productive entities serviced by this server. This allows multiple servers of the same type to be installed, and partition the productive entity service among the available servers. Note that it does not require the server to know the productive entities it serves, since the server registration can be done by a factory configuration service. “Serviced Areas” The value of this property is a string collection naming the factory areas serviced by the"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.4.6.3  Properties (Part 2)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.4.6.3  Properties\n\nContent: server. This property is another means of partitioning the service among multiple servers. The area could be a name of a cell controller if cellular manufacturing is practiced, or the name of any organizational unit implemented by the factory, and known to the factory configuration service."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.4.7  Withdrawing a Service",
    "content": "6.8.2.4.7.1  To withdraw a registered service, the server (or the configuration service) uses:  \nvoid withdraw ( in OfferId Id);"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.4.8  Querying a Registered Service",
    "content": "6.8.2.4.8.1  A server may query the trader the details of a registered service by passing in the offer id.  \nStruct OfferInfo { Object reference; ServiceTYpeName type; PropertySeq properties;\n};\nOfferInfo describe ( in OfferId id);"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.4.9  Modifying a Registered Service",
    "content": "6.8.2.4.9.1  The server may modify the properties of  a registered service. It may add new properties, delete existing properties, or modify the value of existing properties. This is done using the following method:  \nvoid modify ( in OfferId id, in PropertyNameSeq del_list, in PropertySeq modify_list\n);  \n6.8.2.4.9.2  The properties named in the del_list are deleted. Properties in the modify_list that do not exist are added. Properties in the modify_list that exist, receive a new value.  \n6.8.2.4.9.3  The modify method can be used to support changes in the factory configuration, such as new productive entity being added or deleted, a  productive entity being migrated from one cell to another, a new load balancing policy for the servers installed, etc."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.5  Import Use Cases (Part 1)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.5  Import Use Cases\n\nContent: 6.8.2.5.1 Importing a Service The trader offers an interface named Lookup that clients can use in order to locate a service: void query ( in ServiceTypeName type, in Constraint constr, in Preference pref, in PolicySeq policies, in SpecifiedProps desired_props, in unsigned long how_many, out OfferSeq offers, out OfferIterator offer_itr, out PolicyNameSeq limits_applied ); 6.8.2.5.1.1 The Query in Parameters The “in” parameters are used by the client to specify the service it needs and the policies for searching it. The “type” parameter is key to the central purpose of trading. It specifies the name of the service type the client is interested in. The “constraint” guides the trader on how to select a server based on its registered properties. It is a string that describes the selection in some given constraint language. The typical constraints will select a server for a specific productive entity or for the area the productive entity belongs to. Both possibilities use the “in” operator for testing the inclusion of an element in"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.5  Import Use Cases (Part 2)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.5  Import Use Cases\n\nContent: a set. Some examples follow: “DieAttachXYZ in ServicedProductiveEntities” “Cell22 in ServicedAreas” 6.8.2.5.1.2 “Preferences” specify how should a server be selected in case the query results in more than one answer. It is suggested that this parameter be ignored, which means that the default of first is always used. 6.8.2.5.1.3 The “policies” parameter guides the trader on how to choose a policy for performing the search. Search policies are a rather complicated issue, which can be ignored in the Simple Trader case. 6.8.2.5.1.4 The “desired_props” parameter instructs the trader which properties are to be returned as part of the answer (it does not affect the selection itself). This does not make much sense with the limited set of properties which has been defined, and can also be ignored (use none as the parameter value). 6.8.2.5.1.5 The “how_many” parameter is another way to restrict the number of answers. It is proposed that 1 always be used as the value of this parameter. NOTE 6: Should areas be used as the selection"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.5  Import Use Cases (Part 3)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.5  Import Use Cases\n\nContent: criteria, the equipment must be aware of its area within the factory. This should be supported through the productive entity “Configuration” aspect."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.5.1.6  The Query out Parameters",
    "content": "6.8.2.5.1.6.1  The query returns the selected servers in one of two forms: a collection of services or a reference to an iterator through which the returned servers can be obtained. The second method is designed for queries that may return a large number of offers. One can always assume that results are returned within the first out parameter (out OfferSeq offers), namely a sequence of offers.  Furthermore, having specified 1 as the value of the “how_many” parameter, it is ensured that the answered sequence contains at most one element."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.6  Locating the Trading  Service",
    "content": "6.8.2.6.1  The productive entity locates the services it requires using a trading service."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.6.2  A client can obtain a reference to the trading service by invoking the following method on the ORB:",
    "content": "Object resolve_initial_references in ObjectId identifier)^ raises (InvalidName);"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # Where:",
    "content": "the reserved name “TradingService” is passed as the identifier."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.7  A Usage Scenario Example (Part 1)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.7  A Usage Scenario Example\n\nContent: 6.8.2.7.1 Here is an example of a usage scenario. 6.8.2.7.2 In common factory practice, cellular manufacturing has a factory configuration service responsible (among other things) for exporting the factory services to the trading service. The following are some typical use cases: 1. The factory configuration service registers a wafer map server to server two cells named CellA and CellB. The factory configuration service obtains an initial reference to the trading service from the ORB: trader $\\mathbf { \\Sigma } =$ orb.resolve_initial_refer ences(“TradingService”); The trader answers its Register interface: traderRegistry $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ trader.register_if(); The factory configuration service builds properties as a single-itemed sequence of containing one name/value pair whose name is “ServicedAreas” and whose value is a sequence of the cell names { “CellA”, ‚ CellB”} . It then uses the Register interface of the Trading Service to register the service offer: traderRegistry.export("
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.7  A Usage Scenario Example (Part 2)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 6.8.2.7  A Usage Scenario Example\n\nContent: waferMapServer,”Wafer Map Service”, properties); 2. The configuration manager informs a Die Attach equipment that it belongs to CellA. ProductiveEntities.setArea(“CellA”); 3. The Die Attach needs a wafer map. It obtains an initial reference to the trading service from the ORB: trader $\\mathbf { \\Sigma } =$ orb.resolve_initial_refer ences(“TradingService”); The trader answers its Lookup interface: traderLookup $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ trader.lookup_if(); The productive entity looks up the trading service for the wafer map service: traderLookup.query( “Wafer Map Service”, “CellA in ServicedAreas”, pref, policies, desired_props, 1, preference, offers, offers_itr, limits_applied); The wafer map server is returned as the first element of the offers sequence. The productive entity may keep the reference to the wafer map server for future use. 4. The Die Attach can now invoke the service on the wafer map server: waferMapServer.getWaferMap(…);"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 7  Technical Architecture Conformance",
    "content": "7.1  Conformance is defined as “adherence to a standard or specification in the implementation of a product, process, or service.” A conforming implementation should have an associated implementation conformance statement that details the capabilities that have been implemented. While recognizing that the CIM Framework is, by definition, not a complete specification of a MES, a guide for technical architecture defines conformance for each of its major requirements as follows."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 7.2  Distributed Object Communications Conformance",
    "content": "7.2.1  The CIM Framework object model is based on the ability to issue service requests to a component object and to subscribe to events published by the component object. Component suppliers should explain how these two forms of communications are accomplished so consumers can assess the ease and feasibility of integrating a component into the factory MES. Example terminology specific to semiconductor manufacturing is provided for clarity. It does not preclude application specialization for other industries."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 7.3  Exception Conformance",
    "content": "7.3.1  Alerting operation requesters of abnormal outcomes is essential for robust implementations. Component suppliers should explain how their implementations support raising specified system and user-defined exceptions."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 7.4  Event Specification Conformance",
    "content": "7.4.1  Notification of asynchronous occurrences is a cornerstone of distributed event-driven application domains such as MES. Suppliers should explain how their components support event delivery, including the registration of event suppliers, event consumers and the provision for Event Broker features for event filtering."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 7.5  Distributed Transaction Conformance",
    "content": "7.5.1  Ensuring consistent state changes among components is a key concern in the integration of a factory MES. Component suppliers should explain how their components support transactional units of work."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 7.6  Component Management Conformance",
    "content": "7.6.1  Component suppliers should explain how object instances are managed. This includes how the object is identified, constructed, accessed, and destroyed (or flattened in the case of a persistent object). It also includes  \nmechanisms for query or lookup of specific managed object instances."
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 7.7  General Rules for CIM Framework Conformance (Part 1)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 7.7  General Rules for CIM Framework Conformance\n\nContent: 7.7.1 The following rules define the general expectations for technical conformance to any CIM Framework specification. Suppliers should provide documentation explaining any deviations from these general rules. All CIM Framework-defined operations for an interface should be supported. All exceptions and events for an interface should be supported. A component should use component manager interfaces for object instance creation and regis tration where these operations are specified. A component implementation should support all interfaces specified for that component. An application may not add states and transitions to the defined dynamic models that have external interfacing ramifications. The application may still further subdivide the states. A component implementation should explain how it supports substitutability. For example, it may support different degrees of substitutability between the following levels: Strict — An application that supplies a CIM Framework component should be reconfigurable so"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 7.7  General Rules for CIM Framework Conformance (Part 2)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 7.7  General Rules for CIM Framework Conformance\n\nContent: it can use another supplier’s implementation of that component. The application’s interactions with the component are restricted to CIM Framework defined interfaces. Weak — An application may use extended, pro-prietary, or private interfaces of a component. When the another supplier’s implementation is substituted for an installed component, any components using the extended, proprietary, or private interfaces need to be reassessed and possibly modified. The use of the CIM Frame-work-defined interfaces does not change. NOTICE: SEMI makes no warranties or representations as to the suitability of the standard set forth herein for any particular application. The determination of the suitability of the standard is solely the responsibility of the user. Users are cautioned to refer to manufacturer’s instructions, product labels, product data sheets, and other relevant literature respecting any materials mentioned herein. These standards are subject to change without notice. The user’s attention is called to"
  },
  {
    "title": "SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 7.7  General Rules for CIM Framework Conformance (Part 3)",
    "content": "Title: SEMI E96-1101 GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE - # 7.7  General Rules for CIM Framework Conformance\n\nContent: the possibility that compliance with this standard may require use of copyrighted material or of an invention covered by patent rights. By publication of this standard, SEMI takes no position respecting the validity of any patent rights or copyrights asserted in connection with any item mentioned in this standard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and the risk of infringement of such rights, are entirely their own responsibility."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES",
    "content": "This provisional specification was technically approved by the Global Information and Control Committee and is the direct responsibility of the North American Information and Control Committee. Current edition approved by the North American Regional Standards Committee on October 21 and December 15, 1999. Initially available at www.semi.org January 2000; to be published February 2000.  \nNOTE: This document was published twice during the February 2000 (0200) publishing cycle.  \nresource maintenance jobs and factory jobs that drive product material through their process flows."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 1  Purpose",
    "content": "1.1  This document defines the glo bal declarations used by all other components of the CIM Framework and also specifies the common architecture patterns that serve to functionally integrate CIM Framework components. The material architecture defines functionality common to product management, durables management and consumables management components. The factory resource architecture defines relationships and common functionality of a variety of factory resources. The job architecture defines a factory-wide model for controlling factory jobs that drive a variety of manufacturing tasks. These specifications are separated into a distinct group to enable them to be specified once and then logically included or inherited wherever they are subsequently needed."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 2  Scope (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 2  Scope\n\nContent: 2.1 This specification provides the common interfaces required by Manufacturing Execution Systems to: Provide type definitions for common data structures to ensure consistent representation. These items include data types for common concepts such as coordinates, priorities, timestamps, and sequences of basic data types. Provide definitions for common exceptions used consistently throughout the CIM Framework. Provide the material architecture interfaces common to identifying, grouping, moving, locating and tracking material in the factory. Provide the factory resource architecture interfaces common to defining, organizing, tracking usage of and maintaining factory resources including equipment, sensors, durables, and people. Provide the job architecture interfaces common to creating, executing and managing work in the factory. The job architecture is specialized for material processing jobs, material transport jobs, 2.2 This standard does not purport to address safety issues, if any, associated with its"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 2  Scope (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 2  Scope\n\nContent: use. It is the responsibility of the users of this standard to establish appropriate safety and health practices and determine the applicability of regulatory limitations prior to use."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 3.1  Provisional Status (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 3.1  Provisional Status\n\nContent: 3.1.1 This specification is designate d as provisional due to known areas that need to be completed. The following items summarize the deficiencies of the provisional specification to be addressed before a subsequent ballot to upgrade it to full standard status. 3.1.2 The specification uses the IDL typedef “any” in several places. While this usage provides flexibility, it can have the effect of reducing interoperability due to differences in interpretation of the value provided by separate implementations that interact through a standard interface. The “any” typedefs should be replaced with explicit data types prior to upgrade from Provisional to full Standard status. 3.1.3 The definition of interfaces for retrieval of history associated with CIM Framework objects may need to be added to abstract interfaces in this document after the complete specification for the history facility within the CIM Framework Factory Services Component. 3.1.4 The specification of CIM Framework states"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 3.1  Provisional Status (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 3.1  Provisional Status\n\nContent: reported through published state change events is currently based on a type definition for an enumeration of state values. There may be alternate representations for states that are better able to capture the semantics of nested and parallel states. The state representation used for the CIM Framework will be reviewed and possibly changed before upgrade to full standard status. 3.1.5 The Resource model defined i n SEMI E81 includes several extensions that are not yet included in this specification. These extensions include composition of resources from other resources, capabilities associated with resources, and associations with tracking and maintenance functions for resources. These extensions will be addressed before upgrade to full standard status. 3.1.6 The interfaces specified for M ESFactory, Area, and ComponentManager are included in the E81 responsibilities for the Factory Component within Factory Operations. These interfaces will need to be moved to that component when it is"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 3.1  Provisional Status (Part 3)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 3.1  Provisional Status\n\nContent: considered in a future ballot."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 4.1  SEMI Standards",
    "content": "SEMI E5 — SEMI Equipment Communications Standard 2 Message Content (SECS-II)  \nSEMI E10 Standard for Definition and Measurement of Equipment Reliability, Availability, and Maintainability (RAM)  \nSEMI E81 — Provisional Specification for CIM Framework Domain Architecture"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 4.2  Other Standards",
    "content": "UML Notation Guide, Version 1.1, document number ad/97-08-05, Object Management Group  \nISO/IEC International Standard 14750 (also ITU-T Recommendation X.920) –– Information Technology – Open Distributed Processing – Interface Definition Language 2  \nNOTE 1: As listed or revised, all documents cited shall be the latest publications of adopted standards."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 5  Terminology",
    "content": "5.1  abstract interface — an interfa ce specified only for inheritance rather than for implementation in order to standardize common features shared by all specializations of the interface."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions\n\nContent: 6.1.1 This section describes data type definitions and exceptions that are global in nature. By “global” it is meant that they are designed to be used by any component within the CIM Framework. This specification does not address how they are implemented within a CIM Framework conformant application; that level of detail is within the realm of the development effort. 6.1.2 Global type definitions are spe cified as IDL declarations which may be referenced by any CIM Framework interface. The CIM Framework uses the keyword typedef to define aliases for basic object types, but with additional implied semantics. (e.g., the units typedef defines a string, whose contents conform to definitions found in SEMI E5). The keyword struct begins the type declaration for record structures composed of a collection of named and typed values. The third form of type definition is an enumerated type beginning with the reserved word enum. Enumerated types are used to declare a list of tokens that can be"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions\n\nContent: used as values of that type. Enumerated types are mainly used to denote the states of an object for communication in CIM Framework events. Finally, collections of values are declared with the keyword sequence. This kind of type definition may or may not imply significance to the ordering of the members in the sequence. Where no ordering constraint is mentioned, the elements of the sequence are not assumed to be in any meaningful order. NOTE 2: In the following definitions, “//” or “/\\* .... \\*/” delimits a comment. NOTE TO THE READER: The comments in the following sections (described in NOTE 2, above) appear to immediately precede, rather than follow, the items they discuss. — SEMI Staff 6.1.3 All CIM Framework specifica tions will be declared within the context of the CIMFW module which spans all of the components of the CIM Framework. Within the CIMFW module, the global type definitions will be declared within a second-level module called Global. Module: Global typedef string"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions (Part 3)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions\n\nContent: Identifier; typedef unsigned long Flags; struct NamedValue { Identifier name; any argument; long len; Flags arg_modes; }; typedef NamedValue NameValue; typedef sequence <NamedValue> NameValueSequence; typedef string PropertyName; struct Property { PropertyName property_name; any property_value; }; typedef sequence <Property> Properties; $/ ^ { * }$ This type definition represents units for factory parameters, measurements. etc., and conforms to the SEMI E5 standard for representation of units. In that standard, the string contains a code representing a value of the units. For example, “ns” would mean nano-seconds; “A” for ampere; and “wfr” for wafer. $^ { * } /$ typedef string Unit; typedef string Units; $/ ^ { * }$ This type definition represents a sequence of string values. \\*/ typedef sequence <string> StringSequence; /\\* This type definition represents a sequence of any values. \\*/ typedef sequence <any> AnySequence; /\\* This type definition represents a sequence of long values."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions (Part 4)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions\n\nContent: \\*/ typedef sequence <long> LongSequence; $/ ^ { * }$ This enumerated type identifies event priorities and is used in each event definition. \\*/ enum PriorityOfEvent { Low, Medium, High, Alarm }; $/ ^ { * }$ This enumerated type identifies the lifecycle states that an object may go through. It is used in event notifications of state changes. \\*/ enum LifecycleState { Undefined, Created, Deleted, Moved, Copied }; /\\* This enumerated type identifies the states of objects that can be reserved (Lot, Durable and Machine). It is used in event notifications of state changes. \\*/ enum ReservationState { UndefinedReservationState, Reserved, UnReserved }; $/ ^ { * }$ This enumerated type represents the SEMI E10 states for Machines and Support Resources. It is used in event notifications of state changes. \\*/ enum E10State { E10Productive, E10Standby, E10Engineering, E10ScheduledDowntime, E10UnscheduledDowntime, E10NonscheduledTime }; /\\* TimeT is a ulonglong value (64 bits) that represents"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions (Part 5)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions\n\nContent: the number of 100 nanosecond increments that have passed since a base time (October 15, 1582 at 00:00, the Universal Time Representation which refers to time in Greenwich Mean Time). The specification for TimeT is: \\*/ struct ulonglong { unsigned long low; unsigned long high; }; typedef ulonglong TimeT; /\\* TimeStamp is mapped to the data type of TimeT. \\*/ typedef TimeT TimeStamp; typedef sequence <TimeStamp> TimeStampSequence; $/ ^ { * }$ The notion of a specific interval of time denoting a start time and an end time is represented as a struct called IntervalT. \\*/ struct IntervalT { TimeT lower_bound ; TimeT upper_bound ; }; /\\* TimeWindow is mapped to the data type IntervalT. \\*/ typedef IntervalT TimeWindow; $/ ^ { * }$ Duration is mapped to the datatype TimeT. \\*/ typedef TimeT Duration; /\\* This structure is for the representation of a single schedule instance. It should be noted that “EndTime” should never proceed “StartTime.” \\*/ struct ResourceSchedule { TimeStamp"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions (Part 6)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions\n\nContent: plannedStartTime; TimeStamp plannedEndTime; TimeStamp actualStartTime; TimeStamp actualEndTime; }; $/ ^ { * }$ The definition of a sequence of ResourceSchedules. This sequence is ordered in increasing time order and that order must be maintained in any manipulation of the sequence. \\*/ typedef sequence <ResourceSchedule> ResourceScheduleSequence; 6.2 Global Exception Declaration s 6.2.1 This section describes the stan dard CIM Framework exceptions that may be thrown by operations in any component. Module: Global $/ ^ { * }$ This signal is raised when a lookup or find fails. \\*/ exception NotFoundSignal { string errorMessage; }; $/ ^ { * }$ This signal is raised when an add fails because an object already exists with the given identifier. Interfaces may also define and raise a <ObjectType>DuplicateSignal. \\*/ exception DuplicateIdentifierSignal { string errorMessage; string duplicateIdentifier; }; /\\*This signal is raised when an invalid state transition request is made of an object."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions (Part 7)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions\n\nContent: \\*/ exception InvalidStateTransitionSignal { string errorMessage; }; /\\*This signal is raised when a “set” attribute contains a value out of range. \\*/ exception SetValueOutOfRangeSignal { string errorMessage; }; $/ ^ { * }$ This signal is raised when an incorrect TimePeriod is used. \\*/ exception TimePeriodInvalidSignal { string errorMessage; }; /\\* This signal is raised when a Property name is not valid. \\*/ exception InvalidPropertyNameSignal {}; /\\* This signal is raised when a a Property with this name is not defined. \\*/ exception PropertyNotFoundSignal {}; $/ ^ { * }$ This signal is raised when a Property is not supported. \\*/ exception UnsupportedPropertySignal {}; /\\* This signal is raised when a Property is read-only and cannot be set. \\*/ exception ReadOnlyPropertySignal {}; $/ ^ { * }$ This signal is raised when no other defined signal matches the error condition. \\*/ exception FrameworkErrorSignal { string errorMessage; unsigned long errorCode; any errorInformation; };"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions (Part 8)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions\n\nContent: /\\* Definition of fields for FrameworkErrorSignal: errorMessage is a text field representing a description of the circumstances of the exception for use by developers in debugging the exception. errorCode is a numeric field representing the code for the given exception. errorInformation is any further debugging information related to the circumstances of the exception. The errorCode has certain reserved values that are defined and standardized in the CIM Framework. 0000–0999 reserved for the CIM Framework. 1000–1999 reserved for extensions to the CIM Framework. 2000–2999 reserved for specializations of CIM Framework interfaces. 3000–maximum reserved for implementers. /\\* $/ ^ { * }$ This errorCode should be used for any operation where the supplier has chosen to not provide implementation, but needs to communicate to the user that nothing has happened as a result of this operation invocation. \\*/ const unsigned long NOT_IMPLEMENTED $\\mathbf { \\tau } = \\mathbf { \\tau } _ { 0 } ;$ $/"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions (Part 9)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions\n\nContent: ^ { * }$ This errorCode should be used for any operation where the supplier assumes a specialization will implement this operation. If this exception is received, the user will realize that an interface has not been properly specialized. $^ { * } I$ const unsigned long IMPLEMENTED_BY_SUBCLASS $\\mathbf { \\Sigma } = \\mathbf { \\Sigma } _ { 1 }$ ; $/ ^ { * }$ This errorCode should be used for any operation where an unknown exception has been caught by the implementation and, rather than crashing, the implementation can map the “unknown” exception into this known exception. This probably does not aid in program debugging but does prevent program crashing. \\*/ const unsigned long UNKNOWN_EXCEPTION = 2; $/ ^ { * }$ This errorCode should be used for any invocation where some unknown error has occurred that left the server object in an ambiguous state. $^ { * } I$ const unsigned long COMPLETION_UNKNOWN $= 3$ ; 6.3 Abstract Interface Type Defini tions 6.3.1 Referenced Declarations 6.3.1.1 The"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions (Part 10)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.1  Global Type Definitions\n\nContent: following declarations are not part of this specification, but are required for reference by Abstract Interface elements. These referenced declarations are defined in separate documents but are noted here as dependencies that appear in IDL compilations. Module: EquipmentTracking Interface: Machine module EquipmentTracking { interface Machine {}; // Stub typedef sequence <Machine> MachineSequence; exception MachineDuplicateSignal { }; exception MachineNotAssignedSignal { }; exception MachineRemovalFailedSignal { }; }; // module EquipmentTracking Module: Labor Interface: Person module Labor { interface Person {}; // Stub typedef sequence <Person> PersonSequence; exception PersonDuplicateSignal { }; exception PersonNotAssignedSignal { }; exception PersonRemovalFailedSignal { }; }; // module Labor"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.3.2  Abstract Interface Declaration s",
    "content": "Module: AbstractIF  \n/\\* The following IDL interfaces will be fully defined in the sections below. They are declared here as forward references to support the sequence typedefs. \\*/  \ninterface Resource;\ninterface Material;\ninterface MaterialGroup;\ninterface JobSupervisor;\ninterface Job;\ninterface JobRequestor;\n/\\* Type definitions for sequences of interfaces instances. \\*/ typedef sequence <Resource> ResourceSequence;\ntypedef sequence <Material> MaterialSequence;\ntypedef sequence <MaterialGroup> MaterialGroupSequence;\ntypedef sequence <Job> JobSequence;\ntypedef sequence <JobSupervisor> JobSupervisorSequence;"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.4  Resource Abstract Interface G roup",
    "content": "6.4.1  The Resource Abstract Interfa ce Group provides a set of abstractions that are globally useful. Figure 1 is the Information Model for the Resource Abstract Interface Group."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Resource Abstract Interface Group",
    "content": "6.4.1.1  All CIM Framework interfaces will inherit from one of the interfaces shown in Figure 1. NamedEntity provides the most basic naming functions. An OwnedEntity is a NamedEntity with functions supporting the concept of ownership. A Resource is an OwnedEntity which also takes an active role in product manufacturing.  \n6.4.2  Named Entity Interface  \nProvided Services:  \ninterface NamedEntity {  \n/\\* Set and get the name. The NamedEntity interface does not specify scoping of names or enforce uniqueness of names. This could allow distinct instances of a NamedEntity to use the same string as a name. \\*/  \nvoid setName (in string name) raises (Global::FrameworkErrorSignal);\nstring getName ( ) raises (Global::FrameworkErrorSignal);\n/\\* Tests the equality of the name with the name provided as an argument. \\*/\nboolean isNamed (in string testName) raises (Global::FrameworkErrorSignal);"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // NamedEntity",
    "content": "Contracted Services: None.  \nDynamic Model: None.  \n6.4.3  Owned Entity Interface  \n6.4.3.1  The concept of ownership in th e CIM Framework relates to the hierarchical structure that may be defined where one object “owns” another object. This should not be confused with the business concept of ownership relating to an item’s value as an asset.  \nModule:  \nAbstractIF  \nInterface:  \nInherited Interface:  \nNamedEntity  \nDescription:  \nThe abstract interface OwnedEntity provides for the concept of an “owned” entity. There may be only one “owner” for each instance of an OwnedEntity. The OwnedEntity is able to communicate with the owner to request services, or forward information of interest. To build a “parts of” hierarchy, a series of ownerships can be established.  \nExceptions: None.\nPublished Events: None.  \nProvided Services:  \ninterface OwnedEntity : NamedEntity {  \n/\\* Set and get owner. \\*/  \nvoid setOwner (in NamedEntity owner) raises (Global::FrameworkErrorSignal);  \nNamedEntity getOwner ( ) raises (Global::FrameworkErrorSignal);"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: Contracted Services: None. Dynamic Model: None. 6.4.4 Resource Interface Module: AbstractIF Interface: Resource Inherited Interface: OwnedEntity Description: Resource is an abstract inherited interface for any entity in the factory that takes an active role in advancing a product along its manufacturing life cycle (adds value). This includes the factory itself, personnel, production, planning and scheduling resources, and all of the machines used for processing, transporting, and storing materials. Resource provides a common set of services for monitoring and control. Resource uses the NamedEntity and OwnedEntity characteristics together to allow for the building of resource hierarchies. There must be a clear division between the state of the Resource and the condition of the physical entity which the Resource represents. For instance, a Machine is a resource, but the fact that it is “Out of Service” may not mean the physical equipment is shutdown on the shop floor. In fact, the equipment may"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: be operating in manual mode. The Resource state represents the availability of the Resource object to accept work for the factory system. Exceptions: None. Published Events: None. Provided Services: interface Resource : OwnedEntity { /\\* Perform the startup activities for this Resource. Should be implemented by Resource specializations. \\*/ void startUp ( ) raises (Global::FrameworkErrorSignal); $/ ^ { * }$ Perform normal shutdown activities for this Resource. Normal is defined as allowing the Resource to complete any current activities and “gracefully” shutdown. \\*/ void shutdownNormal ( ) raises (Global::FrameworkErrorSignal); $/ ^ { * }$ Perform immediate shutdown activities for this Resource. Immediate is defined as aborting or terminating any current activities and stopping activity as soon as possible. This should be implemented by Resource specializations. \\*/ void shutdownImmediate ( ) raises (Global::FrameworkErrorSignal); $/ ^ { * }$ Respond with the receiver’s level in the Resource"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 3)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: hierarchy. Resource specifies that each different type of Resource provide a “resourceLevel” identifier. string resourceLevel ( ) raises (Global::FrameworkErrorSignal); $/ ^ { * }$ The following service provides name scoping for Resources. Resource name scoping makes use of the notion of “Resource level” and the ownership hierarchy. For example, unique identification of MachineResources within a Machine is possible, but to identify them outside the Machine additional information about their ownership will be required. Thus: nameQualifiedTo (“Machine”) sent to the ProcessResource named “Chamber” answers “TestMachine>Chamber”. If the Machine was owned by a Factory named “TestFactory”, then: nameQualifiedTo (“Factory”) sent to the ProcessResource answers “TestFactory>TestMachine>Chamber” where the ProcessResource has now been uniquely identified for the given Factory. There is no limit to the number of levels that may be addressed this way. Based on the implementations of nameQualifiedTo"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 4)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: (string); a name need not always be concatenated, if a particular Resource level is not applicable to identification. $^ { * } /$ string nameQualifiedTo (in string resourceLevel) raises (Global::FrameworkErrorSignal); /\\* Returns the set of subordinate Resources for a given Resource. \\*/ ResourceSequence subResources ( ) raises (Global::FrameworkErrorSignal); /\\* Answer if the resource is in service. In service means the resource is functional and ready to accept and perform its normal tasks. Derivatives of Resource are expected to expand this state (e.g., add sub-interfaces) that explicitly deal with such additional issues as capacity, “normal” work versus maintenance, etc. \\*/ boolean isInService ( ); $/ ^ { * }$ Answer if the resource is out of service. Out of service means the resource is unable to accept or begin new tasks. Previously begun tasks may continue in some cases. \\*/ boolean isOutOfService ( ); }; // Resource Contracted Services: None. Dynamic Model: Implementations of Resource"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 5)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: may extend the state model by providing additional sub-states that are wholly contained within a state defined here. Extending the state model by the addition of state transitions is also an option for subtypes of Resource. Table 1 Resource State Definitions and Query Table Table 2 Resource State Transitions"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.5  Material Abstract Interface Gr oup",
    "content": "6.5.1  The CIM Framework uses a co mmon architecture for identifying, grouping and locating materials. Any material has an identification, history, location, and associations to any material containers that contain it. Material can also be in multiple material groups that physically (same location or carrier) or logically (same lot, same process batch, same product family, etc.) associate material. Specializations of material include products, durables and consumables. Specializations of material groups include product groups, lots, and process groups."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.5.2  Material Interface (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.5.2  Material Interface\n\nContent: Module: AbstractIF Interface: Material Inherited Interface: NamedEntity Description: Material is an abstract interface for physical items or substances that are required as inputs to the manufacturing process. This includes the product itself, consumables and durables used in the manufacturing process. It does not include the resources used to transform material into product. Exceptions: None. Published Events: None. Provided Services: interface Material : NamedEntity { $/ ^ { * }$ Set and get the identifier for this material. The identifier is unique within the extent of all material for an MES Factory. \\*/ string getIdentifier ( ) raises (Global::FrameworkErrorSignal); void setIdentifier (in string identifier) raises (Global::FrameworkErrorSignal, Global::DuplicateIdentifierSignal); /\\* Returns the material groups of which the receiver is a member. \\*/ MaterialGroupSequence materialGroups ( ) raises (Global::FrameworkErrorSignal); /\\* Answers whether the receiver is a member of the"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.5.2  Material Interface (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.5.2  Material Interface\n\nContent: material group indicated by the argument. \\*/ boolean isMemberOf (in MaterialGroup aMaterialGroup) raises (Global::FrameworkErrorSignal);"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // Material (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // Material\n\nContent: Dynamic Model: None. 6.5.3 Material Group Interface Module: AbstractIF Interface: MaterialGroup Inherited Interface: NamedEntity Description: MaterialGroup is the abstract interface for any aggregation of Material. interface MaterialGroup : NamedEntity { Exceptions: /\\* Signals an attempt to add Material to the MaterialGroup that is already in the group. \\*/ exception DuplicateMaterialSignal {Material aMaterial;}; /\\* Signals an attempt to add a MaterialGroup to a MaterialGroup that is already in the group. \\*/ exception DuplicateMaterialGroupSignal {Material aMaterialGroup;}; $/ ^ { * }$ Signals an attempt to remove Material that wasn’t found in this MaterialGroup. \\*/ exception MaterialRemovalFailedSignal {Material aMaterial;}; /\\* Signals an attempt to remove a MaterialGroup that wasn’t found in this MaterialGroup. \\*/ exception MaterialGroupRemovalFailedSignal {MaterialGroup aMaterialGroup;}; Published Events: None. Provided Services: $/ ^ { * }$ Set and get the unique identifier for this"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // Material (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // Material\n\nContent: group. \\*/ string getIdentifier ( ) raises (Global::FrameworkErrorSignal); void setIdentifier (in string identifier) raises (Global::FrameworkErrorSignal, Global::DuplicateIdentifierSignal); /\\* Adds the argument MaterialSequence to the collection of Matrial held by the receiver. \\*/ void addMaterials (in MaterialSequence aMaterialSequence) raises (Global::FrameworkErrorSignal, DuplicateMaterialSignal); /\\* Adds the argument Material to the collection of Material held by the receiver. \\*/ void addMaterial (in Material aMaterial) raises (Global::FrameworkErrorSignal, DuplicateMaterialSignal); /\\* Removes the Material indicated from the MaterialGroup. Throws the exception if not found. \\*/ void removeMaterial (in Material aMaterial) raises (Global::FrameworkErrorSignal, MaterialRemovalFailedSignal, Global::NotFoundSignal); /\\* Remove and return all Material from the MaterialGroup. \\*/ MaterialSequence removeAllMaterials ( ) raises (Global::FrameworkErrorSignal); /\\* Add the argument MaterialGroup"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // Material (Part 3)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // Material\n\nContent: to this MaterialGroup. \\*/ void addMaterialGroup (in MaterialGroup aMaterialGroup) raises (Global::FrameworkErrorSignal, DuplicateMaterialGroupSignal); /\\* Removes the argument MaterialGroup from this MaterialGroup. \\*/ void removeMaterialGroup (in MaterialGroup aMaterialGroup) raises (Global::FrameworkErrorSignal, MaterialGroupRemovalFailedSignal, Global::NotFoundSignal); /\\* Remove and return all MaterialGroups from this MaterialGroup. \\*/ MaterialGroupSequence removeAllMaterialGroups ( ) raises (Global::FrameworkErrorSignal); /\\* Returns the collection of material in this MaterialGroup. \\*/ MaterialSequence allMaterials ( ) raises (Global::FrameworkErrorSignal); /\\* Returns all the MaterialGroups in this MaterialGroup. \\*/ MaterialGroupSequence allMaterialGroups ( ) raises (Global::FrameworkErrorSignal); /\\* Returns the count of the items in the MaterialGroup. \\*/ long count ( ) raises (Global::FrameworkErrorSignal); }; // MaterialGroup Dynamic Model: None. 6.6 Job Supervision Abstract Inter"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // Material (Part 4)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // Material\n\nContent: face Group 6.6.1 The Job Supervision Abstract Interface Group provides the abstractions common to creating, executing and managing a “job,” where a job can be defined as some system level operation which may be requested from the JobSupervisor. The job often spans a significant amount of time and multiple resources within the system. It is intended for specialization to provide specific job supervisors and jobs to provide system solutions."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job Supervision Abstract Interface Group (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job Supervision Abstract Interface Group\n\nContent: 6.6.1.1 The basic Job Supervision Abs tract Interface Group does not interact with other components, except to the extent that other components instantiate its interfaces. Figure 4 shows how the interfaces of Job Supervision relate to one another. 6.6.1.2 A Job Specification is a sequen ce of properties containing the parameters required to sufficiently define the work to be done. This sequence is passed by the JobRequestor to the JobSupervisor in the Job request message. See the JobSupervisor interface for more details. 6.6.1.3 JobSupervision levels are hiera rchical. One level may accept a Job and delegate portions of that Job to lower levels. Jobs, however, are not purely hierarchical. A Job accepted by one JobSupervisor may be broken down, along with other Jobs of that component and reconstituted as needed to optimize the activities of the factory. 6.6.1.4 For example, a ProductReques t may ask for 15 wafers of a particular product. The ProductRequestManager may"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job Supervision Abstract Interface Group (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job Supervision Abstract Interface Group\n\nContent: delegate a LotJob to Factory Operations with a Lot containing those 15 wafers and 10 more from a different ProductRequest. In the factory, this Lot may be split up and processed in smaller groups at various stages or, as scrap reduces the wafer count, combined with another small lot to create a more optimal process group. The Job Supervision implementation is allowed great latitude to optimize performance. Its only requirement is to fulfill the specification of the Job. 6.6.2 JobSupervisor Interface Module: AbstractIF Interface: JobSupervisor Inherited Interface: Resource Description: The JobSupervisor manages all the Jobs being performed by the component which implements it. It receives the requests for work, facilitates the creation of a Job for the task and returns (a reference to) that Job. A JobSupervisor will have a well defined domain which it can call on to perform work. These may be CIM Framework Resources if it delegates the work, or internal resources if it"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job Supervision Abstract Interface Group (Part 3)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job Supervision Abstract Interface Group\n\nContent: performs the work itself. Only activity requests which can be accomplished within the domain of a JobSupervisor should be issued to/accepted by that JobSupervisor. Jobs, as subtypes of NamedEntity, are named by the JobSupervisor in such a way that their name attribute may be used to query for the Job. Jobs from different JobSupervisors may have the same name. The definition of the work to be performed is the JobSpecification, a sequence of name/value pairs (see “Properties” definition). Specializations of Job Supervision may require certain properties in the JobSpecification. Some commonly useful properties are defined in the following table. When possible, specializations should reuse these definitions. Specializations should also document the allowable and mandatory properties that are supported. See Job definition for more information. interface JobSupervisor : Resource Type Definitions: $/ ^ { * }$ Type for returning results of Job execution. \\*/ typedef"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job Supervision Abstract Interface Group (Part 4)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job Supervision Abstract Interface Group\n\nContent: Global::NameValueSequence Results; JobSpecification Properties: Exceptions: /\\* Requested Job was rejected. \\*/ exception JobRejectedSignal { string errorMessage; }; /\\* Requested Job was not found \\*/ exception JobNotFoundSignal { string errorMessage; string missingJobName; }; Published Events: /\\* Provide lifecycle event for tracking \\*/ const string JobLifecycleSubject $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ “/JobSupervision/JobSupervisor/JobLifecycle”; $/ ^ { * }$ The use of “name” here (and in all other events) indicates the string value for the name or identifier of the Job to which the event refers. Since filtering does not support object reference comparisons, the filtering must be on the “name” of the object. \\*/ struct JobLifecycleFilters { Global::Property name; Global::Property lifecycle; }; JobLifecycleFilters Properties: struct JobLifecycleEvent { string eventSubject; Global::TimeStamp eventTimeStamp; JobLifecycleFilters eventFilterData;"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job Supervision Abstract Interface Group (Part 5)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job Supervision Abstract Interface Group\n\nContent: Global::Properties eventNews; Job aJob; // on Delete, aJob is nil }; Provided Services: $/ ^ { * }$ Request that work be done according to the referred specification. A Job which represents the work is returned for future reference. The post-condition for this operation is the specified Job successfully created. \\*/"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job requestJob (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job requestJob\n\nContent: in Global::Properties aJobSpecification, in JobRequestor aJobRequestor) raises (Global::FrameworkErrorSignal, JobRejectedSignal); /\\* Request that work be done according to the Job specification. This operation blocks until the Job completes. Results generated by the Job are returned. The post-condition for this operation is a successful execution of the specified Job. This interface offers a lightweight alternative to requestJob that does not require that requestors support the JobRequestor interfaces (e.g., informJobStateChange operation). A Job may or may not be created by runJob, but if created, the Job may be accessed with the Job query operations of JobSupervisor. $^ { * } /$ Results runJob ( in Global::Properties aJobSpecification) raises (Global::FrameworkErrorSignal, JobRejectedSignal); $/ ^ { * }$ Ask whether the Job specified by the JobSpecification would be accepted for current or future (queued) processing if a requestJob or runJob message were issued now. \\*/ boolean canPerform (in"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job requestJob (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job requestJob\n\nContent: Properties aJobSpecification) raises (Global::FrameworkErrorSignal); /\\* Command to begin the pausing of all Jobs of this JobSupervisor which can be paused (e.g. Jobs that have not reached the Finished state). $^ { * } /$ void pauseAllJobs () raises (Global::FrameworkErrorSignal); /\\* Command to “resume” all Jobs of this JobSupervisor which are currently Paused. \\*/ void resumeAllJobs () raises (Global::FrameworkErrorSignal); $/ ^ { * }$ This command aborts all the Jobs under the control of the JobSupervisor immediately, without regard to the impact of abruptly halting the Job. This service should be used with great caution. It may result in irrevocable change to factory or material state. \\*/ void abortAllJobs () raises (Global::FrameworkErrorSignal); $/ ^ { * }$ This command stops all Jobs under control of the JobSupervisor, as quickly as possible. Stopping Jobs should not result in damage to the factory or material being processed. \\*/ void stopAllJobs () raises (Global::FrameworkErrorSignal);"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job requestJob (Part 3)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job requestJob\n\nContent: $/ ^ { * }$ This service removes a Job which is in the terminated state. If required, persistent information about the Job may be captured in a history entry. Jobs may also be removed based on other archiving rules. \\*/ void removeFinishedJob (in Job aJob) raises (Global::FrameworkErrorSignal); $/ ^ { * }$ Find a Job by name. A Job is a NamedEntity \\*/ Job findJobNamed (in string jobName) raises (Global::FrameworkErrorSignal, JobNotFoundSignal); /\\* Find a queued Job by name. \\*/ Job findQueuedJobNamed (in string jobName) raises (Global::FrameworkErrorSignal, JobNotFoundSignal); /\\* Find an active Job by name. \\*/ Job findActiveJobNamed (in string jobName) raises (Global::FrameworkErrorSignal, JobNotFoundSignal); /\\* Find a canceled Job by name. \\*/ Job findCanceledJobNamed (in string jobName) raises (Global::FrameworkErrorSignal, JobNotFoundSignal); /\\* Find a finished Job by name. \\*/ Job findFinishedJobNamed (in string jobName) raises (Global::FrameworkErrorSignal, JobNotFoundSignal); /\\*"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job requestJob (Part 4)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Job requestJob\n\nContent: Return all the specified Jobs. The JobSequence may be empty. \\*/ JobSequence allJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allQueuedJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allCanceledJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allActiveJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allExecutingJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allPausingJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allPausedJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allStoppingJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allAbortingJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allFinishedJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allStoppedJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allAbortedJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allCompletedJobs ( ) raises (Global::FrameworkErrorSignal);"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // JobSupervisor",
    "content": "Contracted Services: None.  \nDynamic Model: Inherited.  \n6.6.3  Job Interface  \nModule:  \nAbstractIF  \nInterface:  \nJob  \nInherited Interface:  \nOwnedEntity  \nDescription:  \nThe Job interface represents a unit of work requested of an associated JobSupervisor and performed (or facilitated) by a factory entity. A Job generally results in some change of the overall factory state. How the entities that supply the Job and JobSupervisor interfaces actually perform the work (or delegation of work) is an implementation decision. A Job is expected (but not required) to take a non-zero time to perform and have a non-zero chance of refusal or failure. A Job may encapsulate a decomposition into a sequence of jobs/tasks/activities which are delegated to lower level job supervisors. The Job exists during the execution timeframe. The more persistent record of the Job should be maintained in a history entry.  \ninterface Job : OwnedEntity {  \nExceptions:\nPublished Events:\n$/ ^ { * }$ Any time the Job’s state changes. \\*/"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # const string JobStateChangedSubject $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$",
    "content": "“/JobSupervision/Job/StateChanged”;  \n/\\* This enumerated type identifies the states of Jobs. It is used in event notifications of state changes. \\*/  \nenum JobState { JobUndefined, JobCreated, JobQueued, JobActive, JobExecuting, JobNotPaused, JobPausing, JobPaused, JobNotStopping, JobStopping, JobNotAborting, JobAborting, JobFinished, JobCanceled, JobCompleted, JobStopped, JobAborted };"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct JobStateChangedFilters {",
    "content": "Global::Property name;\nGlobal::Property previousState;\nGlobal::Property newState;  \n};  \nJobStateChangedFilters Properties:"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct JobStateChangedEvent {",
    "content": "string eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nJobStateChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nJob aJob;  \n};  \n$/ ^ { * }$ If the Job cannot be completed by the specified deadline, a JobDeadlineCannotBeMetEvent should be sent as early as possible, not necessarily after the deadline has passed. \\*/  \nconst string JobDeadlineCannotBeMetSubject $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ “/JobSupervision/Job/DeadlineCannotBeMet”;  \nstruct JobDeadlineCannotBeMetFilters { Global::Property name; Global::Property deadline;"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct JobDeadlineCannotBeMetEvent {",
    "content": "string eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nJobDeadlineCannotBeMetFilters eventFilterData;\nGlobal::Properties eventNews;\nJob aJob;  \n};  \n/\\* This event is posted when a Job’s deadline date has changed. \\*/ const string JobDeadlineChangedSubject $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ “/JobSupervision/Job/DeadlineChanged”;"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct JobDeadlineChangedFilters",
    "content": "Global::Property name;\nGlobal::Property previousDeadline;\nGlobal::Property newDeadline;  \n};"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct JobDeadlineChangedEvent { (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct JobDeadlineChangedEvent {\n\nContent: string eventSubject; Global::TimeStamp eventTimeStamp; JobDeadlineChangedFilters eventFilterData; Global::Properties eventNews; Job aJob; }; Exceptions: None. Provided Services: $/ ^ { * }$ Ask the Job for its JobRequestor. \\*/ JobRequestor getJobRequestor () raises (Global::FrameworkErrorSignal); /\\* Get a named Job property from its Job Specification. \\*/ Global::Property getJobProperty ( in Global::PropertyName aPropertyName) raises (Global::FrameworkErrorSignal, Global::InvalidPropertyNameSignal, Global::PropertyNotFoundSignal); /\\* Set a named Job property in its Job Specification. \\*/ void setJobProperty ( in Global::Property aProperty) raises (Global::FrameworkErrorSignal, Global::SetValueOutOfRangeSignal, Global::InvalidPropertyNameSignal, Global::UnsupportedPropertySignal, Global::ReadOnlyPropertySignal); /\\* Indicates whether results are available for this Job. Each specialization may determine what constitutes results. \\*/ boolean areJobResultsAvailable() raises("
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct JobDeadlineChangedEvent { (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct JobDeadlineChangedEvent {\n\nContent: Global::FrameworkErrorSignal ); $/ ^ { * }$ Retrieve the latest results. Each implementation determines what constitutes relevant results. This may be used for returning current results for complex Jobs. \\*/ JobSupervisor::Results getJobResults() raises( Global::FrameworkErrorSignal ); $/ ^ { * }$ Begin the process to pause the Job at the next safe opportunity. Results in the transition to Pausing state and eventually Paused state. \\*/ void makePaused ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); /\\* Request Job resume activity from the previous Pause. Results in the transition to the executing state. \\*/ void makeExecuting ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); /\\* Request to cancel the Job. This operation is only valid if the Job is in the Queued state (e.g. the Job cannot be canceled once it is Active). This operation results in the transition to the Canceled state. \\*/ void makeCanceled ( ) raises"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct JobDeadlineChangedEvent { (Part 3)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct JobDeadlineChangedEvent {\n\nContent: (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); /\\* Begin the process to stop the Job. This is an orderly termination and should never cause irreparable problems (e.g. should not stop etching a wafer in mid-cycle). This operation results in the transition to the Stopping state and eventually the Stopped state. \\*/ void makeStopped ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); /\\* Begin the process to abort the Job. Caution should be used with this operation. Aborting a Job requires immediate termination of the Job and could result in irrecoverable change to factory or material state. This operation results in the transition to the Aborting state and eventually the Aborted state. \\*/ void makeAborted ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); $/ ^ { * }$ Determine whether the Job is in state indicated. \\*/ boolean isAborting ( ) raises (Global::FrameworkErrorSignal); boolean isAborted ("
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct JobDeadlineChangedEvent { (Part 4)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct JobDeadlineChangedEvent {\n\nContent: ) raises (Global::FrameworkErrorSignal); boolean isActive ( ) raises (Global::FrameworkErrorSignal); boolean isCanceled ( ) raises (Global::FrameworkErrorSignal); boolean isCompleted ( ) raises (Global::FrameworkErrorSignal); boolean isExecuting ( ) raises (Global::FrameworkErrorSignal); boolean isFinished ( ) raises (Global::FrameworkErrorSignal); boolean isPausing ( ) raises (Global::FrameworkErrorSignal); boolean isPaused ( ) raises (Global::FrameworkErrorSignal); boolean isQueued ( ) raises (Global::FrameworkErrorSignal); boolean isStopping ( ) raises (Global::FrameworkErrorSignal); boolean isStopped ( ) raises (Global::FrameworkErrorSignal); /\\* Return the estimated time remaining until Job completion. The quality of this estimate is dependent both on the specific Job derivative and on the implementation. If the Job is Finished or Canceled, a zero Duration will be returned. \\*/ Duration timeRemaining ( ) raises (Global::FrameworkErrorSignal);"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // Job",
    "content": "Contracted Services:  \n6.6.3.1  For implementations (e.g., Job derivatives), the Executing state is expected to be extended by partitioning it into at least two “orthogonal” states. One would hold the Pause states. The other would contain the implementation behavior of Executing.  \nObject State Tables:  \nTable 3  Job State Definitions and Query Table  \nTable 4  Job State Transitions"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.6.4  JobRequestor Interface",
    "content": "Module:  \nAbstractIF  \nInterface:  \nJobRequestor  \nInherited Interface:  \nImplementation Dependent  \nDescription:  \nIn order to request work of a JobSupervisor using the requestJob operation, a component must implement the JobRequestor interface. This is a companion interface to JobSupervisor.  The JobRequestor may also subscribe to the state change events of the Job, if more detail is required.  \ninterface JobRequestor {  \nExceptions: None.  \nPublished Events: None.  \nProvided Services:  \n/\\* The Job has transitioned to a new state. Required for transition to Executing from Queued and for any transition to a Finished sub-state. This operation is in addition to the required JobStateChangedEvent notifications. $^ { * } I$"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # void informJobStateChange",
    "content": "in Job aJob, in Job::JobState previousState, in Job::JobState newState) raises (Global::FrameworkErrorSignal);"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // JobRequestor",
    "content": "Contracted Services: None.  \nDynamic Model: None.  \nScenario:  \naJobRequestor:  \n6.6.4.1  Figure 6 shows the most basic of scenarios for Job Supervision interactions. It proceeds in this fashion:\n6.6.4.1.1  The JobRequestor populates a JobSpecification then requests a Job according to that specification.  \n6.6.4.1.2  In response to the Job request, the JobSupervisor facilitates the creation of a Job to represent the task. A handle to the Job is returned to the JobRequestor (assuming the Job request is accepted).  \n6.6.4.1.3  The Job Supervision compone nt (e.g. in the form of the Job) informs the JobRequestor when the Job begins.  \n6.6.4.1.4  The Job Supervision compone nt (e.g. in the form of the Job) informs the JobRequestor when the Job has completed (assuming successful completion). It also issues events for each state change (not shown in the scenario diagram)."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.7  Factory Component",
    "content": "6.7.1  The Factory interfaces provide configuration services to specify the existence and connectivity of factory resources that constitute a factory. This includes area configuration and the registration of CIM system components, and the ability to dynamically configure a factory to enforce business policy.  \n6.7.1.1  These interfaces are included here to satisfy dependencies and meet needs of other CIM Framework Components. These interfaces will be moved to the Factory Operations Component in a subsequent revision ballot."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.7.2  Factory Declarations (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.7.2  Factory Declarations\n\nContent: 6.7.2.1 The following declarations are used by the interfaces of the Factory Component. interface ComponentManager; interface Area; typedef sequence <ComponentManager> ComponentManagerSequence; typedef sequence <Area> AreaSequence; exception AreaNotFoundSignal {Area requestedArea;}; exception AreaDuplicateSignal { }; exception AreaNotAssignedSignal { }; exception AreaRemovalFailedSignal { }; 6.7.3 MESFactory Interface Module: FactoryOperations Interface: MESFactory Inherited Interface: AbstractIF::Resource Description: The MESFactory interface represents one particular factory. This instance is a composite object referring to the objects that represent factory resources, particularly CIM system components. The factory instance provides overall startup and shutdown capability. interface MESFactory : AbstractIF::Resource { Exceptions: None. Published Events: $/ ^ { * }$ MES Factory state change event definition. \\*/ const string MESFactoryStateChangedSubject $\\mathrm { ~ ~ \\psi ~ } ="
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.7.2  Factory Declarations (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.7.2  Factory Declarations\n\nContent: \\mathrm { ~ \\bf ~\" ~ }$ /Factory/MESFactory/StateChanged”; /\\* This enumerated type identifies the states of the MES Factory. It is used in event notifications of state changes. \\*/ enum MESFactoryState { FactoryUndefined, FactoryStartingUp, FactoryOperating, FactoryGoingToStandby, FactoryStandby, FactoryShuttingDownImmediately, FactoryShuttingDownNormally, FactoryOff };"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct MESFactoryStateChangedFilters {",
    "content": "Global::Property name;\nGlobal::Property previousState;\nGlobal::Property newState;  \n};  \nMESFactoryStateChangedFilters Properties:"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct MESFactoryStateChangedEvent {",
    "content": "string eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nMESFactoryStateChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nMESFactory aMESFactory;  \n};  \n/\\* Registration of Component Manager has changed \\*/ const string ComponentManagerRegistrationChangedSubject = “/Factory/MESFctory/ComponentManagerRegistrationChanged”;  \n$/ ^ { * }$ This enumerated type identifies the states of Component Manager registration. It is used in event notifications of state changes. \\*/  \nenum RegistrationState { RegistrationUndefined, Registered, NotRegistered };"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct RegistrationChangedFilters {",
    "content": "Global::Property MESFactoryName;\nGlobal::Property componentManagerName;\nGlobal::Property newState;  \n};  \nRegistrationChangedFilters Properties:"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct ComponentManagerRegistrationChangedEvent {",
    "content": "string eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nRegistrationChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nMESFactory aMESFactory;\nComponentManager aComponentManager;  \n};"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Provided Services: (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Provided Services:\n\nContent: /\\* Add an area to the receiver. Returns the area. \\*/ Area addArea (in Area anArea) raises (AreaDuplicateSignal, Global::FrameworkErrorSignal); /\\* Remove an area from the receiver. Returns the area removed. \\*/ Area removeArea (in Area anArea) raises (Global::FrameworkErrorSignal, AreaRemovalFailedSignal, AreaNotAssignedSignal); /\\* Returns the factory areas \\*/ AreaSequence allAreas ( ) raises (Global::FrameworkErrorSignal); /\\* Returns collections of various factory resources. \\*/ EquipmentTracking::MachineSequence allMachines ( ) raises (Global::FrameworkErrorSignal); /\\* Returns a collection of the component managers for the factory. \\*/ ComponentManagerSequence allComponentManagers ( ) raises (Global::FrameworkErrorSignal); /\\* A component informs the factory that it has completed startup. \\*/ void informComponentManagerIsOperating (in ComponentManager aComponentManager) raises (Global::FrameworkErrorSignal); $/ ^ { * }$ A component informs the factory that it has completed shutdown."
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Provided Services: (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Provided Services:\n\nContent: \\*/ void informComponentManagerIsStopped (in ComponentManager aComponentManager) raises (Global::FrameworkErrorSignal); $/ ^ { * }$ Factory is requested to go to STARTING UP state. Note MESFactory inherits from the Resource interface and is started up using the operations defined in that interface. During the startup and shutdown the factory delegates appropriate requests to all registered components. \\*/ void makeStartingUp ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); /\\* Factory is requested to specified state. \\*/ void makeOperating ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); oid makeStandby ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeShuttingDownNormaly ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeShuttingDownImmediately ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeOff ( ) raises"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Provided Services: (Part 3)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # Provided Services:\n\nContent: (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); /\\* Answer whether the factory is in the state indicated \\*/ boolean isOutOfService ( ) raises (Global::FrameworkErrorSignal); boolean isOff ( ) raises (Global::FrameworkErrorSignal); boolean isStartingUp ( ) raises (Global::FrameworkErrorSignal); boolean isInService ( ) raises (Global::FrameworkErrorSignal); boolean isOperating ( ) raises (Global::FrameworkErrorSignal); boolean isShuttingDownNormaly ( ) raises (Global::FrameworkErrorSignal); boolean isShuttingDownImmediately ( ) raises (Global::FrameworkErrorSignal); boolean isGoingToStandby ( ) raises (Global::FrameworkErrorSignal); boolean isStandby ( ) raises (Global::FrameworkErrorSignal);"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // MESFactory",
    "content": "Contracted Services: None. Dynamic Model:  \nTable 5  MESFactory State Definitions and Query Table  \nTable 6  MESFactory State Transition Table"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.7.4  Area Interface (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.7.4  Area Interface\n\nContent: Module: FactoryOperations Interface: Area Inherited Interface: OwnedEntity Description: Area is the interface corresponding to a physical or logical grouping of factory resources (the complement of machines and/or personnel assigned to it). Area may represent a singular entity or it may represent a collection of other Areas. For example, an Area may represent an entire facility for maintenance purposes, or an Area may represent a processing area such as a “bay” which is comprised of “zones.” The association between an Area and its composite Areas may be hierarchical or there may simply be a collection of peer Areas without any explicit or implicit relationship. Area may or may not be an optional construct, depending on such issues as security. interface Area { Exceptions: None. Published Events: $/ ^ { * }$ Area configuration changed event definition. \\*/ const string AreaConfigurationChangedSubject $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ “/Factory/Area/AreaConfigurationChanged”; $/ ^ {"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.7.4  Area Interface (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # 6.7.4  Area Interface\n\nContent: * }$ This enumerated type identifies the types of configuration changes for Areas. It is used in event notifications of state changes. \\*/ enum AreaChangeType { MachinesChanged, PersonsChanged, SubAreaChanged }; struct AreaConfigurationChangedFilters { Global::Property name; Global::Property changeType; }; AreaConfigurationChangedFilters Properties:"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct AreaConfigurationChangedEvent { (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct AreaConfigurationChangedEvent {\n\nContent: string eventSubject; Global::TimeStamp eventTimeStamp; AreaConfigurationChangedFilters eventFilterData; Global::Properties eventNews; Area anArea; }; Provided Services: $/ ^ { * }$ Answer the Area to which this Area is associated. If no membership has been established, nil is returned. \\*/ Area getSuperArea ( ) raises (Global::FrameworkErrorSignal); /\\* Get the unique identifier for the Area. \\*/ string getAreaIdentifier ( ) raises (Global::FrameworkErrorSignal); /\\* Adds a machine to the receiver. Returns the machine added. \\*/ EquipmentTracking::Machine addMachine (in EquipmentTracking::Machine aMachine) raises (Global::FrameworkErrorSignal, EquipmentTracking::MachineDuplicateSignal); /\\* Create an association between an Area and the Area to which it belongs. The service will add the Area indicated by the argument to the receiver’s set of subareas. The service will also update the superarea for the argument. The service returns the argument. \\*/ Area addSubArea (in Area"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct AreaConfigurationChangedEvent { (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct AreaConfigurationChangedEvent {\n\nContent: anArea) raises (Global::FrameworkErrorSignal, AreaDuplicateSignal); /\\* Adds a person to the receiver. Returns the person added. \\*/ Labor::Person addPerson (in Labor::Person aPerson) raises (Global::FrameworkErrorSignal, Labor::PersonDuplicateSignal); /\\* Remove the association between an Area and the Area to which it belongs. The service will remove the Area indicated by the argument from the receiver’s set of subareas. The service will also nullify membership (ownership) for the argument. \\*/ void removeSubArea (in Area anArea) raises (Global::FrameworkErrorSignal, AreaNotAssignedSignal, AreaRemovalFailedSignal); /\\* Removes a machine from the receiver. \\*/ void removeMachine (in EquipmentTracking::Machine aMachine) raises (Global::FrameworkErrorSignal, EquipmentTracking::MachineNotAssignedSignal, EquipmentTracking::MachineRemovalFailedSignal); /\\* Removes a person from the receiver. \\*/ void removePerson (in Labor::Person aPerson) raises (Global::FrameworkErrorSignal,"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct AreaConfigurationChangedEvent { (Part 3)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct AreaConfigurationChangedEvent {\n\nContent: Labor::PersonNotAssignedSignal, Labor::PersonRemovalFailedSignal); $/ ^ { * }$ Set the unique identifier for the Area. \\*/ void setAreaIdentifier (in string identifier) raises (Global::FrameworkErrorSignal, Global::DuplicateIdentifierSignal); $/ ^ { * }$ Returns the set of subareas associated with this Area, that is, the Areas “contained” within this higher-level Area. If no membership has been established, an empty set is returned. \\*/ AreaSequence allSubAreas ( ) raises (Global::FrameworkErrorSignal); /\\* Returns the receiver’s set of process machines. \\*/ EquipmentTracking::MachineSequence allMachines ( ) raises (Global::FrameworkErrorSignal); $/ ^ { * }$ Returns the receiver’s set of persons $^ { * } /$ Labor::PersonSequence allPersons ( ) raises (Global::FrameworkErrorSignal); }; // Area Contracted Services: None. Dynamic Model: None. 6.7.5 Component Manager Interface Module: FactoryOperations Interface: ComponentManager Inherited Interface: Resource Description: The"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct AreaConfigurationChangedEvent { (Part 4)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct AreaConfigurationChangedEvent {\n\nContent: ComponentManager is an abstract interface that supports the registration and control (enabling/disabling) of a component’s interface and for managing the resources in its domain. Exceptions: None. Published Events: interface ComponentManager : Resource /\\* Component Manager state has changed \\*/ const string ComponentManagerStateChangedSubject $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ “/Factory/ComponentManager/ComponentManagerStateChanged”; $/ ^ { * }$ This enumerated type identifies the states of Component Managers. It is used in event notifications of state changes. \\*/"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # enum ComponentManagerState {",
    "content": "ComponentManagerUndefined, ComponentManagerStopped, ComponentManagerStartingUp, ComponentManagerShuttingDown };"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct ComponentManagerStateChangedFilters {",
    "content": "Global::Property name;\nGlobal::Property previousState;\nGlobal::Property newState;  \n};  \nComponentManagerStateChangedFilters Properties:"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct ComponentManagerStateChangedEvent { (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct ComponentManagerStateChangedEvent {\n\nContent: string eventSubject; Global::TimeStamp eventTimeStamp; ComponentManagerStateChangedFilters eventFilterData; Global::Properties eventNews; ComponentManager aComponentManager; }; Provided Services: $/ ^ { * }$ This operation causes the component to do its portion of the registration interchange with the factory indicated by the argument. \\*/ void makeRegistered (in MESFactory aFactory) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); /\\* This operation causes the component to remove its registration from the factory. \\*/ void makeNotRegistered (in MESFactory aFactory) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); $/ ^ { * }$ This operation causes a registered component to perform its startup sequence. Each manager gets itself to the point where it is capable of interacting with other components. When it is ready to support all services defined in the interface, the component manager tells the factory that"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct ComponentManagerStateChangedEvent { (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct ComponentManagerStateChangedEvent {\n\nContent: component startup is complete. \\*/ void makeStartingUp ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); $/ ^ { * }$ This operation causes the component to perform its shutdown sequence and then enter the state STOPPED. During shutting down activities, time is allotted to bringing the resources of a component to a safe stopping condition. The component manager tells the factory that component shutdown is complete. \\*/ void makeShuttingDown ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); $/ ^ { * }$ This operation causes the component to go into the state STOPPED without regard to data loss or the stopping condition of resources or material. There is no communication with the factory. $^ { * } I$ void makeStopped ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); /\\* This operation causes a registered component to go into the state IN SERVICE from the state STOPPED. \\*/ void"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct ComponentManagerStateChangedEvent { (Part 3)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # struct ComponentManagerStateChangedEvent {\n\nContent: makeInService ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); /\\* Answer whether the status of the component is that indicated. \\*/ boolean isStopped ( ) raises (Global::FrameworkErrorSignal); boolean isStartingUp ( ) raises (Global::FrameworkErrorSignal); boolean isShuttingDown ( ) raises (Global::FrameworkErrorSignal); boolean isNotRegistered ( ) raises (Global::FrameworkErrorSignal); boolean isRegistered ( ) raises (Global::FrameworkErrorSignal);"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // ComponentManager",
    "content": "Contracted Services: None.  \nDynamic Model:  \nTable 7  ComponentManager State Definitions and Query Table  \nTable 8  ComponentManager State Transitions"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # APPENDIX 1FULL IDL SPECIFICATION (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # APPENDIX 1FULL IDL SPECIFICATION\n\nContent: NOTE: The material in this appendix is an official part of SEMI E97 and was approved by full letter ballot procedures on October 21 and December 15, 1999 by the North American Regional Standards Committee. module CIMF W { #ifndef _CIMFW_GLOBAL_ #define _CIMFW_GLOBAL_ Global { typedef string Identifier; typedef unsigned long Flags; struct NamedValue{ Identifier name; any argument; long len; Flags arg_modes; }; typedef NamedValue NameValue; typedef sequence <NamedValue> NameValueSequence; typedef string PropertyName; struct Property{ PropertyName Property_name; any Property_value; }; typedef sequence <Property> Properties; typedef sequence <string> StringSequence; typedef string Unit; typedef string Units; typedef sequence <any> anySequence; typedef sequence <long> longSequence; enum PriorityOfEvent { Low, Medium, High, Alarm }; enum LifecycleState { Undefined, Created, Deleted, Moved, Copied }; enum ReservationState { UndefinedReservationState, Reserved, UnReserved }; enum"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # APPENDIX 1FULL IDL SPECIFICATION (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # APPENDIX 1FULL IDL SPECIFICATION\n\nContent: E10State { E10Productive, E10Standby, E10Engineering, E10ScheduledDowntime, E10UnscheduledDowntime, E10NonscheduledTime }; semi struct ulonglong {unsigned long low ; unsigned long high ; } ; typedef ulonglong TimeT ; typedef TimeT TimeStamp; typedef sequence <TimeStamp> TimeStampSequence; struct IntervalT { TimeT lower_bound; TimeT upper_bound; }; typedef IntervalT TimeWindow; typedef TimeT Duration; struct ResourceSchedule { TimeStamp plannedStartTime; TimeStamp plannedEndTime; TimeStamp actualStartTime; TimeStamp actualEndTime; }; typedef sequence <ResourceSchedule> ResourceScheduleSequence; exception NotFoundSignal { string errorMessage; }; exception DuplicateIdentifierSignal { string errorMessage; string duplicateIdentifier; }; exception InvalidStateTransitionSignal { string errorMessage; }; exception SetValueOutOfRangeSignal { string errorMessage; }; exception TimePeriodInvalidSignal { string errorMessage; }; exception InvalidPropertyNameSignal {}; exception"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # APPENDIX 1FULL IDL SPECIFICATION (Part 3)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # APPENDIX 1FULL IDL SPECIFICATION\n\nContent: PropertyNotFoundSignal {}; exception UnsupportedPropertySignal {}; exception ReadOnlyPropertySignal {}; exception FrameworkErrorSignal { string errorMessage; unsigned long errorCode; any errorInformation;}; const unsigned long NOT_IMPLEMENTED $\\mathit { \\Theta } = \\mathit { \\Theta } 0$ ; const unsigned long IMPLEMENTED_BY_SUBCLASS $\\mathbf { \\Sigma } = \\mathbf { \\Sigma } 1$ ; const unsigned long UNKNOWN_EXCEPTION $\\mathbf { \\lambda } = \\mathbf { \\lambda } 2$ ; const unsigned long COMPLETION_UNKNOWN $= 3$ ; }; // module Global #endif // _CIMFW_GLOBAL_ module EquipmentTracking { interface Machine {}; // Stub typedef sequence <Machine> MachineSequence; exception MachineDuplicateSignal { }; exception MachineNotAssignedSignal { }; exception MachineRemovalFailedSignal { }; }; // module EquipmentTracking module Labor { interface Person {}; // Stub typedef sequence <Person> PersonSequence; exception PersonDuplicateSignal { }; exception PersonNotAssignedSignal { }; exception"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # APPENDIX 1FULL IDL SPECIFICATION (Part 4)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # APPENDIX 1FULL IDL SPECIFICATION\n\nContent: PersonRemovalFailedSignal { }; }; // module Labor #ifndef _CIMFW_ABSTRACT_IF_ #define _CIMFW_ABSTRACT_IF_ module AbstractIF { interface Resource; interface Material; interface MaterialGroup; interface JobSupervisor; interface Job; interface JobRequestor; typedef sequence <Resource> ResourceSequence; typedef sequence <Material $>$ MaterialSequence; typedef sequence <MaterialGroup> MaterialGroupSequence; typedef sequence <Job> JobSequence; typedef sequence <JobSupervisor> JobSupervisorSequence; interface NamedEntity { void setName (in string name) raises (Global::FrameworkErrorSignal); string getName ( ) raises (Global::FrameworkErrorSignal); boolean isNamed (in string testName) raises (Global::FrameworkErrorSignal); }; // NamedEntity interface OwnedEntity : NamedEntity { void setOwner (in NamedEntity owner) raises (Global::FrameworkErrorSignal); NamedEntity getOwner ( ) raises (Global::FrameworkErrorSignal);"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 1)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: interface Resource : OwnedEntity { typedef sequence <Resource> ResourceSequence; void startUp ( ) raises (Global::FrameworkErrorSignal); void shutdownNormal ( ) raises (Global::FrameworkErrorSignal); void shutdownImmediate ( ) raises (Global::FrameworkErrorSignal); string resourceLevel ( ) raises (Global::FrameworkErrorSignal); string nameQualifiedTo (in string resourceLevel) raises (Global::FrameworkErrorSignal); ResourceSequence subresources ( ) raises (Global::FrameworkErrorSignal); boolean isInService ( ); boolean isOutOfService ( ); }; // Resource interface Material : NamedEntity { string getIdentifier ( ) raises (Global::FrameworkErrorSignal); void setIdentifier (in string identifier) raises (Global::FrameworkErrorSignal, Global::DuplicateIdentifierSignal); MaterialGroupSequence materialGroups ( ) raises (Global::FrameworkErrorSignal); boolean isMemberOf (in MaterialGroup aMaterialGroup) raises (Global::FrameworkErrorSignal); }; // Material interface MaterialGroup : NamedEntity {"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 2)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: exception DuplicateMaterialSignal {Material aMaterial;}; exception DuplicateMaterialGroupSignal {Material aMaterialGroup;}; exception MaterialRemovalFailedSignal {Material aMaterial;}; exception MaterialGroupRemovalFailedSignal { MaterialGroup aMaterialGroup;}; string getIdentifier ( ) raises (Global::FrameworkErrorSignal); void setIdentifier (in string identifier) raises (Global::FrameworkErrorSignal, Global::DuplicateIdentifierSignal); void addMaterials (in MaterialSequence aMaterialSequence) raises (Global::FrameworkErrorSignal, DuplicateMaterialSignal); void addMaterial (in Material aMaterial) raises (Global::FrameworkErrorSignal, DuplicateMaterialSignal); void removeMaterial (in Material aMaterial) raises (Global::FrameworkErrorSignal, MaterialRemovalFailedSignal, Global::NotFoundSignal); MaterialSequence removeAllMaterials ( ) raises (Global::FrameworkErrorSignal); void addMaterialGroup (in MaterialGroup aMaterialGroup) raises (Global::FrameworkErrorSignal, DuplicateMaterialGroupSignal);"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 3)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: void removeMaterialGroup (in MaterialGroup aMaterialGroup) raises (Global::FrameworkErrorSignal, MaterialGroupRemovalFailedSignal, Global::NotFoundSignal); MaterialSequence allMaterials ( ) raises (Global::FrameworkErrorSignal); MaterialGroupSequence allMaterialGroups ( ) raises (Global::FrameworkErrorSignal); long size ( ) raises (Global::FrameworkErrorSignal); }; // MaterialGroup interface JobSupervisor : Resource { typedef Global::NameValueSequence Results; exception JobRejectedSignal { string errorMessage; }; exception JobNotFoundSignal { string errorMessage; string missingJobName; }; const string JobLifecycleSubject =“/JobSupervision/JobSupervisor/JobLifecycle”; struct JobLifecycleFilters { Global::Property name; Global::Property lifecycle; }; struct JobLifecycleEvent { string eventSubject; Global::TimeStamp eventTimeStamp; JobLifecycleFilters eventFilterData; Global::Properties eventNews; Job aJob; // on Delete, aJob is nil }; Job requestJob ( in Global::Properties aJobSpecification, in"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 4)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: JobRequestor aJobRequestor) raises (Global::FrameworkErrorSignal, JobRejectedSignal); Results runJob ( in Global::Properties aJobSpecification) raises (Global::FrameworkErrorSignal, JobRejectedSignal); boolean canPerform ( in Global::Properties aJobSpecification) raises (Global::FrameworkErrorSignal); void pauseAllJobs () raises (Global::FrameworkErrorSignal); void resumeAllJobs () raises (Global::FrameworkErrorSignal); void abortAllJobs () raises (Global::FrameworkErrorSignal); void stopAllJobs () raises (Global::FrameworkErrorSignal); void removeFinishedJob (in Job aJob) raises (Global::FrameworkErrorSignal); Job findJobNamed (in string jobName) raises (Global::FrameworkErrorSignal, JobNotFoundSignal); Job findQueuedJobNamed (in string jobName) raises (Global::FrameworkErrorSignal, JobNotFoundSignal); Job findActiveJobNamed (in string jobName) raises (Global::FrameworkErrorSignal, JobNotFoundSignal); Job findCancelledJobNamed (in string jobName) raises (Global::FrameworkErrorSignal,"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 5)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: JobNotFoundSignal); Job findFinishedJobNamed (in string jobName) raises (Global::FrameworkErrorSignal, JobNotFoundSignal); JobSequence allJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allQueuedJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allCanceledJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allActiveJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allExecutingJobs ( raises (Global::FrameworkErrorSignal); JobSequence allPausingJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allPausedJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allStoppingJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allAbortingJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allFinishedJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allStoppedJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allAbortedJobs ( ) raises (Global::FrameworkErrorSignal); JobSequence allCompletedJobs ( ) raises"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 6)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: (Global::FrameworkErrorSignal); }; // JobSupervisor interface Job : OwnedEntity { const string JobStateChangedSubject $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ “/JobSupervision/Job/StateChanged”; enum JobState { JobUndefined, JobCreated, JobQueued, JobActive, JobExecuting, JobNotPaused, JobPausing, JobPaused, JobNotStopping, JobStopping, JobNotAborting, JobAborting, JobFinished, JobCanceled, JobCompleted, JobStopped, JobAborted }; struct JobStateChangedFilters { Global::Property name; Global::Property previousState; Global::Property newState; }; struct JobStateChangedEvent { string eventSubject; Global::TimeStamp eventTimeStamp; JobStateChangedFilters eventFilterData; Global::Properties eventNews; Job aJob; }; const string JobDeadlineCannotBeMetSubject $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ “/JobSupervision/Job/DeadlineCannotBeMet”; struct JobDeadlineCannotBeMetFilters { Global::Property name; Global::Property deadline; }; struct JobDeadlineCannotBeMetEvent { string eventSubject;"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 7)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: Global::TimeStamp eventTimeStamp; JobDeadlineCannotBeMetFilters eventFilterData; Global::Properties eventNews; Job aJob; }; const string JobDeadlineChangedSubject $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ “/JobSupervision/Job/DeadlineChanged”; struct JobDeadlineChangedFilters { Global::Property name; Global::Property previousDeadline; Global::Property newDeadline; }; struct JobDeadlineChangedEvent { string eventSubject; Global::TimeStamp eventTimeStamp; JobDeadlineChangedFilters eventFilterD Global::Properties eventNews; Job aJob; }; exception InvalidPropertyNameSignal {}; exception PropertyNotFoundSignal {}; exception UnsupportedPropertySignal {}; exception ReadOnlyPropertySignal {}; JobRequestor getJobRequestor () raises (Global::FrameworkErrorSignal); Global::Property getJobProperty ( in Global::PropertyName aPropertyName) raises (Global::FrameworkErrorSignal, InvalidPropertyNameSignal, PropertyNotFoundSignal); void setJobProperty ( in Global::Property aProperty) raises"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 8)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: (Global::FrameworkErrorSignal, Global::SetValueOutOfRangeSignal, InvalidPropertyNameSignal, UnsupportedPropertySignal, ReadOnlyPropertySignal); boolean areJobResultsAvailable() raises( Global::FrameworkErrorSignal); JobSupervisor::Results getJobResults() raises( Global::FrameworkErrorSignal); void makePaused ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeExecuting ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeCanceled ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeStopped ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTrans tionSignal); void makeInService ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeAborted ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); boolean isAborting ( ) raises (Global::FrameworkErrorSignal); boolean isAborted ( ) raises (Global::FrameworkErrorSignal);"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 9)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: boolean isActive ( ) raises (Global::FrameworkErrorSignal); boolean isCanceled ( ) raises (Global::FrameworkErrorSignal); boolean isCompleted ( ) raises (Global::FrameworkErrorSignal); boolean isExecuting ( ) raises (Global::FrameworkErrorSignal); boolean isFinished ( ) raises (Global::FrameworkErrorSignal); boolean isPausing ( ) raises (Global::FrameworkErrorSignal); boolean isPaused ( ) raises (Global::FrameworkErrorSignal); boolean isQueued ( ) raises (Global::FrameworkErrorSignal); boolean isStopping ( ) raises (Global::FrameworkErrorSignal); boolean isStopped ( ) raises (Global::FrameworkErrorSignal); Global::Duration timeRemaining ( ) raises (Global::FrameworkErrorSignal); }; // Job interface JobRequestor { void informJobStateChange in Job aJob, in Job::JobState oldState, in Job::JobState newState) raises (Global::FrameworkErrorSignal); }; // JobRequestor}; // module AbstractIF#endif // _CIMFW_ABSTRACT_IF_#ifndef _CIMFW_FACTORY_OPERATIONS_#define _CIMFW_FACTORY_OPERATIONS_ module"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 10)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: FactoryOperations { interface ComponentManager; interface Area; typedef sequence <ComponentManager> ComponentManagerSequence; typedef sequence <Area> AreaSequence; exception AreaNotFoundSignal {Area requestedArea;}; exception AreaDuplicateSignal { }; exception AreaNotAssignedSignal { }; exception AreaRemovalFailedSignal { }; interface MESFactory : AbstractIF::Resource { const string MESFactoryStateChangedSubject $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ “/Factory/MESFactory/StateChanged”; enum MESFactoryState { FactoryUndefined, FactoryStartingUp, FactoryOperating, FactoryGoingToStandby, FactoryStandby, FactoryShuttingDownImmediately, FactoryShuttingDownNormally, FactoryOff }; struct MESFactoryStateChangedFilters { Global::Property name; Global::Property previousState; Global::Property newState; }; struct MESFactoryStateChangedEvent { string eventSubject; Global::TimeStamp eventTimeStamp; MESFactoryStateChangedFilters eventFilterData; Global::Properties eventNews; MESFactory aMESFactory; };"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 11)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: struct RegistrationChangedFilters { Global::Property MESFactoryName; Global::Property componentManagerName; Global::Property newState; }; struct ComponentManagerRegistrationChangedEvent { string eventSubject; Global::TimeStamp eventTimeStamp; RegistrationChangedFilters eventFilterData; Global::Properties eventNews; MESFactory aMESFactory; ComponentManager aComponentManager; }; Area addArea (in Area anArea) raises (AreaDuplicateSignal, Global::FrameworkErrorSignal); Area removeArea (in Area anArea) raises (Global::FrameworkErrorSignal, AreaRemovalFailedSignal, AreaNotAssignedSignal); AreaSequence allAreas ( ) raises (Global::FrameworkErrorSignal); EquipmentTracking::MachineSequence allMachines ( ) raises (Global::FrameworkErrorSignal); ComponentManagerSequence allComponentManagers ( ) raises (Global::FrameworkErrorSignal); void informComponentManagerIsOperating (in ComponentManager aComponentManager) raises (Global::FrameworkErrorSignal); void informComponentManagerIsStopped (in"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 12)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: ComponentManager aComponentManager) raises (Global::FrameworkErrorSignal); void makeStartingUp ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeOperating ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeStandby ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeShuttingDownNormaly ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeShuttingDownImmediately ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeOff ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); boolean isOff ( ) raises (Global::FrameworkErrorSignal); boolean isStartingUp ( ) raises (Global::FrameworkErrorSignal); boolean isOperating ( ) raises (Global::FrameworkErrorSignal); boolean isShuttingDownNormaly ( ) raises (Global::FrameworkErrorSignal); boolean isShuttingDownImmediately ( ) raises"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 13)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: (Global::FrameworkErrorSignal); boolean isGoingToStandby ( ) raises (Global::FrameworkErrorSignal); boolean isStandby ( ) raises (Global::FrameworkErrorSignal); }; // MESFactory interface Area : AbstractIF::OwnedEntity { const string AreaConfigurationChangedSubject $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ “/Factory/Area/AreaConfigurationChanged”; enum AreaChangeType { MachinesChanged, PersonsChanged, SubAreaChanged }; struct AreaConfigurationChangedFilters { Global::Property name; Global::Property changeType; }; struct AreaConfigurationChangedEvent { string eventSubject; Global::TimeStamp eventTimeStamp; AreaConfigurationChangedFilters eventFilterData; Global::Properties eventNews; Area anArea; }; Area getSuperArea ( ) raises (Global::FrameworkErrorSignal); string getAreaIdentifier ( ) raises (Global::FrameworkErrorSignal); Area addSubArea (in Area anArea) raises (Global::FrameworkErrorSignal, AreaDuplicateSignal); void removeSubArea (in Area anArea) raises (Global::FrameworkErrorSignal,"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 14)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: AreaNotAssignedSignal, AreaRemovalFailedSignal); void setAreaIdentifier (in string identifier) raises (Global::FrameworkErrorSignal, Global::DuplicateIdentifierSignal); AreaSequence subAreas ( ) raises (Global::FrameworkErrorSignal); EquipmentTracking::Machine addMachine (in EquipmentTracking::Machine aMachine) raises (Global::FrameworkErrorSignal, EquipmentTracking::MachineDuplicateSignal); void removeMachine ( in EquipmentTracking::Machine aMachine) raises (Global::FrameworkErrorSignal, EquipmentTracking::MachineNotAssignedSignal, EquipmentTracking::MachineRemovalFailedSignal); Labor::Person addPerson ( in Labor::Person aPerson) raises (Global::FrameworkErrorSignal, Labor::PersonDuplicateSignal); void removePerson ( in Labor::Person aPerson) raises (Global::FrameworkErrorSignal, Labor::PersonNotAssignedSignal, Labor::PersonRemovalFailedSignal); EquipmentTracking::MachineSequence machines ( ) raises (Global::FrameworkErrorSignal); Labor::PersonSequence persons ( ) raises"
  },
  {
    "title": "SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity (Part 15)",
    "content": "Title: SEMI E97-0200A PROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL DECLARATIONS AND ABSTRACT INTERFACES - # }; // OwnedEntity\n\nContent: (Global::FrameworkErrorSignal); }; // Area"
  },
  {
    "title": "Document Part 1",
    "content": "Content: interface ComponentManager : AbstractIF::Resource { const string ComponentManagerStateChangedSubject $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ “/FactoryOperations/ComponentManager/ComponentManagerStateChang ed”; enum ComponentManagerState { ComponentManagerUndefined, ComponentManagerStopped, ComponentManagerStartingUp, ComponentManagerShuttingDown}; struct ComponentManagerStateChangedFilters { Global::Property name; Global::Property previousState; Global::Property newState; }; struct ComponentManagerStateChangedEvent { string eventSubject; Global::TimeStamp eventTimeStamp; ComponentManagerStateChangedFilters eventFilterData; Global::Properties eventNews; ComponentManager aComponentManager; }; const string ComponentManagerRegistrationChangedSubject $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ “/Factory/ComponentManager/ComponentManagerRegistrationChanged” ; enum RegistrationState { RegistrationUndefined, Registered, NotRegistered }; void makeRegistered (in MESFactory aFactory) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeNotRegistered (in MESFactory aFactory) raises"
  },
  {
    "title": "Document Part 2",
    "content": "Content: (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeStartingUp ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeShuttingDown ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); void makeStopped ( ) raises (Global::FrameworkErrorSignal, Global::InvalidStateTransitionSignal); boolean isStopped ( ) raises (Global::FrameworkErrorSignal); boolean isStartingUp ( ) raises (Global::FrameworkErrorSignal); boolean isShuttingDown ( ) raises (Global::FrameworkErrorSignal); boolean isNotRegistered ( ) raises (Global::FrameworkErrorSignal); boolean isRegistered ( ) raises (Global::FrameworkErrorSignal); }; // ComponentManager }; // module FactoryOperations#endif // _CIMFW_FACTORY_OPERATIONS_ }; // module CIMFW NOTICE: SEMI makes no warranties or representations as to the suitability of the standard set forth herein for any particular application. The determination of the suitability of the standard is solely the responsibility of the user. Users are cautioned to refer to manufacturer’s instructions, product labels, product data sheets, and"
  },
  {
    "title": "Document Part 3",
    "content": "Content: other relevant literature respecting any materials mentioned herein. These standards are subject to change without notice. The user’s attention is called to the possibility that compliance with this standard may require use of copyrighted material or of an invention covered by patent rights. By publication of this standard, SEMI takes no position respecting the validity of any patent rights or copyrights asserted in connection with any item mentioned in this standard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and the risk of infringement of such rights, are entirely their own responsibility."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM)",
    "content": "This provisional standard was technically approved by the Global Information and Control Committee and is the direct responsibility of the North American Information and Control Committee.  Current edition approved by the North American Regional Standards Committee on November 27, 2001.  Initially available at www.semi.org December 2001; to be published March 2002.  Originally published February 2000; previously published March 2002.  \nNOTICE:  The designation of SEMI E98 was updated during the 1102 publishing cycle to reflect revisions to SEMI E98.1."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 1  Purpose",
    "content": "1.1  Purposes of the Object-Based Equipment Model include the following:  \nDefine a standard model for interfacing to multiprocess equipment and other complex equipment. Define standard equipment components so that communications can “discuss” component-related issues.\nProvide an equipment model that can be easily integrated with SEMI E81 CIM Framework systems by connecting an OBEM-compliant equipment to a Machine object.  \n1.2  The purpose of the Object-Based Equipment Model (OBEM) standard is to provide definitions, services, and behavior, as seen through communications with the factory, for the common types of physical and logical objects of which equipment is typically composed, including the equipment itself.  The definition of standardized objects allows the equipment to describe its makeup to the factory and provides the factory visibility into the equipment."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 2  Scope",
    "content": "2.1  This is a provisional standard that defines concepts, behavior, and services to support the integration of production equipment within a semiconductor factory.  The scope of this standard includes all semiconductor manufacturing equipment that provides an interface to the factory host systems.  Some services may not be applicable to some material handling systems.  \n2.2  Sections that must be completed in order for the provisional status of OBEM to be removed include the following:  \n1. Section  11.2 — Access Management\n2. Section 14 — OBEM Compliance  \n2.3  Detail standards will also be added in the future to specify OBEM mappings to different protocols such as SECS-II, CORBA IDL, and DCOM.  \n2.4  This standard does not purport to address safety issues, if any, associated with its use.  It is the responsibility of the users of this standard to establish appropriate safety and health practices and determine the applicability of regulatory limitations prior to use."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 3  Limitations",
    "content": "3.1  This standard is not intended to define the attributes, behavior, or services of systems that are aggregates of equipment, such as cells.  \n3.2  The decomposition of equipment into different objects is chosen by the equipment supplier to map the physical equipment to the characteristics of the objects defined by this standard.  \n3.3  Object-oriented technology is not required for implementations of OBEM.  However, object-oriented implementations should be compatible with OBEM."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 4  Referenced Standards",
    "content": "4.1  This section lists documents referenced by this standard."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 4.2  SEMI Standards (Part 1)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 4.2  SEMI Standards\n\nContent: SEMI E5 — SEMI Equipment Communications Standard 2 Message Content (SECS-II) SEMI E10 — Standard for Definition and Measurement of Equipment Reliability, Availability, and Maintainability (RAM) SEMI E15 — Specification for Tool Load Port SEMI E15.1 — Provisional Specification for $3 0 0 ~ \\mathrm { { m m } }$ Tool Load Port SEMI E30 — Generic Model for Communications and Control of Manufacturing Equipment (GEM) SEMI E39 — Object Services Standard: Concepts, Behavior, and Services 5.1.17 SMIF — Standard Mechanical Interface (SEMI E19) 5.1.18 STS — Specification for Substrate Tracking SEMI E40 — Standard for Processing Management SEMI E41 — Exception Management (EM) Standard SEMI E42 — Recipe Management Standard: Concepts, Behavior, and Message Services SEMI E53 — Event Reporting SEMI E54 — Sensor/Actuator Network Standard SEMI E58 — Automated Reliability, Availability, and Maintainability Standard (ARAMS): Concepts, Behavior, and Services SEMI E81 — Provisional Specification for CIM Framework Domain Architecture"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 4.2  SEMI Standards (Part 2)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 4.2  SEMI Standards\n\nContent: SEMI E87 — Provisional Specification for Carrier Management (CMS) SEMI E90 — Specification for Substrate Tracking SEMI E94 — Provisional Specification for Control Job Management NOTE 1: As listed or revised, all documents cited shall be the latest publications of adopted standards."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5  Terminology",
    "content": "5.1  Abbreviations and Acronyms  \n5.1.1  AGV — Automated Guided Vehicle  \n5.1.2  AMHS — Automated Material Handling System  \n5.1.3  APC — Advanced Process Control  \n5.1.4  ARAMS — Automated Reliability, Availability, and Maintainability Standard (SEMI E58)  \n5.1.5  CIM — Computer Integrated Manufacturing  \n5.1.6  CJM — Control Job Management  \n5.1.7  CMS — Carrier Management Standard  \n5.1.8  FDC — Fault Detection Control  \n5.1.9  FIMS — Front-Opening Interface Mechanical Standard (reference SEMI E62)  \n5.1.10  FOUP — Front-Opening Unified Pod  \n5.1.11  FPD — Flat Panel Display  \n5.1.12  OBEM — Object-Based Equipment Model  \n5.1.13  OSS — Object Services Standard (SEMI E39)  \n5.1.14  PGV — Personal Guided Vehicle  \n5.1.15  R2R — Run-to-Run Control  \n5.1.16  RMS — Recipe Management Standard (SEMI E42)"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2  Definitions (Part 1)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2  Definitions\n\nContent: 5.2.1 abstract object type — an object supertype that is not instantiated directly but only through one of its subtypes. 5.2.2 actuator — an analog or digital output device that is used to affect changes in the physical environment. Examples of actuators include mass flow controllers (MFCs) and open/closed valves. 5.2.3 advanced process control (APC) — techniques covering both feedforward and feedback control and automated fault detection, applied both by the equipment (in situ) and by the factory (ex situ). 5.2.4 Automated Material Handling System (AMHS) — a factory system used to transport and store carriers. AMHS has two major types of components: an automated transport system and one or more storage systems (stockers). 5.2.5 automated transport system — the component of AMHS used to transport carriers between stockers and/or production equipment. 5.2.6 carrier — a container with one or more fixed positions at which material may be held. NOTE 2: Positions within a carrier may be considered as material locations"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2  Definitions (Part 2)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2  Definitions\n\nContent: owned by the carrier. 5.2.7 clock — a device that is used to provide real-time date and time information. 5.2.8 container — a durable that is used to hold other material, including other containers, for transport, storage, or shipping. Types of containers include carriers and boxes. 5.2.9 dry run (mechanical dry run) — a complete equipment cycle that allows the material handling and software capabilities of the equipment to be exercised without requiring full facilities hookups and without changing the physical state of the wafer. Environmental control subsystem (e.g., vacuum, nitrogen purge, particle detection) should not be affected by a dry run, and process consumables are not used. 5.2.10 durable — a type of material used to facilitate manufacturing but not normally consumed in the process that is removable, reusable, and trackable. Examples include containers, reticles, and pellicles. 5.2.11 environmental subsystem — a subsystem of equipment with the purpose of monitoring or maintaining one or more specific"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2  Definitions (Part 3)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2  Definitions\n\nContent: environmental conditions or used to handle product or durables. Environmental subsystems include vacuum systems, particle detection systems, and nitrogen purge systems. 5.2.12 equipment — equipment (manufacturing equipment) performs one or more of the following manufacturing functions in the factory: material process, material transport, or material storage. Equipment is made up of various parts: modules, subsystems and sensors/actuators. Equipment has at least one carrier port. Equipment communicates with the factory. 5.2.13 equipment element — a component of the equipment that behaves as a unit, performs work, and may or may not contain lower-level components. 5.2.14 equipment module (module) — a major component of equipment that contains at least one material location and performs some task on material. Equipment modules may be aggregates of equipment subsystems, i/o devices, and other modules. 5.2.15 fault detection — analysis of data for early detection of process faults before yield loss becomes significant."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette. (Part 1)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette.\n\nContent: 5.2.17 implementation — the internal view of a type, class, or instance, including any non-public properties and behavior. The specific code and functionality that implements an interface. (See SEMI E81.) 5.2.18 interface — the external view of an object type, class, or object that defines its public properties and services without regard to the internal structure and internal behavior. (See also SEMI E81.) 5.2.19 interface inheritance — the construction of an interface by incremental modification of other interfaces (see implementation inheritance). (See SEMI E81.) OBEM specifies interface inheritance but not implementation inheritance. 5.2.20 I/O device — a general term for any type of sensor or actuator or aggregation of sensor and/or actuator. 5.2.21 linked equipment — two or more equipment that are physically and logically connected and function as a single installation of equipment. In this case, the individual component"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette. (Part 2)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette.\n\nContent: equipment are modeled as highlevel modules of the linked equipment. 5.2.22 load port — The physical interface provided for the exchange of carriers with an agent of the factory (operator or automated material handling system). (Reference SEMI E15.) 5.2.23 Manufacturing Execution System (MES) — the factory system responsible for managing the manufacturing process, including logistics and process flow. 5.2.24 material — (1) any material used in, or required by, the manufacturing process. Material is classified as consumable, durable, or product. (2) an abstraction of the various types of things used during manufacturing, such as wafers, carriers, and chemicals, which require some management. 5.2.25 material location — a reference to a place within the equipment or an equipment component that can hold material, such as the top surface of an indexer or substrate chuck or the end effector of a substrate handler. 5.2.26 measured value"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette. (Part 3)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette.\n\nContent: — a value representing a measurement, with a numerical value, measurement units, and a valid range. 5.2.27 measurement equipment — equipment whose intended function is to measure or inspect the product and to report results. Measurement of the product is the factory’s means of gaining feedback on the manufacturing process. 5.2.28 Object-Based Equipment Model — a model of equipment, its components, behaviors, attributes, and services, as defined by this document. 5.2.29 object type — a declaration (specification) that describes the common properties and behavior for a collection of objects. Types classify objects according to a common interface; classes classify objects according to a common implementation. (See also SEMI E39 and E81.) 5.2.30 object specifier — designates a logical path pointing to a specific instance of an object through a hierarchy of owners. See SEMI E39. 5.2.31 Personal Guided Vehicle (PGV) — a manually"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette. (Part 4)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette.\n\nContent: guided and operated vehicle capable of placing and removing carriers to and from a carrier port. 5.2.32 pod — as used in this document, a container providing environmental control, such as a SMIF or FIMS pod1. 5.2.33 production equipment — process equipment and measurement equipment. 5.2.34 process durable — a specialized durable used by process equipment and specified by the user as part of the process, such as a reticle or burin-in board. 5.2.35 process equipment equipment whose intended function is to process product, adding value to the product. 5.2.36 product — (1) from the equipment’s perspective, product is a synonym for substrate, and includes non-product substrates such as test substrates and sendahead substrates; (2) from the factory perspective, product is the material being processed and produced by the factory. 5.2.37 run-to-run control — techniques for varying settings in one run based on analysis of either"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette. (Part 5)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette.\n\nContent: incoming product (feed-forward) or product from an earlier run. 5.2.38 sensor — a component that responds to changes in the physical environment and provides an analog or digital input value. 5.2.39 sensor/actuator device — a device consisting of one or more sensors and/or actuators on the physical tool. See SEMI E54 for a precise definition of “sensor or actuator” and for a description of the internal structure of an sensor/actuator network Common Device Model definition. 5.2.40 setup — 1. (verb) the performance of one or more steps that puts the equipment into a known state in which it is ready to perform a specific process; 2. (noun) the state of the equipment once it has been setup. 5.2.41 standardized object — an object that is formally defined and compliant to SEMI E39, Object Services Standard (reference SEMI E42). 5.2.42 storage equipment (stocker) — equipment whose intended function is primarily to provide storage,"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette. (Part 6)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette.\n\nContent: either short-term or long-term, for carriers. 5.2.43 subassembly — a component of equipment that provides some limited functionality. 5.2.44 substrate — basic unit of material on which work is performed to create a product. Examples include wafers, die, plates used for masks, flat panels, circuit boards, and leadframes. 5.2.45 subsystem — a subsystem is an intelligent aggregate that behaves as a unit. A subsystem is made up of sensors and/or actuators and may contain mechanical assemblies. Subsystems may be shared by multiple modules. 5.2.46 subtype — an object type that is based on (derived from) another type and adds some specialization or overrides some properties or services. The type from which the subtype is derived is the supertype. For additional detail, see SEMI E39, Object Services Standard. 5.2.47 supertype — an object type which is used as a basis from which specializations are derived. The derived types are called"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette. (Part 7)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette.\n\nContent: subtypes. For additional detail, see SEMI E39. 5.2.48 transport equipment — equipment whose intended function is primarily to move material from one location in the factory to another location. Transport equipment may also provide short-term storage for material. (See also AMHS.) 5.2.49 virtual sensor (synthetic sensor, derived sensor) one or more calculated measured values that are based on one or more sensor readings. This may include results based on neural nets, statistical analysis, etc. or may be based on a single sensor value. 5.2.50 work — a group of one or more substrates that undergo processing in a factory. Something that may be work in one kind of factory, such as reticles and leadframes, may have a different role in other types of factories. Work includes, but is not limited to, material intended as product. For example, it may include product substrates, test substrates, and filler substrates. 5.2.50.1 From the"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette. (Part 8)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 5.2.16  Front-Opening Unified Pod (FOUP) — a frontopening pod with an integrated (non-removable) cassette.\n\nContent: point of view of the equipment, work is either new (processing has not started), completed (all intended processing has been performed, terminated, or aborted, including rejected and resorted work, and no further processing is to be done) or incomplete (work in progress, on hold)."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6  Conventions (Part 1)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6  Conventions\n\nContent: 6.1 This section defines the conventions followed by this document. 6.2 Object Conventions — This document conforms to the conventions for objects established by SEMI E39, including object diagrams, object terminology, and requirements for standardized objects. Accordingly, notation is based on Object Modeling Technique (OMT) as described in Object Oriented Modeling Design. 6.2.1 Formal Name of an Object — The text capitalizes formal object name references. Similar to the way capitalization is normally used when discussing entities. When describing something in the general (like cities) lower case is used, but when a specific entity is of interest (New York City), then first letters are capitalized. 6.2.2 Components of Complex Attributes — The names of object attributes defined in tables are left-justified. The individual elements of complex attributes are rightjustified in order of appearance below the complex attribute. 6.2.3 Names of OBEM Objects — The names of abstract object types start with the word “Abstract”"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6  Conventions (Part 2)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6  Conventions\n\nContent: and are not intended to be directly implemented. All other objects defined in OBEM are concrete types that may be directly implemented."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6.3  State Model Conventions (Part 1)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6.3  State Model Conventions\n\nContent: 6.3.1 This document uses the Harel state chart convention for describing dynamic operation of defined objects. The outline of this convention is described in an attachment of SEMI E30. The official definition of this convention is described in “State charts: A Visual Formalism for Complex Systems”3. 6.3.2 The Harel convention has not the concept of state models of “creation” and “extinction” for expressing a temporary entity. The “job” described in this document is such an entity, and a copy of the same state model is used for an independent job newly created. In this document, a circle with a black circle inside is used for expressing extinction of an entity. A filled black circle denotes the entry to the state model (the entity creation). 6.3.3 Transition tables are provided in conjunction with the state diagrams to explicitly describe the nature of each state transition. A transition table contains columns for Transition number, Previous State, Trigger, New State, Actions, and Comments. The “trigger”"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6.3  State Model Conventions (Part 2)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6.3  State Model Conventions\n\nContent: (column 3) for the transition occurs while in the “previous” state. The “actions” (column 5) includes a combination of: 1. Actions taken upon exit of the previous state. 2. Actions taken upon entry of the new state. 3. Actions taken which are most closely associated with the transition. 6.3.3.1 No differentiation is made between these cases. 6.4 Service Message Representation — Services are functions or methods that may be provided by either the equipment or the host. A service message may be either a request message, which always requires a response, or a notification message, that does not require a response."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6.4.1  Service Definition",
    "content": "6.4.1.1  A service definition table defines the specific set of messages for a given service resource, as shown in the following table:  \n6.4.1.2  Type can be either $\\mathbf { \\vec { \\tau } } ^ {  } \\mathbf { N } ^ { \\prime \\prime } = 1$ Notification or $\\cdots { \\bf \\nabla } ^ { \\left. 6 \\right. - 1 } \\mathrm { R } ^ { 3 } = \\mathrm { R }$ equest & Response.  \n6.4.1.3  Notification type messages are initiated by the service provider (e.g., the equipment) and the provider does not expect to get a response from the service user.  Request messages are initiated by a service user (e.g., the host). Request messages ask for data or an activity from the provider.  Request messages expect a specific response message (no presumption on the message content)."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6.4.2  Service Parameter Dictionary",
    "content": "6.4.2.1 A service parameter dictionary table defines the description, format and its possible value for parameters used by services, as shown in the following table:  \n6.4.2.2  A row is provided in the table for each parameter of a service."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6.4.3  Service Message Definition",
    "content": "6.4.3.1  A service message definition table defines the parameters used in a service, as shown in the following table:  \n6.4.3.2  The columns labeled REQ/IND and RSP/CNF link the parameters to the direction of the message. The message sent by the initiator is called the “Request”. The receiver terms this message the “Indication” or the request. The receiver may then send a “Response” which the original sender terms the “Confirmation”.  \n6.4.3.3  The following codes appear in the REQ/IND and RSP/CNF columns and are used in the definition of the parameters (eg., how each parameter is used in each direction):"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6.5  OBEM Standard Structure (Part 1)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6.5  OBEM Standard Structure\n\nContent: 6.5.1 The remaining part of this document is organized as follows: 6.5.1.1 Section 7 contains background information to provide a context for the Object-Based Equipment Model. 6.5.1.2 Sections 8 provides an overview of two major views of the equipment: the functional view and the internal composition view. 6.5.1.3 Section 9 introduces the OBEM object model: the interface inheritance hierarchy and the rules of aggregation that together form the foundation of the OBEM model of equipment. 6.5.1.4 Section 11 defines the requirements for the component objects within the equipment interface hierarchy: and other related objects of significance not defined elsewhere. 6.5.1.5 Section 12 defines the message services used in OBEM that are not defined in other standards. 6.5.1.6 Section 13 defines the services that are required of the user (factory system, remote access, and operator). 6.5.1.7 Section 14 specifies the minimum requirements and optional capabilities for compliance to the OBEM standard. 6.5.1.8 Section"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6.5  OBEM Standard Structure (Part 2)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 6.5  OBEM Standard Structure\n\nContent: 15 provides scenarios showing typical message flows during operation. 6.5.2 Additional sections are provided as related information: examples and additional material that are not part of the standard itself. These include models for linked litho, $3 0 0 ~ \\mathrm { { m m } }$ equipment, the relationship of OBEM and the CIM Framework, and representations of date and time."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 7  Background",
    "content": "7.1  Both modern manufacturing processes and modern manufacturing equipment are increasingly complex.  A single installation of equipment may have hundreds or thousands of sensors and actuators.  In order to manage this complexity, better methods of referencing the internal components of equipment are needed.  Use of the object paradigm provides a means for the equipment to describe its internal composition to the factory in a natural way.  \n7.2  Definition of standardized objects allows the factory to be specific about its requirements and its need for information."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 7.3  Computer Manufacturing Integration Business Goals (Part 1)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 7.3  Computer Manufacturing Integration Business Goals\n\nContent: 7.3.1 The intent of this section is to provide a context for, and insight into, those requirements of industries such as semiconductor and flat panel display (FPD) manufacturing businesses that affect the object-based equipment model. 7.3.2 The primary purpose of computer integrated manufacturing (CIM) technologies is to improve factory productivity. Other inter-related secondary CIM business goals are listed below. Maximize product yields (line/mechanical yield). Maximize device yields (electrical/functional yield). Maximize total factory product substrate throughput. Increase individual equipment product substrate throughput. Reduce product variability. Reduce process variability. Optimize ability to center processes in a “sweet spot”. Reduce the use of non-product substrates. Reduced time to utilization for equipment (i.e., the time to install, qualify, characterize and ramp production). Increase the usability, accuracy, and reliability of data used for metrics. These business"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 7.3  Computer Manufacturing Integration Business Goals (Part 2)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 7.3  Computer Manufacturing Integration Business Goals\n\nContent: goals can be met by addressing certain concrete objectives, which are listed below."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 7.4  OBEM Functional Objectives (Part 1)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 7.4  OBEM Functional Objectives\n\nContent: 7.4.1 OBEM will standardize specific functional capabilities to be implemented on semiconductor/FPD and other manufacturing equipment, providing a hierarchical view of equipment for effective factory integration. 7.4.2 The OBEM functional objectives are as follows: Manage material into and through the equipment. Manage the association of the process instructions with the material. Report data associated with the equipment, the process, and the material. Facilitate equipment performance monitoring. 7.4.3 These OBEM functional objectives, individually and collectively, can be shown to directly address the overall business goals: 7.4.4 The Object Based Model objective directly affects the ability to implement most of the other objectives, especially in the case of highly modular equipment. 7.4.5 Equipment performance monitoring has the effect of improving product variability, device yield and can reduce the need for non-product test substrates. It can also provide a means of targeting a specific process"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 7.4  OBEM Functional Objectives (Part 2)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 7.4  OBEM Functional Objectives\n\nContent: window to improve device characteristics such as speed. 7.4.6 Management of the association of process instructions with the material can reduce scrap due to misprocessing, thus improving product yield. The material management objectives impact on the throughput of individual equipment and the total factory throughput. 7.5 Relevant Factory Environment — Equipment must support a variety of different factory environments. This is necessary because factory business practices and factory configurations vary not only from company to company but also from one facility within a company to another. Items will be added to this section as their relevance becomes apparent. 7.5.1 Material Handling Systems — Material may be loaded and unloaded manually by a fab technician or it may be loaded and unloaded using semi-automated and automated transport systems. Types of systems include: Automated Guided Vehicles (AGV), Personal Guided Vehicles (PGV), Overhead Transport Systems (OTS), including Overhead Hoist Transport"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 7.4  OBEM Functional Objectives (Part 3)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 7.4  OBEM Functional Objectives\n\nContent: (OHT), and Fixed Arm Robots. 7.5.2 Containers — Containers may be open (e.g., cassettes) or closed (pods, including reticle pods). Pods may be bottom-opening (SMIF), with a removable cassette, or front-opening (FIMS), which may have either a removable cassette or an integrated (nonremovable) cassette (FOUP). 7.5.3 Factory Interface — The equipment must be able to support different levels of automation, including: stand-alone (with no connection to the factory systems), fully on-line and operated locally (by the operator), fully on-line and operated remotely (by the factory systems), and fully on-line and able to support and coordinate interactions from multiple factory users and systems at the same time."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8  Equipment Overview (Part 1)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8  Equipment Overview\n\nContent: 8.1 The Object-Based Equipment Model defines the objects that are generic components of equipment as well as the object representing the equipment itself. OBEM does not dictate the makeup of equipment. Through support of OBEM, the equipment is able to describe its own makeup to the factory. However, OBEM does require certain visibility and access to those parts of the equipment that control and/or monitor the environment or the location of the product. 8.2 Two view areas are of importance: the functional view of the equipment and the internal composition view of the equipment. 8.3 Functional View of Equipment — From a functional view, equipment is internally composed of logical subsystems with different areas of responsibility that are at different levels within a control hierarchy, as illustrated in Figure 1. There are three general levels. Equipment Control is at the highest level, both responsible for, and representing, the equipment as an integrated whole. The middle level provides management of specific"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8  Equipment Overview (Part 2)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8  Equipment Overview\n\nContent: areas, while the lowest level of functionality has specific time-critical responsibilities and handles all direct interaction with the equipment’s I/O (sensors and actuators). The third level is below the factory level of visibility and is discussed here for completeness. NOTE 3: This is not intended to represent the design of an actual implementation. 8.3.1 The functional areas are discussed below in alphabetical order. 8.3.2 Access Management — Access Management is responsible for communications with the factory, including factory computers, local and remote operators, third party systems, and alternate users (desktop access by process engineers, maintenance personnel, supplier remote diagnostics, etc.) Communications with the local operator include input devices (such as keyboards, wands, buttons, and optical character readers) and display devices (console, light pole, and LCD panel) as well as interpretation of operator requests. 8.3.3 Communications Link — Communications Link is responsible for low-level"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8  Equipment Overview (Part 3)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8  Equipment Overview\n\nContent: communications, including establishing a connection with a communications partner, sending messages, and receiving messages. 8.3.4 Date/Time Management — Date/Time Management is responsible for maintaining an accurate date and time-of-day, and for providing current date/time information to the rest of the system. This may include maintenance of regular time-based scheduling. 8.3.5 Environment Control — Environment Control is responsible for maintaining the internal environment according to the equipment’s specifications. While Process Control is specific to a process and recipe, other monitoring activities may be required regardless of whether the equipment is processing or idle. Such activities include monitoring for particles, humidity, or temperature. 8.3.6 Equipment Control — Equipment Control is the supervisory level with overall high-level control. Equipment Control represents the entire equipment as an integrated whole to the factory and represents the decision-making authority within the equipment. 8.3.7"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8  Equipment Overview (Part 4)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8  Equipment Overview\n\nContent: Event Management — Events continually occur in all equipment states. A variety of these events are of interest to the factory, including those events that generate a change of state in any standardized object. The factory requires notification when selected events occur, and in many cases, requires reports of the values of specified information at the time that the event occurred. Event Management is responsible for tracking those events and the reports associated with those events. 8.3.8 Exception Management — Exception Management is responsible for determining the proper response to an action or operation that the equipment was unable to perform which raised an exception condition. It prompts notification to all affected components, including internal components and currently connected users. In some cases, the proper action may have to be resolved by the user. Exception Management is a high level activity that is in addition to underlying hardware and software interlocks. 8.3.9 Facilities Interface — The"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8  Equipment Overview (Part 5)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8  Equipment Overview\n\nContent: Facilities Interface is responsible for managing the physical interfaces (hookups) to the factory. This includes bulk fill, continuous chemical services, factory vacuum, factory exhaust, and the electrical environment of the equipment. 8.3.10 Information Management Information Management is responsible for the information and data stored by the equipment, including information required for the user as well as various internal event and data logs. 8.3.11 Job Management — Job Management is responsible for all jobs, including process jobs, job queues, and job execution. 8.3.12 Material I/O Management — The Material Input/Output (I/O) Management is responsible for loading and unloading material to and from the factory. This includes the AMHS interface (parallel I/O), pod interface, carrier management, and carrier-related services such as reading, writing, and slot mapping (identifying unoccupied, correctly occupied, and incorrectly occupied slots in a carrier). 8.3.13 Material Management — Material Management is"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8  Equipment Overview (Part 6)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8  Equipment Overview\n\nContent: responsible for tracking all material, including carriers, product, and consumables, within or used by the equipment. This includes providing historical information required for product history. 8.3.14 Material Movement Control — Material Movement Control consists of low-level control of internal subsystems, subassemblies, and i/o devices used in moving material within the equipment, such as robots, location sensors, proximity sensors, motors, centering and alignment systems, and material identifier readers."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8.3.15  Object Management (Part 1)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8.3.15  Object Management\n\nContent: 8.3.15.1 Object Management consists of management of OBEM objects, their attributes, and internal communications. It includes all elements of configuration definition, both fixed and userconfigurable, that pertain to the equipment. Configuration settings consist of those attributes that affect the global behavior of the equipment and are generally static and change only on request. They are in effect at all times regardless of the current recipe(s) and/or processing states. They control activities that maintain the environment when “not processing”. 8.3.15.2 Configuration settings shall be retained in non-volatile storage. Some elements of configuration may be distributed. For example, individual process chambers may have their own configuration elements. 8.3.15.3 Elements of configuration management include: configuration of individual physical chambers, and configuration of individual logical objects. 8.3.16 Operations Management Operations Management is responsible for the overall operation of the"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8.3.15  Object Management (Part 2)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8.3.15  Object Management\n\nContent: equipment in all operational modes: automatic, semi-automatic, and manual. 8.3.17 Performance Management — Performance Management is responsible for managing information and operations related to the performance of the equipment and equipment modules. This includes oversight for manual mode operations performed when the equipment and equipment modules are out of service. For implementations of ARAMS, this also includes ARAMS state changes and data as well as oversight for manual mode operations performed during downtime and non-scheduled time. 8.3.18 Process Execution — Process Execution covers those fixed algorithms and procedures that are not reachable or changeable by the user. This includes any embedded control and sequence algorithms not contained in recipes. It consists of low-level control of subsystems, sensors, and actuators not covered by Material Management Control, such as, chemical control (valves, exhaust), motion control (rotational, acceleration, positional) and the control of the environment"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8.3.15  Object Management (Part 3)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8.3.15  Object Management\n\nContent: during processing of the product (temperature, etc.). It also includes product environment control and any fixed embedded fault detection classification, and/or fixed low-level in-situ run-to-run control for advanced process control."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8.3.19  Recipe Execution (Part 1)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8.3.19  Recipe Execution\n\nContent: 8.3.19.1 A recipe represents the pre-planned and reusable set of instructions, algorithms, and settings that are used by process execution to control process, including variable in situ process control algorithms. Recipes are created by the user, and in some cases by the equipment as well. Recipes may be of a variety of types, such as flow sequence, metrology, models, abort, and load maps, as well as etch, clean, etc. 8.3.19.2 Recipe Execution is responsible for the proper and safe execution of recipes, including loading the recipe into the execution area, verification of the recipe, validation of recipes (ensuring the recipe does not conflict with the current equipment configuration), and initiation of process execution based on recipe instructions (SEMI E42). 8.3.20 Recipe Management — Recipe Management consists of the management of stored recipes. This is differentiated from short-term storage of recipes and the selection and execution of recipes performed by Recipe Execution (SEMI E42). Recipes are"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8.3.19  Recipe Execution (Part 2)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8.3.19  Recipe Execution\n\nContent: classified (organized) according to their primary application function: process, environment, service (maintenance), etc."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8.4  Relationships with Other Standards (Part 1)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8.4  Relationships with Other Standards\n\nContent: 8.4.1 Only those functional areas in the middle in Figure 1 are of interest to the host. The top level of Equipment Control represents all of the functionality below it, while the functional areas at the bottom are considered to be low level and proprietary to the equipment supplier. 8.4.2 Table 1 shows those functional areas that are defined by OBEM and those that are defined by other SEMI standards. In some cases, OBEM may extend or limit the functionality defined elsewhere. Table 1 Functional Area Definition 8.5 Internal Composition View of the Equipment — The physical makeup of equipment is of interest to the factory, particularly for equipment that is complex, multi-module, and/or multi-process. Productivity and maintenance tracking, for example, requires that the factory be able to specify individual subsystems and/or modules for maintenance activities, where it is possible to do so without removing the entire equipment from manufacturing scheduling. For example, one or more baths in a"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8.4  Relationships with Other Standards (Part 2)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 8.4  Relationships with Other Standards\n\nContent: wet bench may be down for maintenance even though the wet bench itself continues to process."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 9  OBEM Object Model (Part 1)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 9  OBEM Object Model\n\nContent: 9.1 OBEM defines generic component objects of Equipment, and the Equipment object itself. Equipment is made up of elements (units or parts) of different levels of intelligence and complexity, such as modules, subsystems, and I/O devices. Each of these elements may itself be made up of several smaller elements, some of which may also be intelligent, and this allows the complexity of the equipment to be distributed to smaller functional units. Many of these elements may be of interest to the factory. In particular, process modules, which are intelligent and may be independently operable, are very interesting to the factory, since these are the units where the product is actually processed. The factory requires processing modules to be highly visible and individually addressable and to support certain of the same remote commands that are required of the equipment. Other elements of interest include subsystems for material handling, alignment, and measurement. 9.2 The equipment is responsible for all communications"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 9  OBEM Object Model (Part 2)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 9  OBEM Object Model\n\nContent: at all times, including messages directed to a specific part of the equipment. Service requests directed to components of the equipment shall be managed by the equipment to ensure equipment integrity. $9 . 3 ~ \\mathrm { { I n } }$ Figure 3, two hierarchies are shown. On the left is an inverted interface inheritance hierarchy, and on the right the concrete subtypes where rules of aggretation are shown. The interface inheritance shows the objects that define the attributes, state models, and services of the subtype objects as viewed externally. These are presented upside down from the usual presentation so that they may be directly related to the aggregation hierarchy on the right. In both cases, the simpler objects are below the more complex objects. 9.4 Those object types starting with the word “Abstract” are abstract objects not intended to be implemented directly. Their purpose is solely to define the inherited attributes, state models, and services for those objects used to build an OBEM model of equipment."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 9  OBEM Object Model (Part 3)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 9  OBEM Object Model\n\nContent: The remaining objects shown in Figure 3 are concrete objects. All rules of aggregation are defined for concrete objects only. 9.5 OBEM Object Requirements — By definition, subtypes of objects inherit the properties (attributes, services, and relationships) of their supertypes. In some cases, properties of the subtype may be further specialized. 9.5.1 Object Services Requirements — All objects formally defined by this standard shall be compliant to the fundamental requirements of SEMI E39 (OSS). All OBEM-defined objects that are aggregates, containers, or managers of other objects shall comply with the additional OSS requirements for object owners. According to OSS, an owner is any aggregate, container, or manager of one or more other objects. An owner is required to respond to queries about the types of objects that it owns. Owners have additional responsibilities, as specified in OSS."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 9.5.2  Object Non-volatility (Part 1)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 9.5.2  Object Non-volatility\n\nContent: 9.5.2.1 All objects defined by OBEM shall be persistent. The individual object persists across powerdown and powerup conditions, and all current values of static attributes (attributes that do not change dynamically indicating the object' s status) shall be maintained and restored upon powerup. It may be important to maintain other critical values as well, depending upon the object and the implementation. When the equipment is powdered on or reset5, all state models are restored. Following initialization, the object is considered to be operational. Figure 4 shows this convention for a generic OBEM object. However, since the state model can not be accessed by the user until the object is operational, the default entry state for a specific state model is considered to be within the Operational state. 9.5.2.2 POWERDOWN and INITIALIZATION are common to all OBEM objects. Therefore, they are not specific to any object and are not generally shown. When operational, the OBEM object is capable of maintaining state"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 9.5.2  Object Non-volatility (Part 2)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 9.5.2  Object Non-volatility\n\nContent: information. From the user view, an instantiation of an OBEM object shall follow the behavior or state model as shown in Figure 4. The equipment representation, which consists of an aggregation of OBEM objects, shall also reflect the state model shown here. 9.5.2.3 The equipment is responsible for managing the exchange of any of its component parts, including parts exchanged during powerdown. This may be accomplished through use of intelligent components that are able to identify themselves or through the user interface. 9.5.3 Shared Resources — When two (or more) objects cooperate in using the services provided by a third object, then the third object should not be modeled as a component of either of the first two objects. If the two cooperating objects have a common owner, either logical or physical, then the shared resource object should belong to the common owner. 9.5.4 Object Factory Communications — OBEM objects other than the Equipment object are neither required nor expected to communicate"
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 9.5.2  Object Non-volatility (Part 3)",
    "content": "Title: SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 9.5.2  Object Non-volatility\n\nContent: directly with the factory. Factory communications are handled by the Equipment instantiation."
  },
  {
    "title": "SEMI E98-1102 PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT MODEL (OBEM) - # 9.5.5  Object Event Reporting",
    "content": "9.5.5.1  Event reporting allows a user to receive notification of events together with related data of interest. OBEM compliance requires that the equipment provide a standard mechanism for reporting events of interest to the user, together with the current values of user-selectable data.  \n9.5.5.2  All transitions in state models are of interest to the user and reportable unless otherwise stated in the state model definition."
  }
]