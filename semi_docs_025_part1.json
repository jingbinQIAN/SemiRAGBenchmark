{
  "doc_id": "semi_docs_025",
  "chunk_id": 1,
  "content": "SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: executor informs the service user of the completion of each individual operation by sending the notification message RMEComplete. In addition, in restricted circumstances, the recipe executor is required to inform a namespace that a recipe body originally downloaded from that namespace has been changed. 11.1 Object Services Operations — A recipe executor shall comply with Object Services Standard specifications for fundamental requirements and with the requirements for Owner Objects. Support for Filtering is optional. A recipe executor owns the execution recipes that it stores, and it is owned by the agent that provides recipe executor. The owner relationships are used by Object Services to define a recipe specifier. The recipe executor shall support operations for Get Attributes and Set Attributes for its own attributes. It shall support the operation of Get Attributes for the execution recipe. (Note that all attributes of the execution recipe are read-only and may not be set through the interface.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 3)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: It shall support the Get Type and Get Attribute Name operations for the object types of recipe executor and execution recipe. 11.1.1 Execution Recipe Specifier — The object specifier for an execution recipe includes the object type and identifier of the recipe executor, followed by the identifier of the recipe, including its originating namespace. For example, to specify an execution recipe \"NS-MOM $[ >$ PROCESS/ABC; $5 { > } ^ { \\prime }$ \" that is stored by a recipe executor named \"RE-Etch\" owned by \"Agent:Etch01\", the object specifier would be \"Agent:Etch01 $>$ RcpExec:RE-Etch>NS-MOM $[ >$ PROCESS/ ABC; $5 { > } \"$ . 11.2 Description of Operations — This section describes the operations of the recipe executor. 11.2.1 Recipe Download and Verify — A recipe is downloaded when it is transferred (sent) to the recipe executor. Downloaded recipes that do not have the Verified attribute set to TRUE shall be immediately verified. Otherwise, it is not necessary to re-verify a recipe. Any verification errors\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 4)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: shall be reported to the initiator of the download operation. For further discussion of the verification operation, see Section 11.2.2. Normally, if the identifier of the recipe (namespace name, recipe class, recipe name, and version number) is already assigned to an execution recipe already existing in storage, the download is refused. However, the initiator of the download operation may optionally request a forced overwrite of any such pre-existing recipe. In this case, if the existing recipe is not currently selected, the new recipe replaces the older one. A request to delete or overwrite a currently selected recipe shall be denied. The body of a recipe currently being edited shall be protected from inadvertent change or overwriting by a recipe with the same identifier that is downloaded during this time. If the downloaded recipe is accepted (stored), the equipment shall require the operator either to save the edited recipe to a new (unused) identifier or to discard it. The download and verify\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 5)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: recipe operation is invoked with the RMEDnldVer service. 11.2.2 Recipe Verify — This is a required operation that verifies a specified execution recipe. Verification requires reading the recipe's body. For a source form recipe, the verification operation checks the contents of the recipe for syntactical correctness. If supported, the recipe executor may also include one or more checks for semantic correctness as part of its verification operation. For recipes in object form, verification checks the format of the contents to achieve the same effect. A verified recipe merely indicates that it is technically correct and can be executed. It does not indicate that it can be properly executed for the current hardware configuration. Checking to ensure a recipe will execute properly is called validation and shall only be performed at the time recipes are selected for execution. A recipe that has syntactical or format errors fails the verification process. Information concerning errors shall be reported to\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 6)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: the initiator of the verification process. This information is required for the user to be able to make appropriate corrections. Information returned to the namespace manager at the conclusion of the verification process includes: All external references, required for the ExtRef attribute of the managed recipe, All variable parameter definitions, required for the Parameters attribute of the managed recipe, The estimated or nominal time of the recipe, in seconds, used for the EstRunTime attribute of the managed recipe (optional). These items are not returned if the recipe fails verification. In this case, the recipe executor shall provide sufficient information to the user for identification of the type of error and where within the body it occurred, for at least the first error encountered. The external references that are returned shall always include the name of the recipe referenced, and any referenced namespace, in the proper form for a recipe identifier. If the external reference specifies a\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 7)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: namespace other than \"Default\" (Section 6.4), the version is required to be fully specified for verification to be successful. Otherwise, version shall be left exactly as specified in the body. Omission of version allows \"the best version\" to be determined by the namespace at a later stage. The verify operation is invoked explicitly with the RMEVerify service. It may also be performed as part of the download and verify operation as discussed in Section 11.2.1. 11.2.2.1 Derived Object Form Recipes — For downloaded recipes that are to be stored, the recipe executor may wish to re-write or compress a source form recipe into a derived object form recipe (Section 3.2.2.1.2) as part of the verification process. (The rewritten form may be of any format and is typically not a form of \"machine-executable code\".) Where downloaded recipes are converted to a derived object form prior to storage, a method of re-converting to source form is required. Note that the capability to retain user comments is desirable,\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 8)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: but not required, where this process is adopted. The new derived object form recipe inherits the attributes of the source form recipe with the following exceptions: The class or name of the object form shall be changed in a systematic and documented manner that both makes clear the object form derivative and its heritage from the source form original. For example, the object form may add an extension to the name of the original recipe. The BodyFormat attribute shall be changed to reflect the object form. The attributes ExecLength, ExecChgTime, BodyLength, and EditTime shall be updated. If the attribute ExecChgCtrl requires the originating namespace to be notified of changes, then this request applies to the creation of the derived object form recipe, and the ChangedBody attribute is set to TRUE until the recipe has been uploaded successfully by the namespace manager. The source form recipe from which the derived object form was obtained should not be deleted automatically. 11.2.2.2 Verification ID\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 9)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: The attribute VerificationID is used for derived object form recipes and is provided for the recipe executor identification code. This is a text string containing a unique and persistent \"signature\" or identifier for the recipe executor. This is used to detect derived object form recipes that were derived by earlier software versions of the recipe executor, or by versions used by other agents, that may have obtained different results. The identifier of the source form recipe of the derived object form recipe is stored in the attribute SrcRcpID of the derived object form recipe. 11.2.3 Recipe Upload — Recipe upload is the operation that returns an execution recipe from the recipe executor's storage to the service user. It is required for recipe executors that are able to originate or modify recipes. Recipe upload allows recipes to be managed in a recipe namespace. The upload recipe operation is invoked with the RMEUpload service. 11.2.4 Recipe Rename The recipe rename operation causes a recipe to be\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 10)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: assigned a new identifier. If the new identifier is already in use by a pre-existing execution recipe, or if the recipe to be renamed is currently selected, the request shall be denied. This is a required operation. This service is provided to maintain synchronization between execution recipes and the managed recipes within an originating namespace. The rename recipe operation is invoked by the message service RMERename. 11.2.5 Get Available Storage — The get available storage operation is used to determine the size of the remaining recipe storage capacity, in bytes. The value returned shall exclude any overhead requirements for storage of one execution recipe. That is, it shall be assumed that sufficient storage exists for a single recipe with a combined attribute length and body length less than or equal to the returned value. This is a required operation. The get available storage operation is invoked by the message service RMESpaceInquire. 11.2.6 Recipe Delete — The recipe delete operation\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 11)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: removes one or more recipes from the execution recipe storage. Any reusable (rewritable) storage used by a deleted recipe shall be made available for other recipes, and the deleted recipe shall be unavailable for all subsequent operations. This is useful to release storage for new recipes. This is a required operation. Recipes stored in non-reusable storage that cannot be physically deleted shall be made unavailable for subsequent selection. If the recipe executor does not have execution recipe storage (that is, if its sole storage is the recipe execution area), then the delete operation shall completely remove the specified recipes from the recipe execution area. The delete recipe operation is invoked with the RMEDelete service. A request to delete a currently selected recipe shall be denied. 11.2.7 Recipe Selection — Recipe selection is the process of locating, validating, and preparing a recipe for execution within the execution area. Recipe selection is a required operation of the recipe executor\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 12)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: that allows specification of initial (default) values of any variable parameters defined by the recipe. Initial parameter values specified at this time shall override the corresponding values contained in the ExecLinkParam attribute. It shall be possible to explicitly specify a recipe for execution. It may also be possible to implicitly select a recipe, including initial variable parameter values, through other operations, such as within a higher-order \"process job\". Services for implicit methods and for starting execution itself are beyond the scope of RMS. If the recipe class is omitted when specifying a recipe for selection, then the class \"/PROCESS/\" shall be assumed. The request for recipe selection specifies one or more recipes to be selected. If a recipe cannot be located in the recipe executor's recipe storage area, then the recipe executor may optionally attempt to locate and retrieve it from the originating namespace specified. Only a linked recipe (with the Linked attribute set to TRUE)\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 13)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: may be specified by the service user. An attempt to select an unlinked recipe shall be denied. Subrecipes that are part of a linked recipe set are required only to be verified but not linked. The selection process completes abnormally whenever an error is detected, including the failure to locate a specified recipe or to successfully store it, invalid parameter settings, an attempt to select an unverified recipe, and other validation errors. The select recipe operation is invoked with the RMESelect service. 11.2.7.1 Multiple Selection — Executing agents that support subclasses of the PROCESS class shall provide at least one of two methods for the selection of multiple recipes: (1) they may either allow, or require, that a request for recipe selection explicitly specify a recipe from each of certain subclasses, and/or (2) they may either allow, or require, specification of required subclasses within a linked set of multi-part recipes. Such additional permissions and restrictions shall be included in\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 14)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: the recipe management documentation. For executing agents that support multi-part recipes (such as described in method 2 above), the recipe executor is responsible for validating, as a set, the main recipe and all its subrecipes listed in the LinkList attribute of the main recipe as a condition of execution. If the namespace is specified as \"Default\", the default namespace is used. The name of this namespace is the value in the recipe executor attribute DefaultNamespace (see Section 6.4 and 6.7). All recipes in the linked recipe set are considered to be selected if the select operation is successful. 11.2.7.2 Validation — Validation consists of type and range-checking of recipe settings and parameters, and of confirmation that the recipe is valid for the current hardware configuration. Validation shall occur as part of the process of selection. For recipe executors that require several different classes of recipe, validation may depend on the recipes that are selected as a set. For example, a\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 15)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: diffusion furnace may have a class of recipe that is used for the current gas configuration to map gases to valves. The furnace's normal process recipe that uses names of gases can only be validated in combination with the gas configuration table selected at the same time. 11.2.7.3 Delegation — If delegated recipes are specified in LinkList, it is the responsibility of the recipe executor to ensure that the designated recipe is accessible to the recipe executor of the component agent at the time it is selected. Otherwise, the select request shall be denied. 11.2.7.4 Variable Parameters — For recipes with variable parameters, new initial values for some or all of its parameters may be specified as part of the selection as a parameter name and parameter initial value pair. Parameter values specified as part of the selection take precedence over those initial values defined in the ExecLinkParam attribute. However, parameter restrictions may not be changed when selecting a recipe. All parameter values\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 16)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: that are set either prior to, or during12, the execution of a recipe shall satisfy the conditions of the parameter restriction. If a parameter restriction is given in the ExecLinkParam attribute, then that restriction is used for all occurrences of the parameter. 11.2.7.5 Message Scenarios — There are two possible message flows between the recipe executor and the service user for the select service. If the recipe executor is able to locate the recipes in its local storage, to validate them as a set, and to ready them for execution in a timely manner, then it may indicate the results of the select operation in the response message, as illustrated in Figure 11.1. Alternatively, the recipe executor may anticipate that the process of selection will require more time. In this case, it may send a response indicating the intent to perform the operation as soon as possible, prior to starting the operation. The notification message RMEComplete is sent when all specified recipes are selected or when a\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations (Part 17)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 11  Recipe Executor Operations\n\nContent: selection failure occurs. Exactly one notification message is sent, as illustrated in Figure 11.2.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification (Part 1)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification\n\nContent: If all recipes are located and in local storage, the recipes are validated as a set. 11.2.7.6 Selected Recipes — Once a recipe and its associated subrecipes have been selected, they shall be fully protected from inadvertent (unintentional) change, including change through download, overwrite, deletion, and renaming operations. The recipe executor attribute RecipeSelectID shall be set to the list of currently selected recipes, including all main recipes specified in the select request and all subrecipes within a linked recipe set. The attribute RecipeSelectParam shall be set to the list of all variable parameter definitions currently in effect following selection and prior to the start of actual recipe execution. 11.2.7.6.1 Select Errors — If the recipe executor is unable to locate a recipe specified for selection in its storage, it is responsible for obtaining the recipe from the designated namespace included in the recipe specifier. Possible errors resulting from the select operation\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification\n\nContent: include: Failure to specify recipes from each of the subclasses that it requires, Failure to validate a recipe, Failure to locate a recipe in a specified namespace, Failure to locate a recipe, and An attempt by the user to select an unlinked recipe. The select recipe operation is invoked with the RMESelect service. 11.2.8 Recipe Deselection — A selected recipe is deselected by making it unavailable for execution for the next (subsequent) processing cycle, deleting its identifier from the RecipeSelectID attribute, and deleting its parameter definitions from RecipeSelectParam attribute. This is a required operation. Only a main recipe that is currently selected may be specified for deselection. Deselecting a main recipe shall result in the simultaneous deselection of all of its subrecipes. If a recipe is deselected during execution, this shall have no effect until the current process cycle has completed. The recipe executor may have additional restrictions concerning deselection. The deselect\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification (Part 3)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification\n\nContent: recipe operation is invoked with the RMEDeselect service. 11.2.9 Get Execution Recipe Descriptor — The get execution recipe descriptors operation returns the descriptors of a specified execution recipe: the execution attribute descriptor, the generic attribute descriptor, and the body descriptor, in that order. This is a required operation. The execution recipe descriptor may be used to compare two execution recipes or a managed recipe and an execution recipe. The get execution recipe descriptor operation is invoked with the RMEGetDescriptor service. 11.2.10 Change Control — It is important to the user to be able to control change for execution recipes. In addition, it may be important to store recipes that were originated by the recipe executor in the managed environment of a recipe namespace. The recipe attribute ExecChgCtrl is used to accomplish both purposes. The ExecChgCtl attribute allows the user to control the modification of an existing execution recipe and its subsequent use.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification (Part 4)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification\n\nContent: ExecChgCtrl is a binary value that specifies permission for behavior related to changes. ExecChgCtrl uses bit settings to indicate permission in order to facilitate the different possible combinations. Values given below are in decimal: $1 \\ : = \\ :$ permission to change the body of the execution recipe $2 =$ requirement to notify the originating namespace of permitted changes $4 =$ permission to select (including re-selection of an already selected recipe) a changed recipe $~ 8 ~ =$ permission to save the last values of variable parameters in the ExecParam attribute 11.2.10.1 Changing Existing Recipes — Whenever the body is changed, the attributes ExecAttrLength, ExecChgTime, BodyLength, and EditTime shall be updated. The attribute ChangedBody shall be set to TRUE and remain set until the recipe is uploaded successfully to the originating recipe namespace. The ChangedBody attribute is reset when the upload request is received. It is not included in the uploaded attributes. Note that the\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification (Part 5)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification\n\nContent: attributes ExecAttrLength and ExecChgTime are not kept in the managed recipe stored in the namespace, and that the attributes AttrLength and AttrChgTime are not maintained by the recipe executor and are recalculated for the managed recipe when stored. If the ExecChgCtrl attribute permits both change and subsequent selection or re-selection (as for a currently selected recipe changed by the execution process itself), then the recipe's Linked attribute is not affected. Otherwise, if change is permitted but subsequent selection is not permitted, then the Linked attribute of the main recipe shall be cleared (set to FALSE) to prevent any subsequent selection, and the recipe shall be automatically de-selected at the end of any current processing cycle. It shall not be available for selection until it has been uploaded, re-linked, and downloaded again, with its changes, by the originating namespace. 11.2.10.2 Creating New Recipes — A new execution recipe may be created by various mechanisms. Such\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification (Part 6)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification\n\nContent: mechanisms are beyond the scope of RMS. However, all such recipes shall be assigned an identifier that is not already in use by an execution recipe. It is not required that an originating namespace be assigned immediately in all cases. However, it must be provided before the recipe can be uploaded and placed in the management system. New identifiers assigned automatically by the recipe executor shall use the next available numeric version, in conformance with Section 3.2.3.3. A newly created recipe may not be executed. Its ChangedBody attribute shall be set to TRUE, and BodyFormat shall be set TRUE for non-text recipes. The attribute ExecChgCtrl shall be set to a value of 3 (1 plus 2) or higher. Other non-mandatory attributes shall be set to their default value. Since the Linked attribute is set to FALSE, the new recipe may not be executed as a main recipe. New recipes must be uploaded to a designated originating namespace for management purposes and subsequently downloaded after they have\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification (Part 7)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification\n\nContent: been linked. 11.2.10.3 Building Derived Form Recipes — A new recipe, with a new identifier, is also originated if recipe executor builds a derived object form recipe from an existing source form recipe. Requirements for the derived object form recipe are defined in Section 11.2.2.1. The manager of the originating namespace shall be notified when a derived object form recipe is built from a source form recipe where ExecChgCtrl requires notification of change for the original source form recipe. 11.2.10.4 Saving Last Value — Saving the most recent settings specified by the user in the attribute ExecLinkParam is a protected activity requiring explicit permission in ExecChgCtrl. A change notification requirement in ExecChgCtrl applies to the change of this attribute. Parameter values in ExecLinkParam are overridden by any parameter settings specified by the user at the time a recipe is selected. In this case, the last value of each parameter is stored in the appropriate parameter definition in\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification (Part 8)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMESelect with RMEComplete Notification\n\nContent: the ExecLinkParam attribute. If change notification is specified, the originating namespace shall be notified of this change. The attributes ExecLength and ExecChgTime shall be updated whenever this change is made. The body of the recipe in execution recipe storage shall not be changed for this purpose. 11.2.10.5 Change Notification — If ExecChgCtrl requires that the originating namespace be notified of changes, the notification service RMEChange is sent to the specified namespace indicating the type of change that has occurred.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMEChange Message Flow (Part 1)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMEChange Message Flow\n\nContent: The recipe executor may or may not have direct communication links with the namespace itself. However, in this case, the necessary links may be assumed to exist with the supervisor or other owner of the recipe executor, or it would not be possible for recipes to be downloaded in the first place. The originating namespace, on receipt of a change notification, is responsible for uploading the changed recipe and for synchronizing through the service RMERename any change in identifier that might result from changing a writeprotected recipe. 11.3 Table of Operations — Table 11.1 lists all the operations defined for recipes and namespaces. The column labeled \"Rqmt\" indicates those operations that are required for fundamental compliance to the RMS recipe execution resource. Table 11.1 Recipe Executor Operations 11.4 Recipe Executor Events — The recipe executor shall provide the Recipe Select and Recipe Deselect events. Recipe executors that are capable of originating a new execution recipe shall provide the New\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMEChange Message Flow (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RMEChange Message Flow\n\nContent: Execution Recipe event. Recipe executors that are capable of changing the body of an existing recipe shall provide an Execution Recipe Change Event. These events allow service users other than the originating namespace to receive notification whenever a new recipe is created or an existing recipe body is modified.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 12  Recipe Namespace Services (Part 1)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 12  Recipe Namespace Services\n\nContent: This section defines recipe management and namespace services (see Table 12.1), which begin with a prefix of RMN. RMS services used by distributed recipe namespaces and by the recipe executor are defined in later sections. Recipe management and recipe namespace services request that an operation be performed on a recipe within a namespace or on a namespace. Recipe management operations that change recipe attributes are invoked with the RMNAction or RMNVarPar requests. Certain activities that require extended time to complete may indicate the intent to comply in the response message and then provide confirmation with the RMNComplete message at the completion of each individual operation specified. Table 12.1 Recipe Namespace Services 12.1 Recipe Management Message Parameter Dictionary — Table 12.2 contains the definitions for message parameters, and their components, used by namespace services. For purposes of transferring a recipe with its components, it is regarded as having three types of sections:\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 12  Recipe Namespace Services (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 12  Recipe Namespace Services\n\nContent: a section containing the generic attributes, a section consisting of the body, and a section containing the attributes of the agent-specific dataset. The generic section is always transferred first, and the attributes AttrLength, AttrTimestamp, BodyLength, and EditTime are always sent first, in that order. This allows the length information to be immediately determined by the receiver. Agent-specific dataset sections are sent last, since the number of agent-specific datasets will vary. Descriptors are also regarded as consisting of sections for the generic descriptor, the body descriptor, and zero or more agent-specific descriptors. Each start of each section is identified with a text string reserved for that section type. Table 12.2 Recipe Management Parameter Dictionary 12.2 Message Flow — The flow of messages defined in RMS, between the service user and the service provider, are of two types. The first type, illustrated in Figure 12.1, applies to most namespace operations. A request message is sent\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 12  Recipe Namespace Services (Part 3)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 12  Recipe Namespace Services\n\nContent: from the service user, and the namespace manager returns a response message containing the appropriate information. The second type of message flow, illustrated in Figure 12.2, is used for messages that specify an operation to be performed that may require more time for completion than is allowed between a request and a response. In this case, the response to the request indicates an intent to complete the operation rather than actual completion. The operation is then performed on each of the specified recipes in turn, until each operation has completed, either successfully or with errors. Any errors that occurred are reported in the completion message. The second type of message flow may be used for notifying the service user of RMNAction that individual operations on recipes have been completed. The first type of message flow is used for all other namespace services.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Message Flow with Completion Notification (Part 1)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Message Flow with Completion Notification\n\nContent: The second type of message flow may be used for notifying the service user of RMNAction that individual operations on recipes have been completed. The first type of message flow is used for all other namespace services. 12.3 RMNCreateNS — The service user may request to create a new namespace and assign it a name (identifier). The request shall be denied if the owner agent already has a namespace with the new name. The parameters for RMNCreateNS are listed in Table 12.3. Table 12.3 RMNCreateNS 12.4 RMNDeleteNS — The service user may request to delete a namespace. If the namespace contains recipes, the request shall be denied. The parameters for RMNDeleteNS are listed in Table 12.4. Table 12.4 RMNDeleteNS 12.5 RMNRenameNS — The service user may request to rename a namespace. The request shall be denied if the owner agent already has a namespace with the new name. The parameters for RMNRenameNS are listed in Table 12.5. Table 12.5 RMNRenameNS Service 12.6 RMNSpaceInquire — The service user\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Message Flow with Completion Notification (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Message Flow with Completion Notification\n\nContent: may request the amount of space available for recipes. The parameters for RMNSpaceInquire are listed in Table 12.6. Table 12.6 RMNSpaceInquire 12.7 RMNRcpStatInquire — The service user may request the current write-protection status of a recipe and the next available numeric version for a recipe of the same class and name. The parameters for RMNRcpStatInquire are listed in Table 12.7. Table 12.7 RMNRcpStatInquire 12.8 RMNVersionInquire — The service user may request the best version (highest) for a recipe with given qualifiers of class, name, and (optionally) agent. The parameters for RMNVersionInquire are listed in Table 12.8. Table 12.8 RMNVersionInquire 12.9 RMNCreate — A service user may request to initialize a new recipe in a namespace with a body created elsewhere. The requestor is required to supply the attributes of the recipe body. If the requested recipe identifier is used by a read-only recipe, the request shall be denied. The parameters for RMNCreate are listed in Table 12.9.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Message Flow with Completion Notification (Part 3)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Message Flow with Completion Notification\n\nContent: 12.10 RMNUpdate — The service user requests to replace an existing recipe body in a namespace with an updated body. If the requested recipe identifier is used by a read-only recipe, the request shall be denied. The parameters for RMNUpdate are listed in Table 12.9. Table 12.9 RMNCreate and RMNUpdate 12.11 RMNStore — The service user may request to store a recipe in a namespace. If the recipe identifier is already in use by a read-only recipe in the namespace, or if the namespace has insufficient space for storing the recipe, request shall be denied. The parameters for RMNRetrieve are listed in Table 12.10. Table 12.10 RMNStore 12.12 RMNRetrieve — The service user may request to receive a recipe in its entirety (including all agentspecific datasets), the generic attributes with or without the body but without agent-specific datasets, a particular agent-specific dataset, or all agent-specific datasets. The parameters for RMNRetrieve are listed in Table 12.11. Table 12.11 RMNRetrieve 12.13\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Message Flow with Completion Notification (Part 4)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Message Flow with Completion Notification\n\nContent: RMNCopy — The service user may request to copy a recipe in a namespace to another recipe within the same namespace. If a read-only recipe with the specified Destination ID exists, an Access Denied error shall be returned. The parameters for RMNCopy are listed in Table 12.12. 12.14 RMNRename — The service user may request to rename a recipe in a namespace if the recipe is not write-protected. If the recipe is write-protected, then an Access Denied error shall be returned. The parameters for RMNRename are listed in Table 12.12. Table 12.12 RMNCopy, RMNRename 12.15 RMNAction — RMNAction is used to request the performance of one of the following actions (operations) on one or more recipes: delete, protect, verify, link, unlink, certify, de-certify, download to a specified agent, and upload from a specified agent. Where more than one recipe is specified, operations shall be performed on each recipe in the requested order. If performance of the requested action is likely to take more time to\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Message Flow with Completion Notification (Part 5)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Message Flow with Completion Notification\n\nContent: complete than is normally allowed between a request message and the corresponding response, then the namespace manager should respond with an intent to comply at the earliest opportunity before it begins the requested operation. Immediately following the completion of the operation on each of the specified recipes, the manager shall send a notification message RMNComplete to the service requestor, providing the results of that operation together with information concerning any errors causing abnormal completion of the operation. Error information is important for diagnosis and correction of problems. Figure 12.2 in Section 12.2 shows an example of the message flow for the download operation performed on two recipes. The parameter LinkID is set to a zero value in the response if the operations have been completed and no notifications will be sent. Otherwise, it is set to a nonzero value, and the value set in the parameter RMOpID shall be retained for use in RMNComplete. The parameters for\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Message Flow with Completion Notification (Part 6)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Message Flow with Completion Notification\n\nContent: RMNAction are listed in Table 12.14. Table 12.14 RMNAction 12.16 RMNVarPar — The service user may request to set agent-specific variable parameter definitions. NOTE: Modification of the parameter restrictions in a variable parameter definition shall reset the Certified attribute for that agent. The parameters for RMNVarPar are listed in Table 12.15. Table 12.15 RMNVarPar 12.17 RMNGetDescriptor — The service user may request the descriptors of one or more recipes. The parameters for RMNGetDescriptor are listed in Table 12.13. Table 12.13 RMNGetDescriptor 12.18 RMNComplete — The service provider notifies the service user that an action requested by the service user has completed. The parameter RMOpID is retained from the initial request message RMNAction. The parameter LinkID is set to a non-zero value for all notifications except the notification of completion of the last operation performed. A zero value indicates that no further notifications will be sent. The parameters for RMNComplete\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Message Flow with Completion Notification (Part 7)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Message Flow with Completion Notification\n\nContent: are listed in Table 12.16. Table 12.16 RMNComplete\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 13  Distributed Recipe Namespace Services (Part 1)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 13  Distributed Recipe Namespace Services\n\nContent: This section defines the new message services required for implementation of distributed recipe namespace services. Table 13.1 lists the messages, the type of each message (request or notification), and provides a brief description. Table 13.1 Distributed Recipe Namespace Services 13.1 Distributed Recipe Namespace Message Parameter Dictionary — This section defines, in alphabetical order, the parameters that are used in distributed recipe namespace services and are not already defined in Table 12.2 in Section 12. Table 13.2 contains the definitions for message parameters. 13.2 Distributed Recipe Namespace Segment Services 13.2.1 RMDSApproveAction — A distributed recipe namespace manager may approve or deny a change request that the segment requested at an earlier time. Parameters for RMDSApproveAction are listed in Table 13.3. Table 13.3 RMDSApproveAction Service 13.3 Distributed Recipe Namespace Recorder Services 13.3.1 RMDRAddSegRecord — A recorder’s manager may request the recorder to\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 13  Distributed Recipe Namespace Services (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 13  Distributed Recipe Namespace Services\n\nContent: add a segment record. Parameters for RMDRAddSegRecord are listed in Table 13.4. 13.3.2 RMDRDelSegRecord — A recorder’s manager may request the recorder to delete a segment record. Parameters for RMDRDelSegRecord are listed in Table 13.5. 13.3.3 RMDRAddChgRecord — A recorder’s manager may request the recorder to add a change request record. Parameters for RMDRAddChgRecord are listed in Table 13.6. Table 13.6 RMDRAddChgRecord Service 13.3.4 RMDRDelChgRecord — A recorder’s manager may request the recorder to delete a change request record. Parameters for RMDRDelChgRecord are listed in Table 13.7. 13.3.5 RMDRGetChgRecord — A service user may request an attached recorder to return the current change request record(s) for a recipe or an attached DRNS segment. Parameters for RMDRGetChgRecord are listed in Table 13.8. Table 13.8 RMDRGetChgRecord Service 13.4 Distributed Recipe Namespace Manager Services 13.4.1 RMDComplete — An attached segment notifies its manager when it has completed an approved\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 13  Distributed Recipe Namespace Services (Part 3)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 13  Distributed Recipe Namespace Services\n\nContent: change to a recipe. The parameter RMOpID is retained from the initial request message RMNAction. The parameter LinkID is set to a non-zero value for all notifications except the notification of completion of the last operation performed. A zero value indicates that no further notifications will be sent. Parameters for RMDComplete are listed in Table 13.9. Table 13.9 RMDComplete 13.4.2 RMDNotify — An attached dedicated segment notifies its manager that it has changed an agent-specific dataset and provides the attribute AgentSpec_Agent and all updated attributes. Parameters for RMDNotify are listed in Table 13.10. Table 13.10 RMDNotify 13.4.3 RMDSegChange — An attached segment may request its manager’s approval to make a change. The recipe specifier RMRcpSpec shall include the requesting segment’s object type and name to identify the requestor and the specific instance of the logical recipe to be changed first. Parameters for RMDSegChange are listed in Table 13.11. Table 13.11\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 13  Distributed Recipe Namespace Services (Part 4)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 13  Distributed Recipe Namespace Services\n\nContent: RMDSegChangeService 13.4.4 RMDGetChangeRequests — A service user may request that all existing change requests for a recipe be returned. The first item returned is the active change request. Parameters for RMDGetChangeRequests are listed in Table 13.12. 13.4.5 RMDRebuild — A service user may request a distributed namespace manager to rebuild a distributed namespace. Parameters for RMDRebuild are listed in Table 13.13. Table 13.13 RMDRebuild Service\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 14  Recipe Executor Services\n\nThis section defines recipe executor services. Recipe executor services request that an operation be performed by the recipe executor and begin with the prefix RME.  \nCertain activities that may require extended time to complete shall provide confirmation with the RMEComplete message at the completion of each individual operation specified.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Table 14.1  Recipe Executor Services (Part 1)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Table 14.1  Recipe Executor Services\n\nContent: 14.1 Recipe Executor Message Parameter Dictionary — For purposes of transferring a recipe, it is regarded as having two types of sections: an attribute section containing the recipe’s attributes, and a body section consisting of the body. The attribute section is always transferred first, and the attributes ExecAttrLength, ExecAttrChgTime, AttrLength, AttrTimestamp, BodyLength, and EditTime are always sent first, in that order. This allows the length information to be immediately determined by the receiver. Descriptors are also regarded as consisting of sections for the attribute descriptor, the generic attribute descriptor, and the body descriptor. Each start of each section is identified with a text string reserved for that section type. Table 14.2 contains the definitions for message parameters. a. A recipe specifier may reference a recipe that is in a namespace and not in the recipe executor’s storage. 14.2 Message Flow — The flow of messages defined in RMS, between the service user and the\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Table 14.1  Recipe Executor Services (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Table 14.1  Recipe Executor Services\n\nContent: service provider, are of three types. The first type, illustrated in Figure 14.1, is the most common and applies to all recipe executor operations except for cases of RMEDnldVer, RMEVerify, and RMESelect. A request message is sent from the service user, and the recipe executor returns a response message containing the appropriate information. All activities that occur as a result of the request are completed before the response message is sent. The second type of message flow, illustrated in Figure 14.2, is used for messages that specify an operation to be performed that may require more time for completion than is allowed between a request and a response. In this case, the response to the request indicates an intent to complete the operation rather than actual completion. The operation is then performed on each of the specified recipes in turn, until each operation has completed, either successfully or with errors. Any errors that occurred are reported in the completion message. Message Flow\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Table 14.1  Recipe Executor Services (Part 3)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Table 14.1  Recipe Executor Services\n\nContent: with Completion Notification The second type of message flow may be used for notifying the service user of RMEDnldVer, RMEVerify, and RMESelect that individual operations on recipes have been completed. A third type of message flow consists of a single notification message, shown in Figure 11.3, sent by the recipe executor to inform the originating namespace of a new or changed execution recipe. (See Section 11.2.10.)\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Change Notification Message Flow (Part 1)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Change Notification Message Flow\n\nContent: 14.3 RMEDnldVer — The service user may request the recipe executor to download and verify an execution recipe. All unverified downloaded recipes are verified automatically. The service user may optionally specify a forced overwrite of any pre-existing unselected recipe with the same identifier. A currently selected recipe shall not be overwritten. If forced overwrite is not specified and a recipe with the same identifier is already in storage, the request to download is denied and the recipe is discarded. If the recipe executor performs a verification of the downloaded recipe, and if the verification is successful, then it shall return the information provided by the conditional parameters. Parameters for RMEDnldVer are listed in Table 14.3. 14.4 RMEVerify — The service user may request the recipe executor to verify an execution recipe. If the verification is successful, then it shall return the information provided by the conditional parameters. Parameters for RMEVerify are listed in Table 14.4.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Change Notification Message Flow (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Change Notification Message Flow\n\nContent: Table 14.4 RMEVerify Service 14.5 RMEUpload — RMEUpload retrieves a recipe from local storage and sends it to the service user. Parameters for RMEUpload are listed in Table 14.5. 14.6 RMERename — RMERename changes the identifier of an execution recipe through changing one or more of its identification attributes. If the new identifier is already in use by an execution recipe, or if the recipe is currently selected, permission to rename the recipe shall be denied. Parameters for RMERename are listed in Table 14.6. Table 14.6 RMERename Service 14.7 RMESpaceInquire — The service user may request the amount of space available for recipes. The parameters for RMESpaceInquire are listed in Table 14.7. Table 14.7 RMESpaceInquire 14.8 RMEDelete — RMEDelete removes one or more recipes from local storage and frees any reusable storage area for new recipes. If the recipe is currently selected, permission to delete the recipe shall be denied. Parameters for RMEDelete are listed in Table 14.8. Table 14.8\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Change Notification Message Flow (Part 3)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Change Notification Message Flow\n\nContent: RMEDelete Service 14.9 RMESelect — The service user may specify one or more recipes to be selected for execution. RMESelect is the only service of the recipe executor that allows the service user to specify more than one recipe in a single request. Parameters for RMESelect are listed in Table 14.9. Table 14.9 RMESelect Service 14.10 RMEDeselect — The service user may deselect a recipe to prevent its re-execution. Parameters for RMEDeselect are listed in Table 14.10.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Table 14.10  RMEDeselect Service\n\n14.11  RMEGetDescriptor — The service user may request the descriptors of one or more recipes.\nParameters for RMEGetDescriptor are listed in Table 14.11.  \nTable 14.11  RMEGetDescriptor  \n14.12  RMEChange — The service provider informs an originating namespace that a permitted change has occurred.  \nParameters for RMEChange are listed in Table 14.12.  \n14.13  RMEComplete — The service provider notifies the service user that an action requested by the service user has completed.  \nParameters for RMEComplete are listed in Table 14.13.  \nTable 14.13  RMEComplete Service\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 15  Recipe Management Compliance (Part 1)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 15  Recipe Management Compliance\n\nContent: This section gives a centralized reference location for compliance for RMS objects. It provides references to other sections of the standard where detailed requirements are located. This section also defines standard terminology and documentation related to RMS compliance that can be used by agent suppliers and device manufacturers to describe compliance with this standard. Each object defined by RMS has both fundamental requirements and additional capabilities. Fundamental requirements shall be met by all instances of an RMS-compliant object as specified in cited sections. Additional capabilities consist of those features that are optional. However, for RMS compliance, where features providing the same or similar capabilities are implemented, they shall be implemented according to RMS specifications. Except where one or more subsections are specifically excluded, section references include all subsections of the referenced section. The following table format is used in this section to specify\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 15  Recipe Management Compliance (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 15  Recipe Management Compliance\n\nContent: fundamental and additional (optional) capabilities Fundamental capabilities have a \"Y\" in the column labeled \"Fund.\" Otherwise, the capability is optional. 15.1 Areas of Compliance — There are seven areas of RMS compliance, as follows: a. Managed Recipe b. Recipe Namespace Management c. Distributed Recipe Namespace Management e. Distributed Recipe Namespace Recorder d. Distributed Recipe Namespace Segment f. Execution Recipe g. Recipe Executor 15.2 Managed Recipe — This section defines RMS compliance for the managed recipe. A managed recipe has attributes, a body, and is capable of supporting at least one agent-specific dataset. An RMScompliant managed recipe reflects its compliance (a) through its attributes and (b) through its structure when it is transferred. In some cases, a capability is represented by a single attribute. In other case, support of an additional capability requires several attributes that are required as a set. Table 15.1 describes the requirements for compliance to the managed\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 15  Recipe Management Compliance (Part 3)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 15  Recipe Management Compliance\n\nContent: recipe. \\* At least one of the two forms is required. 15.3 Managed Recipe Compliance Table — Table 15.2 provides a statement of compliance for the managed recipe. 1 Do not mark YES unless all fundamental RMS requirements are implemented. 2 Additional capabilities may not be marked RMS compliant unless all fundamental RMS requirements are implemented. 15.4 Recipe Namespace Management — Recipe Namespace Management requires compliance to specifications for the managed recipe, the recipe namespace, and the recipe namespace manager. 15.4.1 Recipe Namespace — This section defines RMS compliance for the recipe namespace object. A recipe namespace exhibits RMS compliance through its attributes and access to managed recipes. NOTE: Operations and services are performed by the recipe manager. Table 15.3 describes the requirements for compliance to the recipe namespace. 15.4.2 Recipe Namespace Manager — Table 15.4 describes RMS compliance for the recipe namespace manager. 15.4.3 Recipe Namespace Management\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 15  Recipe Management Compliance (Part 4)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 15  Recipe Management Compliance\n\nContent: Compliance Table — Table 15.5 provides a statement of compliance for recipe namespace management. 3 Do not mark YES unless all fundamental RMS requirements are implemented. 4 Additional capabilities may not be marked RMS compliant unless all fundamental RMS requirements are implemented. 15.5 Compliance for Distributed Recipe Namespace Management — Compliance for distributed recipe management requires compliance to the following objects: managed recipe . recipe namespace distributed recipe namespace C recipe namespace manager • distributed recipe namespace manager 15.5.1 Distributed Recipe Namespace — Table 15.6 describes the requirements for compliance for the distributed recipe namespace. 15.5.2 Distributed Recipe Namespace Manager — Table 15.7 describes the requirements for compliance to the distributed recipe namespace manager. 15.5.3 Distributed Recipe Namespace Management Compliance Table — Table 15.8 provides a statement of compliance for distributed recipe namespace management. 5 Do not mark\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 15  Recipe Management Compliance (Part 5)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 15  Recipe Management Compliance\n\nContent: YES unless all fundamental RMS requirements are implemented. 15.6 Distributed Recipe Namespace Segment — Table 15.9 describes the requirements for compliance to the distributed recipe namespace segment. 15.6.1 Distributed Recipe Namespace Segment Compliance Table — Table 15.10 provides a statement of compliance for the distributed recipe namespace segment. 6 Do not mark YES unless all fundamental RMS requirements are implemented. 7 Additional capabilities may not be marked RMS compliant unless all fundamental RMS requirements are implemented. 15.7 Distributed Recipe Namespace Recorder — Table 15.11 describes the requirements for compliance to the distributed recipe namespace recorder. 15.7.1 Distributed Recipe Namespace Recorder Compliance Table — Table 15.12 provides a statement of compliance for the distributed recipe namespace recorder. 8 Do not mark YES unless all fundamental RMS requirements are implemented. 15.8 Execution Recipe Compliance — This section defines RMS compliance for the\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 15  Recipe Management Compliance (Part 6)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 15  Recipe Management Compliance\n\nContent: execution recipe. An execution recipe exhibits RMS compliance (1) through its attributes and (2) through its structure when transferred. Table 15.13 describes the requirements for compliance to the execution recipe. 15.8.1 Execution Recipe Compliance Table — Table 15.14 provides a statement of compliance for the execution recipe. Table 15.14 Execution Recipe Compliance Table 9 Do not mark YES unless all fundamental RMS requirements are implemented. 10 Additional capabilities may not be marked RMS compliant unless all fundamental RMS requirements are implemented. 15.9 Recipe Executor — Table 15.15 describes requirements for compliance for the recipe executor. The recipe executor exhibits RMS compliance through its attributes, behavior, and services. 15.9.1 Recipe Executor Compliance Table — Table 15.16 provides a statement of compliance for the recipe executor.\n\n11  Do not mark YES unless all fundamental RMS requirements are implemented. 12  Additional capabilities may not be marked RMS compliant unless all fundamental RMS requirements are implemented.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 1)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: The list of terms in this section is intended only as a guide. Formal definitions are provided in the main body of the document. agent — A type of resource system in a factory that includes both hardware and software components, at least some of which are also resources. Examples of agents include recipe namespace servers, cells, stations, clusters, attached cluster modules, equipment, and smart equipment subsystems. Agents are associated with a physical system or a collection of physical systems, including computer platforms. agent-specific attribute — A recipe attribute that applies only to a specific agent. agent-specific parameter — A variable parameter that has been “tuned” for a specific agent by modifying its original initial value and/or restrictions and placing the result in the agent-specific attribute AgentSpecific LinkParam. agent-specific recipe — A recipe stored in the default namespace of a specific agent. agent-specific dataset — The recipe component containing the set of agent-specific\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: attributes that have been set for that recipe for a specific agent. approve The operation that sets a recipe's ApprovalLevel attribute to a non-zero value. approved — A recipe is approved whenever its ApprovalLevel attribute is non-zero. approval level — (1) Used to reflect different degrees of recipe development and qualification; (2) The value of the attribute ApprovalLevel. attribute — Information concerning an object that may be used either for internal or external purposes. attribute length — The length of an individual attribute, calculated as the sum of the lengths of the attribute name and the attribute value, exclusive of formatting information. attribute length attribute — An attribute that contains the sum of the lengths of the attributes. A managed recipe, agent-specific dataset, and execution recipe each have their own attribute length attribute. attribute timestamp attribute — The timestamp of the last change to any of a recipe's attributes. authorized user — A user who is able to identify him\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 3)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: or herself to the host or equipment as having the level of authority required for a particular activity, such as certifying a recipe for that equipment. centralized namespace — A recipe namespace that is not distributed. certification-level — The value of the attribute Certified. certified — (1) Factory-level approval that a recipe produces the expected results on a particular instance of equipment; (2) A recipe for which the Certified attribute is defined and given a non-zero value for a specific agent. certify — The operation of changing the certificationlevel of a recipe for an installation of equipment. class — See recipe class. clear — An attribute is cleared (reset) by setting its value to its default value. component agent — A subordinate agent that provides services to a supervisory agent. copy — Originate a recipe by the internal operation of duplicating a recipe and assigning a new identifier. create — The operation of entering a recipe body into a namespace and assigning it a new (unused)\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 4)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: identifier. de-certify — The operation of clearing the certification level (Certified attribute) for a specific agent. dedicated namespace — A recipe namespace with exactly one member. default namespace A dedicated, centralized namespace that is used by standalone equipment and/or for hardware-specific (agent-specific) recipes. default value — A pre-defined value. All nonmandatory recipe attributes are assigned a default value as part of their definition. An attribute set to its default value may be omitted when a recipe is transferred. delegate — An agent's supervisor delegates a recipe that is executed by its component agent. The delegating agent is responsible for ensuring that the component has access to a current copy of the recipe and that the recipe is selected, started, and deselected at the proper time. delete — A recipe is deleted by removing its identifier, preventing further access, and freeing its storage. derived object form — An object form of a recipe that is based upon a recipe in source form\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 5)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: and that represents a more efficient format for execution purposes. Typically, but not by definition, this is a “tokenized” form and requires less storage. descriptor — (1) The length and timestamp attributes of a recipe's attributes or of one of its components; (2) The set of all of the individual descriptors of a recipe. body — See recipe body. deselect — The operation that prevents a selected recipe from subsequent execution without its first being selected again. distributed recipe namespace — A namespace that is capable of using namespace segments provided by multiple agents. download — To send a recipe to the recipe executor. edit — An operation which creates a new recipe body or changes the body of an existing recipe. editor — A service which allows a user to create or modify the contents of the recipe body. Editors are not defined by RMS and are generally considered as external to a namespace. eol — The ASCII line-feed character $\\left( 0 \\mathrm { A } _ { 1 6 } \\right)$ signifying the end of a line\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 6)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: of text. empty — An attribute with a binary, list, or text format with no content. end of line character — See eol. equipment — An agent with associated hardware that provides, at a minimum, recipe execution services. event — A detectable occurrence of interest to a service user. exception — An irregular event that indicates some abnormal or unacceptable condition that requires attention but does not constitute a safety hazard. Within RMS, exceptions indicate the abnormal completion of an operation. execute — An agent executes a recipe by reading the recipe contents and implementing its instructions, process parameters, or other information required for its own processing. executing agent — The agent that is capable of executing a specific recipe. execution area — The storage location of the recipe(s) currently selected (ready) for execution. executable copy — A selected recipe, or “copy” of a selected recipe, which is in the execution area. execution recipe — The subtype of recipe that is stored by the\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 7)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: recipe executor. execution recipe descriptor — Consists of the execution attribute description, the generic attribute description, and the body descriptor, in that order. execution recipe storage — Storage for recipes provided by the recipe executor for recipes that are not currently selected. external reference — (1) The reference which a recipe makes to another recipe; (2) The list of subrecipes referenced by a parent recipe. forced overwrite — The replacement of an existing execution recipe with a downloaded recipe with the same identifier. fundamental requirements — The requirements for information and behavior that must be satisfied for compliance to the Recipe Management Standard. Fundamental requirements apply to specific areas of application or objects. generic attribute — A recipe attribute that applies to all agents capable of executing a specific recipe. get available storage — The operation that calculates the amount of remaining recipe storage capacity, in bytes, exceeding overhead requirements.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 8)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: header length — The sum of the lengths of the attributes the header contains at the time the calculation is performed. host — A supervisory agent that represents the factory to its subordinates. identification attribute — An attribute that is used to identify a specific object and that is not included in a recipe section when a recipe is transferred. identification code — A text string containing a unique and persistent “signature” for the recipe executor that last performed verification on a recipe. identifier — One or more attributes of an object that uniquely identify it within a specific context. last value — The setting for a variable parameter specified by the user when the recipe was last selected for execution. link — The operation performed on a main recipe that collects and resolves external references, and collects variable parameter definitions, for that recipe and all referenced recipes. linked recipe set — The set of recipes identified by the link operation and specified by the attribute\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 9)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: LinkList. logical recipe — A recipe with a particular set of attributes and a particular body considered independently from its physical location. A logical recipe may have multiple instances or copies. main recipe — (1) The recipe, within a set of one or more recipes to be linked together, which is not a subrecipe; (2) The starting recipe or “entry point” for a set of recipes. managed recipe — A recipe that is stored with a recipe namespace. mandatory attribute — A required attribute that always exists and has a non-default value. modify variable parameters — An operation that modifies the variable parameter definitions applied to a specific agent. name — A text-based attribute of an object that may be used as all or part of an identifier. Certain restrictions on its characters exist. (See SEMI E39.) namespace — A domain within which object identifiers are unique. Also see recipe namespace. namespace specifier — An object specifier applied to a recipe namespace. non-numeric parameter — Any variable parameter\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 10)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: that is not a numeric parameter. non-shared namespace — A recipe namespace that has at most one member. notification service — A service that does not expect a response. numeric parameter — Any variable parameters that can take on any numeric value for their format type, between a parameter low limit and a parameter high limit. These limits shall not exceed absolute minimum and maximum limits set for that parameter by the agent's supplier. numeric version — See version number. object form — (1) Any recipe not in text form; (2) The body of a recipe which has been compressed from the source form. (See also the generic attribute BodyFormat.) object specifier — A logical pointer to a remote object. See SEMI E39 (OSS). operator — The user who interacts locally with agent through the agent's human interface. originate — Any operation which produces a new recipe identifier, including copying, renaming, creating, editing a read-only recipe, and downloading a new version. originating namespace — The recipe namespace\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 11)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: from which an execution recipe was originally downloaded and/or to which it is to be uploaded. parameter — A control value that affects the agent's process. Also see variable parameter. parameter definition — A formal declaration of a variable parameter that specifies the parameter's name, initial value, and restrictions. parameter domain — The set of all possible values for a given form that fulfill the conditions of the parameter restriction (if any). parameter restriction — A required part of a parameter definition specifying one or more conditions that any value assigned to that parameter is required to satisfy to be valid. parent recipe — Any recipe with external references to subrecipes. primary class — A recipe class which is not a subclass of another class. PROCESS class — The required primary class for all recipes used for the agent's normal process. protect — The operation of changing the approval level of an individual recipe to that of the RecipeReadOnlyLevel attribute of the recipe namespace.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 12)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: read-only recipe — A recipe that is protected. A recipe with an approval-level greater than, or equal to, the value of the namespace attribute RecipeReadOnlyLevel cannot be changed by updating, deleting, renaming, unlinking, or re-linking. recipe — (1) The pre-planned and reusable portion of the set of instructions, settings, and parameters under control of the agent that determine the processing environment seen by the manufactured object and that may be subject to change between runs or processing cycles; (2) The aggregation composed of a generic header, zero or more agent-specific headers, and a recipe body. recipe attribute — Structured information concerning a recipe within the recipe header. recipe body — The contents of the recipe containing the data used for execution purposes. recipe class — A formal grouping of recipes with a common language syntax and functionality. managed recipe descriptor — Consists of the generic attribute descriptor and the body descriptor, followed by descriptors for any\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 13)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: agent-specific datasets. recipe execution area — Storage used for currently selected recipes (i.e., for the current process cycle). recipe executor — The component of an executing agent responsible for understanding and verifying the syntax and semantics of a recipe, for validating it, and for executing it. recipe identifier — Consists of the recipe's class, name, and version. recipe name — A user-defined text string used in the recipe identifier. The name corresponds to PPID in Stream 7 implementations. recipe namespace — A logical management domain for (1) the storage and management of recipes, and (2) the insurance of the uniqueness of recipe identifiers within that domain. recipe namespace manager (manager) The component of an agent that manages the recipe namespace and that represents the interface for the namespace to the external world. recipe namespace segment (segment) The component of a namespace that represents the internal storage and actual manipulation of recipes. recipe section — A partition of\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 14)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: the recipe for purposes of transferring it through an RMS service. All recipes have a section containing the generic attributes and a section containing the body. Some recipes also have a section containing the agent-specific attributes. recipe specifier — An object specifier applied to a recipe. recipe storage area — A storage area for recipes. rename — The operation of assigning a new identifier to a recipe or to a recipe namespace. request service — A service that requires a response. SERVICE class — An optional primary class used for recipes whose purpose is to maintain, prepare, calibrate, or test the operation of equipment. reset — See clear. resource — An owned entity that has an active role in factory operations. select — The act of preparing a recipe, or a linked recipe set, for execution. This includes confirmation that all specified subrecipes are available, that the attributes of the main recipe and all its referenced recipes meet execution requirements, that the recipes are validated as a set,\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 15)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: and that all other steps that may be necessary for the proper execution of the recipe have been performed. service — A service (or message service) represents a function offered to a user by a provider. A service is one of two types: a request or a notification. service resource — A set of services within a particular area of specialization, such as a recipe namespace resource or a recipe execution resource. setting — A static value accessible to the user, through one or more methods, that is used by agent to control its process. Settings include, but are not limited to, setpoint values. Settings typically may be specified within a recipe. shared namespace — A namespace with more than one member. source form — A recipe body which consists of one or more lines of text and which conforms to a formally defined recipe language. storage area — An area where objects and data are stored. See also recipe storage area. stored recipe attribute — An attribute of a recipe, a recipe header, or a recipe body, that is\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 16)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: stored as a name/value pair within a recipe header whenever the recipe is transferred. subclass — A class of recipes within a larger class. subrecipe — Any recipe which is referenced by another recipe within the same namespace. supervisory agent — An agent with supervisory responsibilities for one or more subordinate agents. Examples include a host manufacturing system and a cluster controller. timestamp — (1) The notation of the date and time of the occurrence of an event; (2) An attribute of a recipe header or recipe body that contains the date and time the particular section was last changed. This attribute is a text string of the form “yyyymmddhhmmsscc” for the year yyyy, the month mm, the day dd, the hour hh, the minutes mm, and the seconds ss. unlink — An operation that clears all attributes set by a link operation. unprotect — An operation that resets a recipe's ApprovalLevel attribute. (Set it to zero.) update — The operation of replacing the body of an existing recipe. upload — To transfer a recipe\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 17)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: body from the recipe executor. user — A person interacting with an agent directly through the agent's human interface or indirectly through the agent's supervisor. validate — The action of checking a recipe to ensure that the recipe and its parameters' type and range are valid for the agent's configuration at the time the recipe is selected for execution. [A recipe may be syntactically correct and yet may contain statements that cannot be executed under all configurations of the agent.] variable parameter — A formally defined variable (setting) defined in the body of a recipe (1) With a specified default value, boundaries or conditions for replacement values, and (where applicable) units, and which is placed in the Parameters attribute of the recipe when it is verified; (2) Permitting the actual value to be supplied externally by a parent recipe, or at the time the recipe is selected for execution by the supervisor or the operator. verification area Optional temporary storage provided for unverified\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 18)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: downloaded recipes. verify — The operation of (1) ensuring that a recipe is syntactically correct, and (2) identifying variable parameters and external references. version — A text string that is part of a recipe's identifier. version number — A version consisting only of the digits $^ { \\ 6 \\mathfrak { c } } 0 ^ { , 9 }$ through “9” and one decimal point character “.” that can be translated to a pure number. Only whole numbers (with no decimal point) and numbers with a decimal point that do not begin or end with a $^ { 6 6 } 0 ^ { 5 }$ may be used. whitespace — In ASCII, the space $( 2 0 _ { 1 6 } )$ , tab $( 9 _ { 1 6 } )$ , carriage return $\\left( 0 \\mathrm { D } _ { 1 6 } \\right)$ , and form feed $( 0 \\mathrm { C } _ { 1 6 } )$ characters. write-protect — See protect. NOTICE: These standards do not purport to address safety issues, if any, associated with their use. It is the responsibility of the user of these standards to establish appropriate safety and health practices and determine the applicability\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 19)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: of regulatory limitations prior to use. SEMI makes no warranties or representations as to the suitability of the standards set forth herein for any particular application. The determination of the suitability of the standard is solely the responsibility of the user. Users are cautioned to refer to manufacturer's instructions, product labels, product data sheets, and other relevant literature respecting any materials mentioned herein. These standards are subject to change without notice. The user’s attention is called to the possibility that compliance with this standard may require use of copyrighted material or of an invention covered by patent rights. By publication of this standard, SEMI takes no position respecting the validity of any patent rights or copyrights asserted in connection with any item mentioned in this standard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and the risk of infringement of such rights, are entirely their own\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms (Part 20)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # 16  Glossary of Terms\n\nContent: responsibility.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # RELATED INFORMATION 1\n\nNOTE: This related information is not an official part of SEMI E42 and is not intended to modify or supersede the official standard. Rather, these notes are auxiliary information provided as background or examples of possible application and are included as reference material. The standard should be referred to in all cases. SEMI makes no warranties or representations as to the suitability of the material set forth herein for any particular application. The determination of the suitability of the material is solely the responsibility of the user.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-1  RMS Standardized Objects\n\nThe standardized objects defined by RMS are shown in Table R1-1.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-2  RMS Requirements/Concepts Map\n\nTable R1-2 provides the specific RMS concepts that address each of the requirements from Table 2.1.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-3  Background (Part 1)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-3  Background\n\nContent: The material in this section provides a context for the Recipe Management Standard and is intended for background information only. In a complex environment, equipment and host become relative terms indicating roles of two independent agents with respect to each other. In general, both equipment and host may provide services to one another, and some services may be provided by both. In certain cases, one may provide services to its partner that the other does not. With respect to recipes, equipment refers to the recipe’s executor, whereas host represents a supervisory agent who may delegate recipes which will be executed by the equipment. For clusters, cells, and local-area stations, where a midlevel controller communicates both to lower-level components and to a higher level factory system, that controller may alternately take the role of host to its components and of equipment to the factory system. Where role is significant, the terms equipment and host are used in this section to indicate the relationship of\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-3  Background (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-3  Background\n\nContent: the two agents to one another. R1-3.1 Traceability — A main management objective in both a Development Fab and a Production Fab is traceability of manufacturing conditions to the final device characteristics. This traceability is required in a Development Fab to support the analysis and characterization of the process under development. Certain customers of a Production Fab require this traceability in order to do business. Even without such a customer requirement, traceability is important for process control and postmortem analysis of unexpected device characteristics. The recipe is the primary specification of manufacturing conditions to the equipment; therefore, the management of recipes is critical to this traceability. R1-3.2 Recipe Life Cycle — The lifetime of a recipe in a Fab typically has several phases, as illustrated in Figure R1-1. While being developed, it may contain errors, or it may not produce the desired results. The recipe may be edited several times during its initial development. At some\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-3  Background (Part 3)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-3  Background\n\nContent: point, the recipe enters the test phase, where it will be executed and its results evaluated. A check for syntax correctness occurs at or before the time the equipment prepares it for execution. Still further changes may be made to fine-tune the process to achieve a particular result. During this process, it is still desirable to be able to protect it from inadvertent change or deletion. Finally, the recipe is ready for production and goes through a series of signoffs which constitutes a formal authorization procedure. In many factories, only recipes which have been approved as production-worthy may be used in production runs. Figure R1-1\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Typical Recipe Life Cycle (Part 1)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Typical Recipe Life Cycle\n\nContent: Also, because results may vary between different installations of equipment, an additional level of authorization may be required that certifies individual equipment for a given approved recipe. A factory change control system must accommodate different levels of protection for recipes in different phases of their life cycle. To accomplish this, equipment must recognize and support the different requirements for each phase. R1-3.3 Recipe Editing — Traditionally, recipes are developed on the equipment that runs them. Besides requiring time on the target machine (a potentially scarce and expensive resource), this requires the person defining the recipe to be inside a clean area. A potential solution is for equipment manufacturers to provide versions of their dedicated recipe editors that can be integrated into the factory manufacturing systems. Aside from the difficulty of the equipment manufacturer supporting the variety of platforms currently in use internationally, even in a distributed factory\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Typical Recipe Life Cycle (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Typical Recipe Life Cycle\n\nContent: environment, a proliferation of different dedicated recipe editors required for the different types of equipment is not considered a good solution. A better solution is to permit editing external to the cleanroom and then to transmit the completed recipe to the equipment for verification. This can be achieved by providing a text form of the equipment manufacturer’s recipe language which can be created and modified with any standard text editor. This may not be possible with some types of recipes (e.g., pattern recognition programs for vision systems), but this restriction may be removed when the technology advances. Editing on the equipment may still be desirable, particularly in a Development Fab. When the equipment permits a recipe to be changed, the equipment must provide reporting mechanisms that inform the host of changes and allow the host’s change control system to operate. R1-3.4 Recipe Sharing — A Fab may have several installation of the same type of equipment (equipment with the same\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Typical Recipe Life Cycle (Part 3)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Typical Recipe Life Cycle\n\nContent: functionality and the same recipe language). Therefore, where possible, the same recipe should be able to be shared between different equipment of this same type. R1-3.5 Protection and Process Control — The primary goal of process control is to ensure that the final result of the manufacturing process does not change over time. This may be accomplished by both feedback and feedforward methods. These methods modify the settings used in the process. This requires two capabilities that seem to be in conflict: The definition of the process settings (the recipe) should not change. The process settings should change to counter the drift inherent in real processes. The first capability is particularly important in a Production Fab. Most Fab policies prohibit processes from changing after they have been approved for production. This is easy to build into a change control system on the host. However, if the equipment allows local editing, then it must also enforce this policy. Wholesale changes in a recipe are\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Typical Recipe Life Cycle (Part 4)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Typical Recipe Life Cycle\n\nContent: never necessary for the second purpose. Usually only a few parameter values are modified in small increments to effect control of the process. A well-defined process specifies the parameters that vary and their range of variation. For any given recipe, it must be possible for the host to specify different values of such parameters for each piece of equipment so that the recipe may be “tuned” for that equipment to produce uniform results. In addition, the process control agent, on the equipment or the host, may need the ability to calculate the parameter value changes for each run and to inform the equipment of the new values. Mechanisms are provided to support such interactions. R1-3.6 Recipe Selection — Typical operation of equipment requires an operator or the host to initially select the recipe to be run. Recipe selection may be specified implicitly within the definition of a higher order “process job”. In either case, the specification of a recipe is accomplished by referring to its recipe identifier\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Typical Recipe Life Cycle (Part 5)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # Typical Recipe Life Cycle\n\nContent: (i.e., the identifier used by the change control system) and, where needed to resolve ambiguity, its location. Once selected, a recipe is initiated by an appropriate start command, which may be explicitly given by the operator or host or implicitly given by the equipment when executing a higher order process job. Repeated runs of the same recipe may be accomplished via subsequent start commands without the necessity of formal recipe re-selection.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-4  Example of a Factory Implementation of Approval Levels\n\nA factory might implement different levels of approval by regulating the following levels of recipe approval on the equipment:\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-5  Examples of Variable Parameters (Part 1)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-5  Examples of Variable Parameters\n\nContent: The recipe body may have statements that allow parameters to be changed within fixed limits. For example, recipe BAKE;2.3 may contain statements such as: Parameter BakeTime of TIME minimum $\\mathit { \\Theta } = \\ 1 0 0$ seconds maximum $\\mathbf { \\lambda } = \\ 3 0 0$ seconds; TIME BakeTime • (200,100,300,”s”) /\\* default,min,max,units \\*/ that define the process parameter “BakeTime”, its initial value and restrictions. The BAKE;2.3 recipe may use the BakeTime parameter in further internal statements to determine the length of time a wafer is processed, such as: wait for TIME BakeTime; This parameter may then be set by a parent recipe as in Example (1) below or from the EqpSpec_PARAM attribute (see 5.3.1.4) or with a “Select Recipe” command from the host or operator. For example, a recipe “BAKE;2.3” may define a variable “BakeTime”, while a recipe “RAMP;1,0” may define a variable “RampSetPoint”. A parent recipe “XYZ” might contain external references in the text of the source form such as: or\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-5  Examples of Variable Parameters (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-5  Examples of Variable Parameters\n\nContent: (2) set RampSetPoint to 500; do RAMP(RampSetPoint); set Baketime to 120; do BAKE;2.3(BakeTime); /\\* 120 sec (2 min.) bake \\*/ or where “Time_A” and “Time_B” were both formally defined within XYZ. In example (1), no initial value is specified for RampSetPoint. In this case, when the main recipe is selected, the initial value specified either in EqpSpec_LinkParam or in Gen_LinkParam (that is the same as the definition in RAMP;2.3) is used. However, in this example, the parameter BakeTime is assigned a value by the parent recipe, and this supersedes any value from a recipe attribute or a “Select Recipe” command from the host or operator. In the example given, BakeTime is assigned a value outside of the declared domain. This should create an error when the recipe is verified. Examples (2) and (3) illustrate how subrecipes RAMP and BAKE may be referenced multiple times by a parent recipe, and the parent may provide different values with each reference (Example 2) or may define new parameters to use\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-5  Examples of Variable Parameters (Part 3)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-5  Examples of Variable Parameters\n\nContent: with different references (Example 3). In the above examples, PARAMETERS (set when each individual recipe is verified) and Gen_LinkParam (set when XYZ is linked) will contain parameter definitions as follows: BAKE;2.3 BakeTime\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-6  Applications of Object Services (Part 1)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-6  Applications of Object Services\n\nContent: Object Services are defined in SEMI E39 (Object Services Standard (OSS): Concepts, Behavior, and Services). This section provides a description of how these services may be applied for RMS. R1-6.1 Scope — Scope may be used to specify the namespace of interest. It may also be used to specify a namespace or recipe execution resource belonging to a component agent of the service provider. For example, scope allows a factory host to ask a cluster tool for the attributes of a cluster module. Scope may be used to point to one of several namespaces supported by an agent. R1-6.2 Filter — A filter may be used when asking a namespace for a list of recipe identifiers to limit the number of identifiers returned. For example, the service user may ask a namespace for a list of recipe identifiers that were edited by “Tom” (Attribute name $\\mathbf { \\Sigma } = \\mathbf { \\Sigma }$ “EditedBy”, Attribute value $: = { } ^ { 6 6 } \\mathrm { T o m } ^ { \\mathrm { , } }$ , Attribute Relation $\\mathbf { \\Sigma } =\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-6  Applications of Object Services (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-6  Applications of Object Services\n\nContent: \\mathbf { \\Sigma }$ “is equal to”) and that are linked (Attribute name $\\ O =$ “Linked”, Attribute value $\\ O =$ “TRUE”, Attribute Relation $\\ O =$ “is equal to”). R1-6.3 Complex Attributes — Object Services do not provide a way to change individual elements in an attribute with a structure or list form. To add, delete, or modify items in a list or structure, it is necessary to first get the current attribute value for the object of interest using the GetAttr service, to make the desired changes externally to the value, and then to write the new value using the SetAttr service.\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-7  Examples of RMS Application (Part 1)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-7  Examples of RMS Application\n\nContent: Figure R1-2 illustrates possible interactions between a namespace and namespace manager implemented on a factory system, a diskless equipment with a recipe executor, and an operator. Figure R1-2 Other examples would be similar. Interactions are primarily with external service users of namespace and recipe execution capabilities, and between namespace managers and recipe executors. Namespaces do not interact with one another. To copy a recipe from one namespace to another, an intermediary is required. This is not covered by RMS. NOTICE: These standards do not purport to address safety issues, if any, associated with their use. It is the responsibility of the user of these standards to establish appropriate safety and health practices and determine the applicability of regulatory limitations prior to use. SEMI makes no warranties or representations as to the suitability of the standards set forth herein for any particular application. The determination of the suitability of the standard is solely\n\nSEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-7  Examples of RMS Application (Part 2)\n\nTitle: SEMI E42-0704 RECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND MESSAGE SERVICES - # R1-7  Examples of RMS Application\n\nContent: the responsibility of the user. Users are cautioned to refer to manufacturer's instructions, product labels, product data sheets, and other relevant literature respecting any materials mentioned herein. These standards are subject to change without notice. The user’s attention is called to the possibility that compliance with this standard may require use of copyrighted material or of an invention covered by patent rights. By publication of this standard, SEMI takes no position respecting the validity of any patent rights or copyrights asserted in connection with any item mentioned in this standard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and the risk of infringement of such rights, are entirely their own responsibility.\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS)\n\nThis standard was technically approved by the Global Information & Control Committee and is the direct responsibility of the Japanese Information & Control Committee. Current edition approved by the Japanese Regional Standards Committee on April 30, 2004.  Initially available at www.semi.org June 2004; to be published July 2004. Originally published in 1996; previously published September 1997.\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # 1  Purpose\n\n1.1  This document maps the services and data of the parent document to SECS-II streams and functions and data definitions.\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # 2  Scope\n\n2.1  This document applies to all implementations of Recipe Management that use the SECS-II message protocol (SEMI E5).  \nNOTICE: This standard does not purport to address safety issues, if any, associated with its use.  It is the responsibility of the users of this standard to establish appropriate safety and health practices and determine the applicability of regulatory or other limitations prior to use.\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # 3.1  SEMI Standards\n\nSEMI E5 — SEMI Equipment Communications Standard 2 Message Content (SECS-II)  \nSEMI E42 — Recipe Management Standard: Concepts, Behavior, and Message Services  \nNOTICE: Unless otherwise indicated, all documents cited shall be the latest published versions.\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # 4  Terminology\n\nNone.\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # 5  Service Mapping\n\n5.1  Table 1 shows the specific SECS-II streams and functions that shall be used for SECS-II implementations of the services defined in RMS.  \n5.2  Request and notification messages are mapped to primary (odd-numbered) SECS-II functions and response messages are mapped to secondary (evennumbered) SECS-II functions.  \n5.3  In several cases, a common set of parameters allows more than one RMS services to be mapped to a single stream and function, with an additional SECS-II data item used to differentiate between the two services. RMNCreateNS and RMNDeleteNS both map to S15,F3/F4, RMNCreate and RMNUpdate both map to S15,F13/14, and RMNCopy and RMNRename both map to S15,F19/20.  \n$5 . 4 \\ \\mathrm { I n }$ addition, the notification messages RMNComplete, RMEComplete, RMEChange, RMDComplete, and RMDNotify all map to S6,F25/F26.  \nTable 1  Services Mapping Table\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # 6  Service Parameter Mapping (Part 1)\n\nTitle: SEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # 6  Service Parameter Mapping\n\nContent: 6.1 Table 2 shows the mapping between message parameters defined by RMS and data items defined by SECS-II. For parameters specified in the definitions of an RMS service, either the parameters themselves, or individual elements of complex parameters, map to a specific data item. Table 2 Service Parameters Item Mapping Table 6.2 There are also several data items that are used in the SECS-II messages which do not map to specific services parameters. Services with the same set of parameters are mapped to the same SECS-II message by adding an additional data item to differentiate between the services. In addition, SECS-II restrictions require multi-block primary messages to be preceded by a multi-block inquire/grant transaction defined within the same stream. For RMS messages, this requirement is satisfied with the S15,F1 and F2 messages. Data items defined for these two messages have no counterpart in RMS service parameters. 6.3 Table 3 contains the SECS-II data items that have no corresponding RMS service\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # 6  Service Parameter Mapping (Part 2)\n\nTitle: SEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # 6  Service Parameter Mapping\n\nContent: parameter: Table 3 Additional Data Item Requirements Table NOTICE: SEMI makes no warranties or representations as to the suitability of the standards set forth herein for any particular application. The determination of the suitability of the standard is solely the responsibility of the user. Users are cautioned to refer to manufacturer's instructions, product labels, product data sheets, and other relevant literature respecting any materials mentioned herein. These standards are subject to change without notice. The user’s attention is called to the possibility that compliance with this standard may require use of copyrighted material or of an invention covered by patent rights. By publication of this standard, SEMI takes no position respecting the validity of any patent rights or copyrights asserted in connection with any item mentioned in this standard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and the risk of infringement of such\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # 6  Service Parameter Mapping (Part 3)\n\nTitle: SEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # 6  Service Parameter Mapping\n\nContent: rights, are entirely their own responsibility.\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # RELATED INFORMATION 1\n\nNOTE: This related information is not an official part of SEMI E42.1 and is not intended to modify or supercede the official standard. Publication was authorized by full letter ballot procedures. Determination of the suitability of the material is solely the responsibility of the user.\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-1  RMS-Compliant Equipment with a Stream 7 Host (Part 1)\n\nTitle: SEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-1  RMS-Compliant Equipment with a Stream 7 Host\n\nContent: Semiconductor manufacturers with legacy systems, capable of communicating using Stream 7 messages only, may still take advantage of many of the Recipe Management concepts when used with equipment that is Recipe Management-compliant. This section contains guidelines and examples for maintaining recipe attributes within the body of a Stream 7 process program. R1-1.1 Recipe Identifier — Both the process program identifier PPID and the object identifier, including the recipe identifier, have a maximum length of 80 characters. Recipe class, name, and version number may be encoded into the data item PPID using the format required for the recipe identifier. “/CLASS1/CLASS2/.../CLASSn/NAME;VERSION” It is recommended that recipe class names be unique, allowing use of the form “/CLASS/NAME;VERSION” to ensure the length conforms to the maximum allowed in SECS-II. R1-1.2 Recipe Sections — All sections of the recipe are transferred together as the data item PPBODY. This allows all non-default\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-1  RMS-Compliant Equipment with a Stream 7 Host (Part 2)\n\nTitle: SEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-1  RMS-Compliant Equipment with a Stream 7 Host\n\nContent: values of recipe attributes to be preserved when a recipe is uploaded to the host and later downloaded back to equipment. There are two potential methods for formatting PPBODY. If the recipe body is a text file, it is recommended that all attribute values are translated into text, including numeric and boolean values, with boolean values represented by the strings “.T.” or “.F.”. The second recommended method, applicable to both source and object forms, uses the structure of one of the SECS-II messages containing the managed recipe, as illustrated in Figure 1, or of an execution recipe. A cluster tool supporting shared namespaces, for example, might require multiple agent-specific data sets, while single-process equipment types would not. R1-1.2.1 Structuring PPBODY Using Text — For purposes of transfer, recipes are regarded as composed of sections: The generic section, the body section, and zero or more agent-specific data-set sections (RMS, Section 12.1). This convention should\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-1  RMS-Compliant Equipment with a Stream 7 Host (Part 3)\n\nTitle: SEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-1  RMS-Compliant Equipment with a Stream 7 Host\n\nContent: also be maintained within PPBODY. The SECS-II messages used to transfer recipes (Stream 15, Functions 15 and 18) transfer the data-set sections last, because they are variable in number and are not always present. However, in a text format within PPBODY, it is generally easier to put all attributes before the body. Since RMS uses the end-of-line character for source form recipes, this convention is recommended to separate the logical components of the sections containing attributes as well. A few reserved keywords are sufficient as tags to identify significant components: SECTION, ATTRIBUTE, LIST, PARAMNAME, PARAMSETTING, and PARAMRULE are recommended for consistency. Keywords are in uppercase for visual impact and are not delimited except for use of whitespace and the line-feed character $\\mathbf { \\Omega } ( 0 \\mathbf { A } _ { 1 6 } )$ used as the end-of-line (eol) character. Whitespace is used to separate fields within a line. The symbol $\\lfloor \\rfloor$ is used here to\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-1  RMS-Compliant Equipment with a Stream 7 Host (Part 4)\n\nTitle: SEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-1  RMS-Compliant Equipment with a Stream 7 Host\n\nContent: represent whitespace, which is used both as a delimiter to separate fields within a line and also for optional visual effect. Each section begins with a section declaration of the form SECTION”text”(eol) where text is a section name, one of “Generic”, “ASDS”, “Body”. Two sections are separated with two eol characters together. The eol convention within the body section, however, must conform to the recipe language specifications provided by the equipment manufacturer. Each attribute begins with ATTRIBUTEAttributeName followed by the attribute value, which may be a single item, a list of single items, or a list of complex items, such as variable parameters. If a list, the keyword LIST precedes the values, each item in the list terminated with either a comma or, for the last item, the eol character. This becomes or for attributes consisting of lists of single items (e.g., LinkList or ExtRef). If the keyword LIST if followed by eol, this indicates a list of complex items. The eol\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-1  RMS-Compliant Equipment with a Stream 7 Host (Part 5)\n\nTitle: SEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-1  RMS-Compliant Equipment with a Stream 7 Host\n\nContent: character, in this case, also is used to terminate the individual items in the high-order list. An attribute consisting of a list of complex items should identify the individual fields of each complex item. Those attributes containing variable parameters (e.g., Parameters) are of the form Each individual field within a complex attribute value is delimited with the quotation mark (“) character. The eol character is used to terminate a section declaration, an attribute declaration, and a complex item within an attribute. The recipe body is preceded with SECTION “Body”(eol) followed by the recipe body in the form normally used by the equipment. In comparison of the two suggested formats, the advantage of the text form described in this section is that the attributes are human-readable and printable and therefore the user is able to modify those attributes that are not designated as read-only with a standard text editor. The advantage of the SECS-II form (Figure 1) is that the\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-1  RMS-Compliant Equipment with a Stream 7 Host (Part 6)\n\nTitle: SEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-1  RMS-Compliant Equipment with a Stream 7 Host\n\nContent: equipment is more easily able to support a host that is only capable of using Stream 7.\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-2  RMS-Compliant Recipe Management with Stream 7 Equipment (Part 1)\n\nTitle: SEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-2  RMS-Compliant Recipe Management with Stream 7 Equipment\n\nContent: For RMS-Compliant Recipe Management applications dealing with legacy Stream 7 equipment, the situation is more restricted. While an RMS-compliant equipment may preserve attributes by bundling them inside the PPBODY of a process program, this option is not available when the situation is reversed because the equipment determines the permissible format(s) within the recipe. Therefore, all attributes of the recipe must be completely maintained by the host. The host in this situation may provide a recipe namespace that is dedicated either to an individual equipment installation, to a group of equipment capable of sharing the same process programs, or both. If the equipment is compliant to Process Program Management as defined in SEMI E30 (GEM), then it will provide a collection event when the process program is created, changed, or deleted. Hosts that provide a dedicated recipe namespace for non-RMS equipment are able to use this event to trigger a process program upload\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-2  RMS-Compliant Recipe Management with Stream 7 Equipment (Part 2)\n\nTitle: SEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-2  RMS-Compliant Recipe Management with Stream 7 Equipment\n\nContent: and update the corresponding recipe. Most Stream 7 equipment use only a single type of process program. This defaults to the recipe class PROCESS. The equipment is unaware of the internal fields used by the recipe identifier. If it preserves the contents of PPID and does not impose its own restrictions, it may be desirable to use the format of the recipe identifier, in particular the version component. This would allow version control at the host. Some equipment maintains more than one type of process program and may distinguish between the different types either through providing additional Stream 7 messages, through naming conventions such as a “.ext” extension, through program length, or other devices. Downloading a process program in Stream 7 is equivalent to both the operation of “sending” a recipe to a different namespace (at the equipment) and to downloading a recipe to the recipe executor for execution. R1-2.1 Structuring PPBODY Using SECS-II Message Format —\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-2  RMS-Compliant Recipe Management with Stream 7 Equipment (Part 3)\n\nTitle: SEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-2  RMS-Compliant Recipe Management with Stream 7 Equipment\n\nContent: The second method of sending attributes within PPBODY is to use a SECS-II message structure that is used to send and receive recipes. Figure 1 illustrates using the structure of a managed recipe form S15,F13 and F16. Note that cluster tools may provide full recipe namespace capabilities for its modules, including shared namespaces for modules of a specific type. In this case, a cluster recipe may contain multiple agent-specific datasets $( \\mathrm { m } > 1 ) ,$ . Other equipment may be able to use the structure for the execution recipe. L,q $\\begin{array} { l } { ( \\mathfrak { q } \\ = \\ 1 , 2 , 3 ) } \\\\ { ( \\mathtt { r } \\ = \\ 0 \\ \\circ \\ r 2 ) } \\end{array}$ 1. L,r ) 1. <RCPSECNM> 2. L,g ${ \\mathfrak { g } } \\ = \\ \\#$ generic attributes) 1. L,2 1. <RCPATTRID > 2. <RCPATTRDATA > a. L,2 1. <RCPATTRID > 2. <RCPATTRDATA > 2. <RCPBODY> 3. L,m (m = # agent-specific datasets) 1. L,2 1. <RCPSECNM > 2. L,b 1. L,2 1. <RCPATTRID > 2. <RCPATTRDATA11> b. L,2 1. <RCPATTRID1b> 2.\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-2  RMS-Compliant Recipe Management with Stream 7 Equipment (Part 4)\n\nTitle: SEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-2  RMS-Compliant Recipe Management with Stream 7 Equipment\n\nContent: <RCPATTRDATA > m. L,2 1. <RCPSECNM > 2. L,c 1. L,2 1. <RCPATTRID > 2. <RCPATTRDATA > · c. L,2 1. <RCPATTRID > 2. <RCPATTRDATAmc> NOTICE: SEMI makes no warranties or representations as to the suitability of the standards set forth herein for any particular application. The determination of the suitability of the standard is solely the responsibility of the user. Users are cautioned to refer to manufacturer's instructions, product labels, product data sheets, and other relevant literature respecting any materials mentioned herein. These standards are subject to change without notice. The user’s attention is called to the possibility that compliance with this standard may require use of copyrighted material or of an invention covered by patent rights. By publication of this standard, SEMI takes no position respecting the validity of any patent rights or copyrights asserted in connection with any item mentioned in this standard. Users of this standard are expressly advised\n\nSEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-2  RMS-Compliant Recipe Management with Stream 7 Equipment (Part 5)\n\nTitle: SEMI E42.1-0704 STANDARD FOR SECS-II PROTOCOL FOR RECIPE MANAGEMENT STANDARD (RMS) - # R1-2  RMS-Compliant Recipe Management with Stream 7 Equipment\n\nContent: that determination of any such patent rights or copyrights, and the risk of infringement of such rights, are entirely their own responsibility.\n\nSEMI E53-0704 EVENT REPORTING\n\nThis standard was technically approved by the Global Information & Control Committee and is the direct responsibility of the Japanese Information & Control Committee. Current edition approved by the Japanese Regional Standards Committee on April 30, 2004.  Initially available at www.semi.org June 2004; to be published July 2004. Originally published December 1996.\n\nSEMI E53-0704 EVENT REPORTING - # 1  Purpose (Part 1)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 1  Purpose\n\nContent: 1.1 Access to process data in equipment is crucial for effective process monitoring and control in a semiconductor manufacturing facility. This standard addresses the communication needs of semiconductor equipment and other factory objects, such as cell controllers or recipe servers, with respect to the timely collection and reporting of such data. 1.2 The purpose of this standard is to provide a general purpose set of event reporting services that may be offered by equipment suppliers. This document may be referenced, in whole or in part, by other standards addressing higher level application domains. 1.3 The communications services defined here will enable standards based inter-operability of independent systems. They shall allow application software to be developed which can assume the existence of these services and allow software products to be developed which offer them. Information on the mapping of these services to special protocols (e.g., SECS II) are added as adjunct standards. 2.6 The services assume a communications environment in which a reliable connection\n\nSEMI E53-0704 EVENT REPORTING - # 1  Purpose (Part 2)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 1  Purpose\n\nContent: has been established between the user and the provider of the services. Establishing, maintaining, and releasing a connection is beyond the scope of this standard. NOTICE: This standard does not purport to address safety issues, if any, associated with its use. It is the responsibility of the users of this standard to establish appropriate safety and health practices and determine the applicability of regulatory or other limitations prior to use.\n\nSEMI E53-0704 EVENT REPORTING - # 3.1  SEMI Standards\n\nSEMI E5 — SEMI Equipment Communications Standard 2 Message Content (SECS-II)\n\nSEMI E53-0704 EVENT REPORTING - # 2  Scope (Part 1)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 2  Scope\n\nContent: 2.1 This standard is applicable to any stand-alone equipment, cluster module, cluster tool, or cell of automation in a factory. As such it addresses event reporting at all levels in the factory and equipment control hierarchy. 2.2 This standard requires significant communication and computational resources and is therefore not applicable at or below the level of I/O distribution (e.g., sensor bus) within the equipment. 2.3 This standard covers the reporting of data periodically and/or in response to events. Reports may also be requested on demand. 2.4 This standard presents a solution from the concepts and behavior down to the messaging services. It does not define the messaging protocol. 2.5 A messaging service includes the identification that a message shall be exchanged and definition of the data which is contained in that message. It does not include information on the structure of the message, how the data is represented within the message, or how the message is exchanged. This additional information is contained with the message protocol. The defined services may be\n\nSEMI E53-0704 EVENT REPORTING - # 2  Scope (Part 2)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 2  Scope\n\nContent: applied to multiple protocols. SEMI E30 — Generic Model for Communications and Control of SEMI Equipment (GEM) SEMI E38 — Cluster Tool Module Communications (CTMC) SEMI E39 — Object Services Standard: Concepts, Behavior, and Services SEMI E40 — Standard for Processing Management NOTICE: Unless otherwise indicated, all documents cited shall be the latest published versions.\n\nSEMI E53-0704 EVENT REPORTING - # 4  Terminology (Part 1)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 4  Terminology\n\nContent: 4.1 The following definitions are arranged in alphabetical order. Some terms are defined using terms defined elsewhere within this section. Other terms may be defined within SEMI’s Compilation of Terms. 4.1.1 attribute — a data item associated with an object. An attribute may be referenced by zero or more data reports. 4.1.2 behavior — the manner in which something functions; how an object acts and reacts, in terms of its state changes and message passing. 4.1.3 collection event — an event that may be used to initiate the collection and reporting of data. A collection event may trigger an event report. A collection event may also start or stop one or more trace reports. 4.1.4 data report — a data report is a list of attribute names for a single object. Data reports may be predefined by a factory object or defined dynamically by the service user. 4.1.5 default object — the object assumed when no object specifier is supplied. 4.1.6 event — represents the occurrence of a change in the condition of a system (e.g., lot complete, temperature over range). 4.1.7 event report\n\nSEMI E53-0704 EVENT REPORTING - # 4  Terminology (Part 2)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 4  Terminology\n\nContent: — a class of objects that has information related to an event and can be linked to user defined data reports and can send messages containing this information to a service user. 4.1.8 factory object — any identifiable object within the factory information and control architecture. Examples include equipment, a cluster process module, a cell controller, a recipe namespace server. 4.1.9 object — defined in the Object Services (SEMI E39). 4.1.10 object specifier — defined in the Object Services (SEMI E39). 4.1.11 services — a set of closely related messages. 4.1.12 service provider — a service provider is an application responsible for providing services to service users. NOTE 1: There may be one or more service users concurrently accessing a single service provider. It is the responsibility of the service provider to provide its services transparently to each service user. 4.1.13 service user — a service user is any application that uses the services. 4.1.14 trace report — a class of objects which provides to a service user a means for collecting periodic readings of\n\nSEMI E53-0704 EVENT REPORTING - # 4  Terminology (Part 3)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 4  Terminology\n\nContent: selected attributes of a system.\n\nSEMI E53-0704 EVENT REPORTING - # 4.2  Data Types (Part 1)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 4.2  Data Types\n\nContent: 4.2.1 form — type of data: float, positive integer, unsigned integer, integer, enumerated, boolean, text, formatted text, structure, list, ordered list. 4.2.2 float — a number represented by a mantissa and an exponent. It is used to represent numeric data which is continuous in value. 4.2.3 positive integer — May take the value of any positive whole number. Messaging protocol may impose a limit on the range of possible values. 4.2.4 unsigned integer — May take the value of any positive integer or zero. Messaging protocol may impose a limit on the range of possible values. 4.2.5 integer — May take the value of any negative or unsigned number. Messaging protocol may impose a limit on the range of possible values. 4.2.6 enumerated — May take on one of a limited set of possible values. These values may be given logical names, but they may be represented by any single-item data type. 4.2.7 boolean — May take on one of two possible values; TRUE or FALSE. 4.2.8 Text — A text string. Messaging protocol may impose restrictions, such as length or ASCII representation. 4.2.9\n\nSEMI E53-0704 EVENT REPORTING - # 4.2  Data Types (Part 2)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 4.2  Data Types\n\nContent: formatted text — a text string with an imposed format. This could be by position, by use of special characters, or both. 4.2.10 structure — a complex structure consisting of a specific set of items, of possibly mixed data types, in a specific arrangement. 4.2.11 list — set of one or more items that are all of the same form (one of the above forms). 4.2.12 ordered list — s list for which the order in which the items appear is significant.\n\nSEMI E53-0704 EVENT REPORTING - # 5  Conventions (Part 1)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 5  Conventions\n\nContent: 5.1 Harel State Model — This document uses the Harel State Chart notation to describe the dynamic behavior of the objects defined. An overview of this notation is presented in an appendix of SEMI E30. The formal definition of this notation is presented in Science of Computer Programming 8, “Statecharts: A Visual Formalism for Complex Systems,” by D. Harel, 1987. 5.1.1 Transition tables are provided in conjunction with the state diagrams to explicitly describe the nature of each state transition. A transition contains columns for transition #, current state, trigger, new state, action(s). The “trigger” (column 3) for the transition occurs while in the “current” state. The “actions” (column 5) include a combination of; 1) actions taken upon exit of the current state, 2) actions taken upon entry of the new state, and 3) actions taken which are most closely associated with the transition. No differentiation is made. 5.2 OMT Object Information Model — The object models are presented using the Object Modeling Technique developed by Rumbaugh, James, et al, in\n\nSEMI E53-0704 EVENT REPORTING - # 5  Conventions (Part 2)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 5  Conventions\n\nContent: “Object-Oriented Modeling and Design,” Prentice Hall, Englewood Cliffs, NJ, ©1991. Overviews of this notation are provided in an appendix of the Object Services SEMI E39. 5.3 Object Attribute Representation — The object information models for standardized objects will be supported by an attribute definition table with the following column headings: 5.3.1 The access column uses RO (read only) or RW (read and write) to indicate the access that users of object services have to the attribute. 5.3.2 A ‘Y’ or $\\mathbf { \\nabla } \\cdot \\mathbf { N } ^ { \\prime }$ in the requirement (rqmt) column indicates if this attribute must be supported in order to meet fundamental compliance for the service. 5.3.3 The form column is used to indicates the format of the attribute. See Section 4.2 for definitions.\n\nSEMI E53-0704 EVENT REPORTING - # 5.4  Service Message Representation (Part 1)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 5.4  Service Message Representation\n\nContent: 5.4.1 Service Resource Definition — The service resource definition table defines the specific set of messages for a given service group, as shown in the following table: 5.4.1.1 Type can be either notification (N) or request (R). Notification messages are initiated by the service provider. No response is expected. Request messages are initiated by the service user. Request messages ask for data or for an operation to be performed. Request messages expect a specific response (no presumption on the message content). 5.4.2 Service Parameter Dictionary — Each parameter should relate to either attributes from the object model or events of the dynamic model (Harel State Chart). All parameters to the services are listed in a single table or dictionary. The column headings for this parameter dictionary are as follows: 5.4.2.1 A row is provided in the table for each parameter of the service. The first column contains the name of the parameter. This is followed by columns describing the form and the contents of the parameter. 5.4.2.2 The description column\n\nSEMI E53-0704 EVENT REPORTING - # 5.4  Service Message Representation (Part 2)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 5.4  Service Message Representation\n\nContent: describes the meaning of the parameter and interrelationships with other parameters. 5.4.2.3 The form column is used to indicate the type of data contained in the parameter (see Section 4.2 for definitions) and the possible values it may take on. 5.4.2.4 To prevent definition of numerous parameters named “XxxList,” this document adopts the convention of referring to the list as “(list of) Xxx.” In this case, the definition of the parameter “Xxx” will be given, not of the list. Where a list is used in both the request and the response, the list order in the request is retained in the response. A list must contain at least one element unless zero elements are specifically allowed. 5.4.3 Service Message Definition — There is a table for each service showing the parameter detail. The column headings for the service detail are as follows: 5.4.3.1 The columns labeled req/ind and rsp/cnf link the parameters to the direction of the message. The message sent by the initiator is called the “request” (req). The receiver terms the message the “indication”\n\nSEMI E53-0704 EVENT REPORTING - # 5.4  Service Message Representation (Part 3)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 5.4  Service Message Representation\n\nContent: (ind). The receiver may then send a “response” (rsp), which the original sender terms the “confirmation” (cnf). 5.4.3.2 The request (req/ind) and response (rsp/cnf) entries can take on the following values:\n\nSEMI E53-0704 EVENT REPORTING - # 6  Overview (Part 1)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 6  Overview\n\nContent: 6.1 Event reporting provides a dynamic and flexible means by which the service user can receive notification of events and data relating to objects defined here and in other SEMI standards. 6.2 Figure 1 illustrates a simple event reporting situation. 6.7 Using Object Services — An event reporting service user can create reports dynamically by accessing attribute information using the object services (see SEMI E39) when they are provided (see Figure 3). 6.3 Event and variable identifiers may be defined by another standard with which equipment or an object complies. In either case, the definitions must be included in the documentation from the supplier. 6.4 The service user may define and access data reports using the event reporting request services. Data reports are sampled and sent by the service provider using the event reporting notification services. 6.5 Data reports may be pre-defined by the supplier. Such reports cannot be deleted and their report identifiers may not be used for dynamically created reports. 6.6 Multiple Service Users — In a more complex situation,\n\nSEMI E53-0704 EVENT REPORTING - # 6  Overview (Part 2)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 6  Overview\n\nContent: several service users may require simultaneous access to the event reporting services (ERS). In this case, the service provider manages data report definitions independently for each service user as shown in Figure 2. A copy of each pre-defined report is made for each service user. Support for more than one simultaneous service user is optional.\n\nSEMI E53-0704 EVENT REPORTING - # 7  Concepts (Part 1)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 7  Concepts\n\nContent: 7.1 Objects and Identifiers — Much of the discussion and specification for event reporting services relies on an understanding of object technology and modeling techniques. The use of object technology for ERS implementations is not required. Further, it is not required that ERS implementations be compliant to the Object Services Standard (OSS). This standard does specifiy mechanisms by which ERS can take advantage of OSS when those services are provided. 7.1.1 Events are associated with an object and data is stored in object attributes. To uniquely identify an event or an attribute the object to which it relates must first be identified. 7.1.2 An object may be a physical entity such as standalone process equipment, a cluster tool or a cluster module. An object may be an abstraction such as a recipe, a process job or a transfer job. An object may be defined by the equipment supplier, or by a standard with which the equipment complies. An example of a cluster tool, containing process modules, is used in this section as the service provider. This example is for\n\nSEMI E53-0704 EVENT REPORTING - # 7  Concepts (Part 2)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 7  Concepts\n\nContent: illustration purposes only. The same concepts apply for all factory objects as defined above. 7.1.3 Objects may be part of an object hierarchy or contained in other objects. The default object is the object which provides the service connection. In the case for batch processing equipment which is compliant to GEM, SEMI E30, the connection to the host is provided by the equipment and the equipment is the default object. Also, a cluster controller would be the default object of equipment containing process modules. However, from the point of view of the cluster controller, each connection to the service providers in each connected module would be the default object. For example, the processing management service of PM:ETCH would be a default object for that module connection. But, the cluster controller would have differernt default objects on each of its other service connections. 7.1.4 An object specifier, (see SEMI E39), identifies an object within the scope of the service provider. An object specifier consists of one or more object type and object instance identifier\n\nSEMI E53-0704 EVENT REPORTING - # 7  Concepts (Part 3)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 7  Concepts\n\nContent: pairs. For example, “PM:ETCH>” might be the object specifier of a process module $\\mathrm { \\ t y p e { = } P M }$ , identifier=ETCH) within a cluster tool. If the object specifier is omitted, then the default object is assumed. 7.1.5 Objects are considered local to the service provider even if they exist on a remote module. That means the service provider is responsible for detecting events and accessing data from those objects in a timely manner, by whatever means, to provide the specified services. 7.1.6 Equipment which implements OSS-compliant event reporting services allows the service user to reference equipment components by an object specifier; for example, “PM:ETCH>MFC:CCL4.” 7.2 Event Report Object Model — Figure 4 shows the objects, attributes (variables), and relationships involved in event reporting. The notation used is defined in Section 5. The diagram illustrates the relationships between the service’s messages and attributes (variables). The objects and their attributes are defined Section 8. Only the trace, data report, collection event, and data source\n\nSEMI E53-0704 EVENT REPORTING - # 7  Concepts (Part 4)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 7  Concepts\n\nContent: objects’ attributes and behaviors are standardized in that section. Note that this model presents a view of event reporting services from the perspective a single user. It is optional for the service provider to support simultaneous access from multiple service users. But for that option the provider shall present this view to each user independently. 7.2.1 Service Provider Object — The service provider is responsible for compiling report samples according to each service user setup. It detects collection events, provides trace timing and accesses the value of data source object attributes (variables) in order to compile the data reports. ERS does not specify the attributes or behavior of this object. It is included in the event report object model to provide context for other objects within ERS. 7.2.2 Service User Object — The service user is responsible for configuring its own event reporting setup and receives reports from the service provider according to that setup. ERS does not specify the attributes or behavior of this object. It is included in the event report\n\nSEMI E53-0704 EVENT REPORTING - # 7  Concepts (Part 5)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 7  Concepts\n\nContent: object model to provide context for other objects within ERS. However, the service user object shall be able to receive the event report send and trace report send messages from the service provider. 7.2.3 Collection Event Object — This object type or class is responsible to provide all the collection event identifiers for which event reports can be generated. Other factory services and objects may provide event notification messages which are important in the context of a service or functionality that they provide. But, in general, these notifications do not provide mechanisms to report information beyond their domain boundaries. For example, Processing Management, SEMI E40, includes an event notification for process complete (PRJobAlert (Milestone)). In order to collect data associated with this event, it must be “known” to the collection event object type. When it is “known” by the collection event object, then event reports can be generated using data or attributes from the data sources which are “known” by the event reporting service provider. A data source could\n\nSEMI E53-0704 EVENT REPORTING - # 7  Concepts (Part 6)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 7  Concepts\n\nContent: provide information on process chamber pressure and temperature, which are attributes or variables important to the process but which are not known to the processing management service. 7.2.4 Event and Data Source Objects — The use of the event source and data source objects provides extensive capability to access the attributes of objects in a distributed environment. Where the event services provider has a domain which extends over multiple resources, such as a cell controller for a furnace bay or a cluster tool controller, these objects provide an unambiguous mechanism for addressing the data that the service user wishes to access. 7.2.4.1 The event and data source objects are to the event reporting services what directory object is in a file system of a computer’s operating system. They should be thought of as containers of information which provide pointers (or names) of objects that are the actual sources of events or data. 7.2.4.2 The event source object is not directly accessible to the service user. Knowledge of events and event sources can be accumulated by\n\nSEMI E53-0704 EVENT REPORTING - # 7  Concepts (Part 7)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 7  Concepts\n\nContent: interrogation of the collection event object using OSS. 7.2.4.3 Collection event identifiers shall be determined by either of two possible methods. One, the equipment supplier may define and supply with the equipment a list of collection event IDs (identifiers). Two, the equipment’s collection event object can be interrogated with object services requests for collection event sources and identifiers. For example, using the second method, one could use object services to ask the collection event object for a list of collection event sources, which might include objects such as “PM:Etch>MFC:CCL4” or “TM $>$ Aligner.” Then using OSS, the collection event object can be queried for events associated with these sources. For the MFC a list of events might include “preslow,” “overlimit,” “valvemax,” etc. 7.2.5 Data Report Object — A data report defines the variables (or attributes) of a specific object (data source) which are to be sampled. Data reports are either pre-defined or defined dynamically by the service user. A data report sample is a set of data containing the values\n\nSEMI E53-0704 EVENT REPORTING - # 7  Concepts (Part 8)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 7  Concepts\n\nContent: of the variables defined for the data report. To sample a data report means that the current values of the variables at their data source object should be recorded. Data reports may be sampled and sent either with an event report and/or with a trace report. The service user may request: To sample an individual data report. Create a data report. Delete a data report. 7.2.6 Event Report — Event reports may be sent as messages to the service user whenever the associated collection event occurs. The collection event object is the source of the event report message. Event reporting is initially disabled. If the data to be sent with an event report has more than one data source, then there must be at least one data report for each data source to be included in the event report link definition. The service user may request: Event reporting to be enabled. Event reporting to be disabled. One or more data reports to be to linked (included in) the event report. 7.2.7 Trace Report — Trace reports are messages which are sent to the service user periodically. The trace report will\n\nSEMI E53-0704 EVENT REPORTING - # 7  Concepts (Part 9)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 7  Concepts\n\nContent: contain the value(s) of the data item(s) specified in the data report(s) referred to by the trace object which is the source of the trace report. 7.2.7.1 The trace object contains the description of what to include in the trace report and trace objects are either pre-defined or defined dynamically by the service user. The service user may request: Trace reporting to be enabled. Trace reporting to be disabled. One or more trace reports to be reset at any time to their initial state. One or more trace reports to be deleted at any time. 7.2.7.2 When the enabled attribute of the trace object is set, then trace reporting may be started or in response to a start event. When the trace reporting starts, the sample count is reset to zero. A trace report may be stopped when a certain number of samples have been reported or when a stop event occurs. 7.2.7.3 The service user may specify a trace object to be automatically deleted once it has been stopped by whichever mechanism. Otherwise, the trace reporting simply stops. If no start event is defined, then the trace is restarted\n\nSEMI E53-0704 EVENT REPORTING - # 7  Concepts (Part 10)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 7  Concepts\n\nContent: immediately. Otherwise, the next start event will restart the trace. Disabling or deleting a trace report stops reporting immediately. 7.3 Scenarios — The communications involved in event reporting are introduced below in the form of some representative scenarios. The full behavior and message set are covered in Sections 8.2 and 8.3 respectively. 7.3.1 Event Reporting — Figure 6 shows a scenario in which a data report is created by the service user and linked to an event report. Event reporting is then enabled. Subsequently, an event report is sent with the data reports attached whenever the collection event occurs. The service user then disables event reporting, preventing subsequent collection events from triggering the report. Data reports and links to event reports may be pre-defined by the equipment in which case the DataReportCreate and LinkCreate messages are omitted. 7.3.2 Trace Reporting — Figure 7 shows a scenario in which a trace object is created with enabled and AutoDelete both set to TRUE. Since the trace object is enabled and there is no start event\n\nSEMI E53-0704 EVENT REPORTING - # 7  Concepts (Part 11)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 7  Concepts\n\nContent: defined the data reports assigned to the trace object are sampled and sent immediately as a trace report message. The trace object timer is started and the sample counter set to zero. Each time the sample period elapses thereafter, a new trace report is sent, and the sample counter incremented. When the sample counter reaches the total samples parameter, then the trace report is automatically deleted. 7.3.3 Trace Reporting with Event Control — Figure 8 shows a scenario in which a trace object is created with enabled and AutoDelete both set to FALSE. There is also a start event (ProcessingStarted) and a stop event (ProcessingComplete) defined. When the start event occurs, the data reports assigned to the trace are sampled and sent, the trace timer is started and the sample counter set to zero. Each time the sample period elapses thereafter, a report is sent and the sample counter incremented. Since a total samples parameter was not specified, the trace report stops only when the stop event occurs. Once the stop event has occurred, the service user disables the trace\n\nSEMI E53-0704 EVENT REPORTING - # 7  Concepts (Part 12)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 7  Concepts\n\nContent: report preventing it from restarting when the next start event occurs. 7.3.4 Event Reporting with Non-predefined CollectionEvent Object — Additional capabilities of SEMI E39 (OSS) give Event Reporting standard more flexibility. For example, CollectionEvent objects can be created while equipment is running if the equipment has been installed the capability. If event sources are dynamically generated as process job, CollectionEvent objects must be created after the source is generated. If a user is not interested in such source, this capability is not required. However, if the user needs to get event report for such source, the capability is useful. This document doesn’t recommend nor suppress that but it’s depending on users.\n\nSEMI E53-0704 EVENT REPORTING - # 8.1  Object Definitions (Part 1)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 8.1  Object Definitions\n\nContent: 8.1.1 Collection Event Object — A collection event object generates an event report each time it is triggered by a collection event from an event source. An event report contains the data samples from zero or more data reports to which it is linked by the collection event object. Table 1 Collection Event Object Attribute Definitions 8.1.2 Data Report Object — The data report is part of the event reporting setup. It references zero or more attributes of a data source object and may be linked to zero or more event reports or trace reports. Table 2 Data Report Object Attribute Definitions 8.1.3 Trace Object — The trace object generates trace reports based on the settings of its attributes. Trace object activities may be started and stopped by a collection event and may refer to one or more data reports. Table 3 Trace Object Attribute Definitions 8.1.4 Data Source Object — The data source is an entity, accessible to the service provider, which contains data (attributes) that may be of interest to the service user. The event reporting service can be composed of\n\nSEMI E53-0704 EVENT REPORTING - # 8.1  Object Definitions (Part 2)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 8.1  Object Definitions\n\nContent: one or more data sources. In the case of only one data source, the use of its identifier in messages can be dropped. In this case, the data source is the default object. The attributes of a data source may be referenced by zero or more data reports. Table 4 Data Source Object Attribute Definitions 8.1.5 Event Source Object — This object represents components within a system that generate collection events. The service provider supplies mechanisms such that the when collection events are generated by the event source, then the collection event object, if enabled, will be triggered to generate an event report. ERS does not specify the attributes or behavior of the event source object. It is included in the event report object model to provide context for other objects within ERS. 8.2 Object Behaviors — This section specifies the behavior of the three objects in the information model which have standardized behaviors. The message detail for the service is addressed in a later section. Message flow diagrams presented in the previous section are useful to show\n\nSEMI E53-0704 EVENT REPORTING - # 8.1  Object Definitions (Part 3)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 8.1  Object Definitions\n\nContent: simple situations. The data report, event report and trace report state models presented in this section provide the information necessary to extrapolate the message flow diagrams for all situations within the scope of this standard. 8.2.1 Event Reporting State Models — The behavior required for event reporting is fully specified by the service provider state model. All required service user behavior is inferred by this model. 8.2.1.1 Figure 10 shows the state diagram for a collection event object. The Harel State Model Notation used is described in Section 5. Table 5 Collection Event Object State Definitions Table 6 Event Report Transition Table 8.2.2 Data Report Object State Model — Each data report shall follow the transitions as specified in Figure 11. Multiple instances of data report are managed by the event services. There are two basic types of data reports; predefined and user defined. Table 7 Data Report Object State Definitions Table 8 Data Report State Transition 8.2.3 Trace Object State Model — Figure 12 shows the state diagram for a trace\n\nSEMI E53-0704 EVENT REPORTING - # 8.1  Object Definitions (Part 4)\n\nTitle: SEMI E53-0704 EVENT REPORTING - # 8.1  Object Definitions\n\nContent: object. The Harel State Model Notation used is described Section 5. The state transition table is shown in Table 10. Table 9 Trace Object State Definitions\n\nSEMI E53-0704 EVENT REPORTING - # Table 10  Trace Object State Transition Table\n\n8.3  Messaging Services Detail — This section specifies the messages required to implement the event reporting service. The messages were introduced in Section 7.3.1. These services are independent of the messaging protocol used.  \nThe specification includes a list of required messages, the definition of the parameters contained within the messages, and data type of the parameters. Not defined here is the internal structure of the actual messages as transferred, including order of the parameters and how various data structures and data types are represented.  \nThe service message notation used in the tables below is described in the Conventions, Section 5.4.\n\nSEMI E53-0704 EVENT REPORTING - # 8.3.1  Service List\n\nTable 11  Event Reporting Services  \n8.3.2  Use Object Services — Attributes of the standardized objects listed in Table 12: SEMI E39 shall be accessed by using the GetAttr and SetAttr messages as defined in SEMI E39.\n\nSEMI E53-0704 EVENT REPORTING - # 8.3.3  Parameter Dictionary\n\nTable 13  Event Reporting Parameters  \n1  \nTable 14  Data Report Sample Parameter Detail  \nTable 15  Trace Report Sample Parameter Detail\n\nSEMI E53-0704 EVENT REPORTING - # 8.3.4  Service Detail\n\n8.3.4.1  Event Report Request — When the event object receives this message, it immediately generates and sends an event report to the service user.  \nTable 16  Event Report Request Service Detail  \n8.3.4.2  Event Report Send — This is a notification message to the service user. It contains the event report for the collection event which has triggered this action.\n\nSEMI E53-0704 EVENT REPORTING - # 8.3.4.3  Data Report Create\n\nTable 18  Data Report Create Service Detail\n\nSEMI E53-0704 EVENT REPORTING - # 8.3.4.4  Data Report Delete\n\nTable 19  Data Report Delete Service Detail  \n8.3.4.5  Data Report Request — Message asking the service provider to sample the data report and send the resulting report.\n\nSEMI E53-0704 EVENT REPORTING - # Table 24  Trace Delete Service Detail\n\n8.3.4.10  Trace Report Request — Request the data reports specified by the trace object ID be sampled and sent to the service user.  \nTable 25  Trace Report Request Service Detail  \n8.3.4.11  Trace Report Send — The notification message sent by the service provider to the service user when the trace object has prepared a trace report according to its definition.\n\nSEMI E53-0704 EVENT REPORTING - # Table 27  Trace Reset Service Detail\n\nNOTICE:  SEMI makes no warranties or representations as to the suitability of the standards set forth herein for any particular application. The determination of the suitability of the standard is solely the responsibility of the user. Users are cautioned to refer to manufacturer’s instructions, product labels, product data sheets, and other relevant literature respecting any materials mentioned herein. These standards are subject to change without notice.  \nThe user’s attention is called to the possibility that compliance with this standard may require use of copyrighted material or of an invention covered by patent rights. By publication of this standard, SEMI takes no position respecting the validity of any patent rights or copyrights asserted in connection with any item mentioned in this standard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and the risk of infringement of such rights, are entirely their own responsibility.\n\nSEMI E53.1-0704 SECS-II SUPPORT FOR EVENT REPORTING STANDARD\n\nThis standard was technically approved by the Global Information & Control Committee and is the direct responsibility of the Japanese Information & Control Committee. Current edition approved by the Japanese Regional Standards Committee on April 30, 2004.  Initially available at www.semi.org June 2004; to be published July 2004. Originally published December 1996.\n\nSEMI E53.1-0704 SECS-II SUPPORT FOR EVENT REPORTING STANDARD - # 1  Purpose\n\n1.1  This document maps the services and data of its prime document, SEMI E53, to SECS-II streams and functions and data definitions.\n\nSEMI E53.1-0704 SECS-II SUPPORT FOR EVENT REPORTING STANDARD - # 2  Scope\n\n2.1  This is the standard way to implement the Event Reporting, which provides event-based reporting using the SECS-II message format.  \nNOTICE: This standard does not purport to address safety issues, if any, associated with its use.  It is the responsibility of the users of this standard to establish appropriate safety and health practices and determine the applicability of regulatory or other limitations prior to use.\n\nSEMI E53.1-0704 SECS-II SUPPORT FOR EVENT REPORTING STANDARD - # 3.1  SEMI Standards\n\nSEMI E5 — SEMI Equipment Communications Standard 2 Message Content (SECS-II)  \nSEMI E39 — Object Services Standard: Concepts, Behavior, and Services  \nSEMI E39.1 — SECS-II Protocol for Object Services Standard (OSS)  \nSEMI E53 — Event Reporting  \nNOTICE: Unless otherwise indicated, all documents cited shall be the latest published versions.\n\nSEMI E53.1-0704 SECS-II SUPPORT FOR EVENT REPORTING STANDARD - # 4  Terminology\n\nNone.\n\nSEMI E53.1-0704 SECS-II SUPPORT FOR EVENT REPORTING STANDARD - # 5  Mapping of Event Reporting Messages\n\nTable 1  Event Messages Mapping\n\nSEMI E53.1-0704 SECS-II SUPPORT FOR EVENT REPORTING STANDARD - # 6  Event Parameters Mapping\n\nTable 2  Event Service Parameter Mapping\n\nSEMI E53.1-0704 SECS-II SUPPORT FOR EVENT REPORTING STANDARD - # 7  Implementation Details (Part 1)\n\nTitle: SEMI E53.1-0704 SECS-II SUPPORT FOR EVENT REPORTING STANDARD - # 7  Implementation Details\n\nContent: 7.1 Many of the messages of the Event Reporting Standard are implemented with currently defined SECS-II messages. Certain restrictions must be applied to their usage. These restrictions are specified in this section. 7.2 To be OSS-compliant, the following data items must use the format 20 specification: RPTID CEID TRID • VID 7.2.1 The format of the ASCII strings shall conform to the Object identifier specifications in the Object Services Standards, document SEMI E39 and SEMI E39.1. 7.3 Each Data Report sample, whether stand alone or as part of an Event or Trace report, will report TIMESTAMP as the first item in its list of report variables and/or object attributes. This means for reports defined by the service user, the user should define TIMESTAMP as the first VID in the report definition. Further, all of the service provider’s predefined reports shall deliver the value of TIMESTAMP in the first V. 7.4 Serveral capabilities of the Event Reporting Standard are accessed through the Object Services Standard. When an instance of\n\nSEMI E53.1-0704 SECS-II SUPPORT FOR EVENT REPORTING STANDARD - # 7  Implementation Details (Part 2)\n\nTitle: SEMI E53.1-0704 SECS-II SUPPORT FOR EVENT REPORTING STANDARD - # 7  Implementation Details\n\nContent: a report (Report, Event, or Trace) object has been created, then its attributes can be read and written using the Object Service’s GetAttr and SetAttr messages. 7.4.1 Object Services shall be used to set RPTOC and to get CHGND. 7.4.2 Object Services shall be used to set or clear CEED. 7.4.3 EVNTSRC shall be provided in supplier documentation or as a list of Event Sources obtained by using Object Services to interrogate the Collection Event Object, COLLEVENT, with the GetAttrName request message. 7.5 Event Reporting Services is protocol independent and therefore, makes no mention of SECS-II multiblock access and grant messages. When the Event Reporting Services use the SECS-II protocol, then S6F11,F13 shall be preceded by S6F5 if a report will be multi-block. Trace Report Send, S6F27 shall also use the multi-block access/grant transaction if the report will be multi-block. NOTICE: SEMI makes no warranties or representations as to the suitability of the standards set forth herein for any particular application. The determination\n\nSEMI E53.1-0704 SECS-II SUPPORT FOR EVENT REPORTING STANDARD - # 7  Implementation Details (Part 3)\n\nTitle: SEMI E53.1-0704 SECS-II SUPPORT FOR EVENT REPORTING STANDARD - # 7  Implementation Details\n\nContent: of the suitability of the standard is solely the responsibility of the user. Users are cautioned to refer to manufacturer’s instructions, product labels, product data sheets, and other relevant literature respecting any materials mentioned herein. These standards are subject to change without notice. The user’s attention is called to the possibility that compliance with this standard may require use of copyrighted material or of an invention covered by patent rights. By publication of this standard, SEMI takes no position respecting the validity of any patent rights or copyrights asserted in connection with any item mentioned in this standard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and the risk of infringement of such rights, are entirely their own responsibility.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD\n\nThis standard was technically reapproved by the Global Information and Control Committee and is the direct responsibility of the North American Information and Control Committee. Current edition approved by the North American Regional Standards Committee on March 14, 2004.  Initially available at www.semi.org May 2004; to be published July 2004. Originally published in 1997; previously published March 2003.  \nNOTICE:  The designation of SEMI E54 was updated during the 0705 publishing cycle to reflect the creation of SEMI E54.16 and SEMI E54.17.  \nNOTICE: The document that was previously designated as SEMI E54 (Standard for Sensor/Actuator Network Common Device Model) has been redesignated as SEMI E54.1.  Because the Sensor/Actuator Network Standard is the parent document, it has been designated as SEMI E54.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 1  Purpose\n\n1.1  This specification provides the structure of SEMI’s Sensor/Actuator Network (SAN) standard. It provides the definition for interoperability with respect to SEMI SAN standard-compliant Sensor/Actuator devices.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 2  Scope\n\n2.1  This standard specifies how devices interoperate on a network as part of the control system for equipment.  \n2.2  This specification, which is the root of the SAN standard, defines the relationships of each of the other specifications that are components of the SEMI SAN standard.  \nNOTICE: This standard does not purport to address safety issues, if any, associated with its use.  It is the responsibility of the users of this standard to establish appropriate safety and health practices and determine the applicability of regulatory or other limitations prior to use.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 3  Referenced Standards\n\n3.1  SEMI Standards  \nSEMI E30 — Generic Model for Communications and Control of SEMI Equipment (GEM)  \nSEMI E39 — Object Services Standard: Concepts, Behavior, and Services  \nSEMI E54.1 — Standard for Sensor/Actuator Network Common Device Model  \n3.2  Other Documents  \nISO $7 4 9 8 ^ { 1 }$ — Basic Reference Model for Open Systems Interconnection (OSI)  \nJames Rumbaugh, Michael Blaha, William Premerlani, Frederic Eddy, William Lorensen, Object-Oriented Modeling and Design, Englewood Cliffs, New Jersey: Prentice-Hall, 1991.  \nNOTICE: Unless otherwise indicated, all documents cited shall be the latest published versions.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 4  Terminology (Part 1)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 4  Terminology\n\nContent: 4.1 Abbreviations & Acronyms 4.1.1 API — Applications Programming Interface 4.1.2 CDM — Common Device Model. The root object application model for devices on the sensor bus. 4.1.3 DM — DeviceManager. An object specified in SEMI E54.1 (Standard for Sensor/Actuator Network Common Device Model). 4.1.4 IDL — Interface Definition Language. A programming language-independent notation for specifying interfaces. 4.1.5 ISO — International Organization for Standardization. 4.1.6 NCS — Network Communication Standard. Provides the specification for mapping the CDM and SDM to specific network technologies. These standards will be incorporated as parts of the SEMI SAN standard. 4.1.7 OEM — Original Equipment Manufacturer. They are usually the control system developer, but in any case they are almost always responsible for the control system. 4.1.8 OMT — Object Modeling Technique. A methodology developed by James Rumbaugh, et al. for using objects to model systems. 4.1.9 OSI — Open System Interconnection. A seven-layer model for communications developed by ISO.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 4  Terminology (Part 2)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 4  Terminology\n\nContent: 4.1.10 OSS — Object Services Standard. SEMI E39. 4.1.11 SAN — Sensor/Actuator Network. It is frequently used to reference this standard. 4.1.12 SDM — Specific Device Model. This is an application model for a specific type of sensor, actuator, or entity 4.2 Definitions 4.2.1 application — for software, this is a working series of computer instructions that provide end user services. 4.2.2 applications model — a formal description of the software elements and interactions that perform an end user task. 4.2.3 entity — in software engineering, this is something that is recognizable as distinct and particular from the other things that make up a software system or program. 4.2.4 interface — in information modeling, it is the boundary between two entities from which information will flow. 4.2.5 user layer — in communications, this is a set software function connected to the communication protocol's top layer, usually called the applications layer, from the user’s application environment. It typically allows the user application to be protocol-independent.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 5  Overview (Part 1)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 5  Overview\n\nContent: 5.1 Referring to Figure 1, the SAN standards specify a complete communications solution covering all the layers of the OSI reference model. The CDM and SDM together specify a protocol-independent set of application services, attributes, and behavior for a device that must be supported by the user layer as shown in Figure 1. An NCS completes the specification of the user layer by specifying a mapping to a network technology’s interface. The NCS must specify its capabilities referenced against the ISO OSI Reference Model. An NCS may utilize an open or commercial solution. In any case, the NCS will provide references to those solution’s specifications. 5.2 Generally, the functionality of a software layer is embodied by the definition of the services it provides. Its services are the set of messages it generates and to which it responds, and its subsequent behavior upon receipt of any particular message. The CDM and an SDM provide a complete user layer specification in a platform and language-neutral form (dotted line in Figure 1). The goal being to provide\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 5  Overview (Part 2)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 5  Overview\n\nContent: device interoperability at the applications level. The NCS will guarantee interoperability at the network level (i.e., across a single type of network). The SAN standard does not require implementation of the top interface to the user layer, as specified by the CDM and an SDM. The CDM and an SDM provide the information needed to develop an NCS, which defines the interface requirement between the user layer and a specific network technologies communication layer (the solid line labeled as Network Interface). This means that the SAN standard allows user applications, whether from the device or the controller side implementation viewpoint, to interact directly with a network technologies interface.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 5.3  Network Technology Supplier View of the SAN Standard\n\n5.3.1  The CDM and an SDM together specify the messages, behavior, and attributes of a device type that will be visible over the network. In Figure 1, this is the area above the line that indicates the protocol-independent interface. Network suppliers will map this information to the top layer of their protocol. They do this by helping to develop and extend their NCS.  \n5.3.2  Most network suppliers have an application layer already defined for their protocol. In that case, the user layer as specified in a SEMI SAN NCS is quite thin. In fact, it is just a simple mapping of SDM interface to messages and data (attributes) provided by the network. Thus, an NCS (one for each supported network) specifies a user layer that sits on top of the network supplier’s protocol.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 5.4  Device Supplier View of the SAN Standard\n\n5.4.1  Device suppliers are not required to implement designs illustrated in the specific device model (SDM) specifications. The designs are presented using an object-modeling notation as a means to clearly specify the devices interface. An SDM provides a model of a device, it is not a design for the device. Device suppliers are not expected to provide an object-oriented implementation. However, in order to ensure that a device interface responds as expected, it is necessary for the device supplier to not only provide the support for the services and attributes specified, but to ensure that the code that is implemented on the device behaves as specified by the applications model for a specific device type.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 5.5  Equipment Supplier View of the SAN Standard\n\n5.5.1  The OEM’s have the largest task in adopting the SAN standard. They have to implement applications that use the interfaces defined for the many devices that make up the typical equipment control system. They have to be  \nfamiliar with the interfaces of a large number of the SDMs. On the other hand, they will become insulated from the inner workings of many devices, and from the code that they used to write to support those inner workings. In many cases, they may have to implement more than one Network Communication Standard.  \n5.5.2  During early adoption, OEM’s may look to the SAN to act as a replacement for memory mapped discrete wired IO. With this type of adoption, the OEM will not lessen his burden of control code.  \n5.5.3  As Sensor Bus becomes more broadly adopted, OEM's may take advantage of the distributed processing capability offered by intelligent devices to reduce the complexity of their control software.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 5.6  The SAN Standard Structure (Part 1)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 5.6  The SAN Standard Structure\n\nContent: 5.6.1 A SAN employs devices from numerous sup-pliers. The SEMI SAN standard provides a framework to ensure interoperability of these devices within a network. The standard enables device suppliers and equipment control system developers to achieve that end. The SAN standard comprises five specifications. 5.6.2 The first specification is this document, which is the root document and specifies the connection between the other documents of the standard. It also specifies the construction for each of the other documents. 5.6.3 The next specification is the Common Device Model Specification. Each device on the SAN must comply with this specification. 5.6.4 The third specification defines the templates for creating ballots for specific device models and additions to the NCS. 5.6.5 The fourth specification is Specific Device Models standard. These standards contain models for various types of sensors, actuators, and entities. For instance, a model of a mass flow controller, a manometer, and a thermocouple will be specified. 5.6.6 The fifth\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 5.6  The SAN Standard Structure (Part 2)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 5.6  The SAN Standard Structure\n\nContent: type of specification is the Network Communication Standards. Each network technology has its own standard as an ancillary specification to the SAN standard. 5.6.7 Applications notes may accompany a number of the standards documents and are intended to guide implementors in the application of the standard.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 6  Concepts (Part 1)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 6  Concepts\n\nContent: 6.1 Minimal device — The SAN specifications allow simple and complex devices to be built compliant to the standard. This is done by specifying a minimum of required attributes, services, and behaviors in an SDM. The SDMs may also provide optional service definitions that must be followed if extended capabilities are to be built into a device. Devices that do not implement the extended capabilities must respond to extended service or access requests with an appropriate response code rather than failing to respond or issuing an exception or alarm message. 6.2 Many of the SAN NCS specifications rely on commercial technology. A significant number of network technologies are available off-the-shelf. The standards do not prescribe a choice. Once a technology described in an NCS is chosen, the NCS specifies how it is to be applied. The SAN standard is easily extensible for future technologies. 6.3 A device supplier must be able to use the standard to describe a device with little or no ambiguity for the device users. For the user, this means that he can select\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 6  Concepts (Part 2)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 6  Concepts\n\nContent: a device with confidence and that it can be easily integrated with his control system. The user must understand the electrical interface, the capabilities, and messages which a device supports based on the supplier’s description of how this standard is supported by the device.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 7  Requirements (Part 1)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 7  Requirements\n\nContent: 7.1 Organization of the SAN Specifications — Figures 2 and 3 are intended to assist in understanding the document relationships that are specified in the following subsections. In these figures, all specifications that are standards are drawn as rounded rectangles. In Figure 3, the shadowed rectangles indicate the standards that contain requirements for implementing devices that are compliant to this standard. 7.1.1 The CDM specification is the first ancillary document of the SAN suite. 7.1.2 A second ancillary specification to the SAN standard provides templates that are guides to adding specific device models and network communication mappings to the SAN standard. 7.1.3 Specifications for specific device models for all types of devices are included as additional ancillary specifications of the SEMI SAN standard. Specific device models are added in the order they are developed and passed SEMI’s ballot procedure. 7.1.4 Each network technology’s user layer specification is included as an ancillary standard (see Figure 3). These Network Communication\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 7  Requirements (Part 2)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 7  Requirements\n\nContent: Standards (NCS) provide the mapping for each of the approved specific device models. Therefore, each NCS is also a specification that grows over time. As new device models are developed and approved, a mapping of the model to a network technology is added to a NCS. 7.1.5 Auxiliary Information — Auxiliary information may be included with the standard in the form of appendices or technical notes. Generally, this information is not balloted, but is included as provided by the SEMI Standards Program regulations. Auxiliary information shall always be noted as such when it accompanies a specification or ballot.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 7.2  Interoperability (Part 1)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 7.2  Interoperability\n\nContent: 7.2.1 At the Applications Level — The SDMs are used to derive the definitions for attributes, services, and behavior that are unique to each device type. A model may discuss relationships internal to a device to provide additional meaning to the services and attributes that can be manipulated over the network. Applications written to these models can operate a device independent of the network on which they communicate. The models shall assure that devices of different types can operate cooperatively at the applications level. 7.2.2 Below the User Layer — The various SANCS specifications describe the method by which a device communicates over a specific network such that it can meet the requirements of its type. All devices described within an NCS shall operate cooperatively on that specific network technology below the user layer. 7.2.3 The SEMI SAN standard does not address methods for internet-working below the applications layer, as described herein. An application entity may connect to more than one network. This could be typical of the\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 7.2  Interoperability (Part 2)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 7.2  Interoperability\n\nContent: application entities on the equipment controller. While the SAN standard allows that application entities could exist at any network node, it requires no mechanism for a message that begins on one network to be routed to another network. 7.3 SEMI SAN Compliance — To fully describe the characteristics of a network capable device, its compliance shall be specified by reference to the SAN ancillary standards. Thus, a device indicates both its type and network technology for its SDM and a NCS. 7.3.1 For a device to be compliant to the SAN standard, it shall implement all of the required attributes, behavior, and services as described in the SAN CDM. 7.3.2 Type or Applications Model Specification — The SDM of a device (which is its type, e.g., MFC o thermocouple) shall be denoted by SEMI E54.y, where “y” indicates the SDM ancillary standard. 7.3.3 Network Communication Specification Communication (protocol) compliance specification of a device is denoted by SEMI E54.x, where “x” is the network communications ancillary specification. NOTICE: SEMI\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 7.2  Interoperability (Part 3)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # 7.2  Interoperability\n\nContent: makes no warranties or representations as to the suitability of the standard set forth herein for any particular application. The determination of the suitability of the standard is solely the responsibility of the user. Users are cautioned to refer to manufacturer’s instructions, product labels, product data sheets, and other relevant literature respecting any materials mentioned herein. These standards are subject to change without notice. The user’s attention is called to the possibility that compliance with this standard may require use of copyrighted material or of an invention covered by patent rights. By publication of this standard, SEMI takes no position respecting the validity of any patent rights or copyrights asserted in connection with any item mentioned in this standard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and the risk of infringement of such rights, are entirely their own responsibility.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # RELATED INFORMATION 1 APPLICATION NOTES\n\nNOTICE: The material contained in these Application Notes is not an official part of SEMI E54 and is not intended to modify or supersede the official standard. Rather, these notes are auxiliary information included as reference material for implementers of the standard. The standard should be referred to in all cases. SEMI makes no warranties or representations as to the suitability of the material set forth herein for any particular application. The determination of the suitability of this material for any particular purpose is solely the responsibility of the user.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device (Part 1)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device\n\nContent: R1-1.1 This Related Information section describes how the SAN standard is used by a device supplier who wishes to offer SEMI SAN-compliant devices to the market. R1-1.2 While the SAN standard may appear overwhelming on first viewing, it is actually built from independent components. It is not necessary to understand or ‘know’ the entire standard. It can be dealt with in small pieces. For device suppliers, only the pieces that deal with their particular device type need to be considered. The specifications to implement a specific device are typically less than thirty pages of text. The standard is structured such that it is extensible while providing the ability to specify a device by reference to the standard. R1-1.3 Synopsis of Device Operation — All devices on a SAN have a similar operational profile. That profile is specified in SEMI E54.1 (Standard for Sensor/Actuator Network Common Device Model) and in the Common Device Model support section of each NCS. R1-1.3.1 Table R1-1 explains where to find specifications\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device (Part 2)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device\n\nContent: for various device operations. R1-1.4 Device Type — Each type of device is specified in the SDM specifications. One SDM is devoted to each device type. An SDM is always a specialization of the CDM. The SDM provides services, behavior, and attributes that are in addition to those specified in the CDM. For example, the SDM of a manometer might specify attributes for current pressure and alarm bands. It might have services needed for performing calibration. R1-1.5 Network Technology — How a network technology is used by the SAN standard is specified in an NCS. The NCS for a technology provides a mapping of the CDM and SDM of a device type to a specific network protocol. R1-1.5.1 It is only necessary for a device to support an NCS and the section for its type within that NCS. The NCS provides all that is needed to ensure that a device can communicate and interoperate across a given network technology. The point is that from the other side of the wire, the network-independent interface is not visible. That interface is\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device (Part 3)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device\n\nContent: implied by the behavior of the network interface. R1-1.6 Network Independence — Device suppliers have the option of supplying an interface at the protocolindependent applications layer, as indicated in Figure 1. While this requires more implementation work for the device supplier, it speeds the integration of sensors and actuators for the OEM. R1-1.6.1 In this case, it is still necessary for the device to support the NCS to ensure that their device will interoperate with other devices on the network. R1-1.6.2 To supply this option, a device supplier would provide a device driver-like interface (software) to the OEM. R1-1.6.3 Devices that supply a protocol-independent API that is compliant to the SEMI SAN standard provide advantages to both device and control system suppliers. The device supplier can assure that his device receives syntactically correct messages at his network interface layer. Control applications written to the protocolindependent interfaces have the advantage that they would not have to be\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device (Part 4)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device\n\nContent: rewritten in order to change to another network. To achieve this, device suppliers would have to ship software, in the form of ‘device drivers’, that would be installed on the control supplier's platform. NOTE 1: Standards for these ‘device drivers’ may be developed at a later time as they do not currently exist. However, most operating systems used by control systems suppliers support installable device drivers. R1-1.7 Recommendations on Optional and Extended Device Capabilities — It is expected that device suppliers would not compete based on their network interface. Devices traditionally compete based on cost, service, stability, reliability, accuracy and repeatability, and relevant dynamic attributes. From a network perspective, all devices have these common characteristics: periodic reporting, polled reporting, asynchronous event reporting, calibration, health, and diagnostic reporting. Access and control over the common characteristics should be implemented based on the SAN standard. Access and control of the\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device (Part 5)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device\n\nContent: competitive characteristics of devices may be implemented with supplierspecific interface extensions. However, the device supplier is strongly cautioned in the use of these extensions. Heavy use of extensions could be a serious competitive disadvantage unless the supplier is the clear winner in all the competitive characteristics. A locked door could lock one in, it could also lock one out. Device suppliers will usually find that their extensions can be implemented using the optional features of the CDM and SDM. NOTE 2: Network interfaces could be a competitive factor during the early technology adoption phase. R1-1.8 The Controller Side Usage of the SAN Standard — The control system supplier (in many cases this is the OEM) evolves a different view of SEMI’s SAN standard. They are not as concerned with the network technology as with utilizing the applications capabilities as specified by the CDM and SDMs. It is strongly recommended that control applications not be network aware. This may produce some operating\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device (Part 6)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device\n\nContent: overhead, but for most applications, this is a good trade-off to gain flexibility provided by a protocol-independent interface. Many network devices may be supplied without any user layer (device driver) application side software. For these devices, the control system supplier would have to do some system’s programming to provide a device driver for the application interface. Over time, it is likely that most devices will be delivered with a device driver. (Similar to the way printers are sold with Windows (TM) device drivers. This is what allows Windows applications to use a printer of the end users choosing.) R1-1.8.1 The standards as of 1996 do not provide all the specifications needed to uniquely define how device drivers would be installed in the controller side of the API. This may become a future area of standardization, if OEMs decide to invest in the standard’s development time. R1-1.9 Device Intelligence — This varies considerably between device types and between devices of the same type. SEMI SAN\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device (Part 7)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device\n\nContent: specifications attempt to allow a range of intelligence to devices without forcing them to be ‘highly’ intelligent. To this end, the applications models specify a required minimum set of capabilities that must be supported for a device. Optional capabilities generally require more intelligent device operation. Devices that are not capable of supporting these extended capabilities provide a “not implemented” indication if access to those capabilities is requested. R1-1.9.1 The following subsections describe device capabilities in order of increasing intelligence. A device’s I/O direction is defined relative to the control application entity. Therefore, a sensor is an input, even though from the sensor’s point of view it supplies output values. R1-1.9.2 Polled input is the simplest sensor device requirement. All sensing devices should meet this requirement. In this mode of operation, a device only reports its value(s) when requested. This mode potentially provides the biggest burden on network bandwidth. However, it\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device (Part 8)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device\n\nContent: is the capability level that is most compatible with current control system architectures. R1-1.9.3 Strobed output is the simplest actuator device requirement. All actuating devices should meet this requirement. This device only changes to a new state at the time of receipt of a specific message to do so. R1-1.9.4 Periodic input is the capability to program the input device so that it sends its value(s) on a scheduled or periodic basis. Network bandwidth burden is reduced because it is not required to send a request each time an update for the input value is needed. R1-1.9.4.1 This is also very compatible with current control architectures. R1-1.9.5 Asynchronous input provides a capability for a sensing device to supply its value(s) when an event is detected. These events are usually programmed into the device. Examples of programmable events include threshold crossing of a value, value rate of change, measurement complete. R1-1.9.5.1 Devices with this capability can significantly reduce network bandwidth burden,\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device (Part 9)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device\n\nContent: because they only need the network when some event has occurred. Equipment control architectures developed before 1990 may not be able to utilize this type of capability. R1-1.9.6 Programmed output provides the capability for actuating devices to follow a programmable sequence of operations. For instance, an analog output could be given a ramp profile to follow as it moves between set points. R1-1.9.6.1 This is another capability which can greatly reduce network bandwidth requirements. But, it is also a capability that 1990 vintage and earlier control systems may not be able to utilize easily. R1-1.9.7 Devices with distributed processing capabilities are able to support features such as monitoring their health, providing diagnostics, and programmable preprocessing of data. R1-1.9.7.1 These capabilities can have an impact on network burden, but more importantly may improve equipment reliability and maintainability. Again, this is a capability that is not readily utilized by control architectures developed prior to\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device (Part 10)\n\nTitle: SEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R1-1  Implementing a SAN Standard-Compliant Device\n\nContent: 1990. R1-1.9.8 Devices with distributed control capabilities are capable of being programmed to create peer relationships with other devices on the network. Within these relationships, it is possible for one or more of the peers to control or regulate a subsystem within the equipment. For instance, a butterfly valve and manometer with these capabilities could be programmed to hold a particular pressure.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # RELATED INFORMATION 2 INDEX FOR SENSOR/ACTUATOR STANDARDS\n\nNOTICE: This related information is not an official part of SEMI E54 and is not intended to modify or supercede the official standard. After approval of this document, publication of this Related Information was authorized by the committee chairs solely to aid in identifying the relationships between the current Sensor Bus standards and documents in process. Determination of the suitability of the material is solely the responsibility of the user.\n\nSEMI E54-0705 SENSOR/ACTUATOR NETWORK STANDARD - # R2-1  Scope\n\nR2-1.1  The table below is based on Figure 1 in SEMI E54.1, and is intended to show the relationships between standards that are currently published, as well as describe documents in process in SEMI Standards that, if approved, will be added to SEMI E54.  \nR2-1.2  There are five categories:  \nMain Document\nTemplates\nSpecific Device Model\nCommon Device Model\nNetwork Communication Standards  \nR2-1.3  Standard titles with a designation number are published documents, and descriptors without designation numbers are documents in process.",
  "images": []
}